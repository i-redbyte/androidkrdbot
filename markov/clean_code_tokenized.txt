Роберт Мартин ЧИСТЫЙ КОД Предисловие В Дании очень популярны леденцы - . Их сильный лакричный вкус отлично скрашивает нашу сырую и часто холодную погоду . Однако нас , датчан , леденцы - привлекают еще и мудрыми или остроумными высказываниями , напечатанными на крышке каждой коробки . Сегодня утром я купил две коробки леденцов и обнаружил на них старую датскую поговорку : ? . «Честность в мелочах — вовсе не мелочь» . Это было хорошим предзнаменованием , которое полностью соответствовало тому , о чем я собирался написать в предисловии . Мелочи важны . Эта книга посвящена вещам простым , но вовсе не малозначительным . Бог скрывается в мелочах , сказал архитектор Людвиг Мис ван дер Роэ . Эта цитата напоминает о недавних дебатах о роли архитектуры в разработке программного обеспечения и особенно в мире гибких методологий . Мы с Бобом время от времени увлеченно вступаем в этот диалог . Да , Мис ван дер Роэ проявлял внимание и к удобству , и к неподвластным времени строительным формам , лежащим в основе великой архитектуры . С другой стороны , он также лично выбирал каждую дверную ручку для каждого спроектированного им дома . Почему ? Да потому , что мелочи важны . В наших с Бобом непрестанных «дебатах» о выяснилось , что мы согласны с тем , что архитектура играет важную роль при разработке , хотя мы по - разному смотрим на то , какой смысл вкладывается в это утверждение . Впрочем , эти разногласия относительно несущественны , так как мы считаем само собой разумеющимся , что ответственные профессионалы выделяютнекотороевремя на обдумывание и планирование проекта . Появившиеся в конце - х концепции проектирования , зависящеготолькоот тестов и кода , давно прошли . Тем не менее внимание к мелочам является еще более важным аспектом профессионализма , чем любые грандиозные планы . Во - первых , благодаря практике в мелочах профессионалы приобретают квалификацию и репутацию для серьезных проектов . Во - вторых , даже мельчайшее проявление небрежности при строительстве — дверь , которая неплотно закрывается , или криво положенная плитка на полу , или даже захламленный стол — полностью рассеивает очарование всего сооружения . Чтобы этого не происходило с вашими программами , код должен быть чистым . Впрочем , архитектура — всего лишь одна из метафор для разработки программных продуктов . Она лучше всего подходит для проектов , в которых продукт «возводится» в том же смысле , в каком архитектор возводит строение . В эпоху и гибких методологий основное внимание уделяется быстрому выводу продукта на рынок . Фабрики , производящие программные продукты , должны работать на максимальной скорости . Однако этими «фабриками» являются живые люди : мыслящие , чувствующие программисты , работающие над пожеланиями пользователей или историей продукта для создания новых продуктов . Метафора производства сейчас как никогда сильна в их мировоззрениях . Скажем , методология во многом вдохновлена производственными аспектами японского автостроения с его конвейерами . Но даже в автостроении основная часть работы связана не с производством , а с сопровождением продуктов — или его отсутствием . В программировании % и более того , что мы делаем , тоже изящно называется «сопровождением» . На самом деле речь идет о починке . Наша работа ближе к работе домашних мастеров в строительной отрасли или автомехаников в области автостроения . Что японская теория управления говорит по этому поводу ? В году в японской промышленности появилась методология повышения качества , называвшаяся . Она была ориентирована прежде всего на сопровождение , а не на производство . Доктрина базировалась на так называемых «принципах » . В сущности , принципы представляют собой набор житейских правил . Кстати говоря , они также заложены в основу методологии — другого модного течения на западной сцене , набирающего обороты и в программных кругах . Как указывает Дядюшка Боб в своем введении , хорошая практика программирования требует таких качеств , как сосредоточенность , присутствие духа и мышление . Проблемы не всегда решаются простым действием , максимальной загрузкой оборудования для производства в оптимальном темпе . Философия состоит из следующих концепций : • Сэйри , или организация . Абсолютно необходимо знать , где что находится — и в этом помогают такие методы , как грамотный выбор имен . Думаете , выбор имен идентификаторов неважен ? Почитайте следующие главы . • Сэйтон , или аккуратность . Старая американская поговорка гласит : всему свое место , и все оказывается на своих местах . Фрагмент кода должен находиться там , где читатель кодаожидает его найти , — а если он находится где - то в другом месте , переработайте свой код и разместите его там , где ему положено быть . • Сэйсо , или чистка . Рабочее место должно быть свободно от висящих проводов , грязи , мусора и хлама . Что в этой книге говорят авторы о загромождении кода комментариями и закомментированными строками кода ? Они советуют от них избавиться . • Сэйкэцу , или стандартизация : группа достигает согласия по поводу того , как поддерживать чистоту на рабочем месте . Что в этой книге сказано о наличии единого стиля кодирования и набора правил в группах ? Откуда берутся эти стандарты ? Прочитайте — узнаете . • Сюцукэ , или дисциплина . Программист должен быть достаточно дисциплинированным , чтобы следовать правилам , он должен часто размышлять о своей работе и быть готовым к изменениям . Если вы не пожалеете усилий — да , усилий ! — чтобы прочитать и применять эту книгу , вы научитесь понимать последний пункт . Мы наконец - то подошли к корням ответственного профессионализма в профессии , которая должна пристально интересоваться жизненным циклом продукта . В ходе сопровождения автомобилей и других машин по правилам , аварийный ремонт аналог проявления ошибок является исключением . Вместо этого мы ежедневно осматриваем машины и заменяем изнашивающиеся части до того , как они сломаются , или выполняем аналоги знаменитой «смены масла каждые миль» для предотвращения износа . Безжалостно перерабатывайте свой код . А еще можно сделать следующий шаг , который считался новаторским в движении более лет назад : строить машины , изначально ориентированные на удобство сопровождения . Ваш код должен не только работать , но и хорошо читаться . Как нас учит Фред Брукс , крупные блоки программного кода стоит переписывать «с нуля» каждые семь лет или около того , чтобы они не обрастали мхом . Но может быть , временную константу Брукса стоит вывести на уровень недель , дней и часов вместо годов . Именно на этом уровне живут мелочи . В мелочах кроется огромная сила , но при этом такой подход к жизни выглядит скромно и основательно , как мы стереотипно ожидаем от любого метода с японскими корнями . Однако такой взгляд на жизнь не является чисто восточным в западной народной мудрости можно найти немало наставлений такого рода . Цитата , приведенная ранее при описании принципасэйтон , принадлежит перу министра из Огайо , который буквально рассматривал аккуратность «как средство от любого зла» . Как насчетсэйсо ? Чистота ведет к Божественности . Каким бы красивым ни был дом , захламленный стол портит все впечатление . А что говорят осюцукэ ? Тот , кто верен в мелочах , верен во всем . Стремление к переработке кода , укрепление позиций для последующих «серьезных» решений — вместо того , чтобы откладывать переработку «на потом» ? Ранняя пташка червяка ловит . Не откладывай на завтра то , что можно сделать сегодня . Фраза «последний ответственный момент» в методологии имела именно такой смысл , пока не попала в руки консультантов по разработке ПО . Как насчет места малых , индивидуальных усилий в общей картине ? Из маленьких желудей вырастают большие дубы . Интеграция простой профилактической работы в повседневную жизнь ? Яблочко на ужин , и доктор не нужен . Дорога ложка к обеду . Чистый код уважает глубокие корни мудрости , лежащие в основе нашей культуры — той , которой она когда - то была или должна быть , и может быть при должном внимании к мелочам . Даже в литературе по архитектуре мы находим фразы , возвращающие нас к важной роли мелочей . Вспомните дверные ручки ван дер Роэ . Сэйрив чистом виде . Внимание к имени каждой переменной . Имя переменной должно выбираться так же тщательно , как и имя новорожденного . Как известно любому домовладельцу , такая забота и непрерывное стремление к улучшению никогда не приходят к концу . Архитектор Кристофер Александр — отец паттернов и языка паттернов — рассматривает каждый акт проектирования как маленький , локальный акт восстановления . С его точки зрения мастерство тонкой структуры является единственным содержанием архитектуры более крупные формы можно оставить на долю паттернов , а их применение — на долю жильцов . Проектирование продолжается не только с пристройкой к дому новых комнат , но и с покраской , заменой старых ковров или кухонной раковины . Аналогичные принципы действуют во многих видах искусства . В поисках других мастеров , считавших , что Бог живет в мелочах , мы оказываемся в славной компании французского писателя века Гюстава Флобера . Французский поэт Поль Валери говорит о том , что стихотворение никогда не бывает законченным , что оно требует постоянной переработки , а прекратить работу над ним — значит бросить его . Такоеповышенное внимание к мелочам характерно для всех настоящих творцов . Возможно , принципиального нового здесь не так уж много , но эта книга напомнит вам о необходимости следовать житейским правилам , которые вы давно забросили из безразличия или стремления к стихийности , к простой «реакции на изменения» . К сожалению , описанные аспекты редко рассматриваются как краеугольные камни искусства программирования . Мы рано бросаем свой код — и не потому , что он идеален , а потому , что наша система ценностей сосредоточена на внешнем виде , а не на внутренней сущности того , что мы делаем . Невнимательность в конечном итоге обходится недешево : фальшивая монета всегда возвращается к своему владельцу . Исследования — ни отраслевые , ни академические — не желают опускаться до скромной области поддержания чистоты кода . В те времена , когда я работал в Исследовательской организации по производству программного обеспечения , в ходе исследований выяснилось , что последовательный стиль применения отступов является одним изсамых статистически значимых признаков низкой плотности ошибок . Мы хотим , чтобы причиной качества была архитектура , язык программирования или что - то другое , столь же почтенное . Нас как людей , чей предполагаемый профессионализм обусловлен мастерским владением инструментами и методами проектирования , оскорбляет сама идея , что простое последовательное применение отступов может иметь такую ценность . Цитируя свою собственную книгу - летней давности , скажу , что такой стиль отличает совершенство от простой компетентности . Японское мировоззрение сознает критическую важность каждого рядового рабочего , и что еще важнее — систем разработки , существующих благодаря простым повседневным действиям этих рабочих . Качество возникает в результате миллиона проявлений небезразличного отношения к делу , — а не от применения какого - то великого метода , спустившегося с небес . Простота этих проявлений не означает их примитивности и даже не свидетельствует об их легкости . Тем не менееиз них возникает величие и , более того , — красота любого человеческого начинания . Забыть о них значит не быть человеком в полной мере . Конечно , я по - прежнему выступаю за широту мышления и особенно за ценность архитектурных подходов , корни которых уходят в глубокое знание предметной области и удобство использования программных продуктов . Книга написана не об этом , или , по крайней мере , в ней эта тема не рассматривается напрямую . Она несет более тонкий посыл , глубину которого не стоит недооценивать . Она соответствует текущим мировоззрениям настоящих программистов — таких , как Питер Соммерлад , Кевлин Хенни и Джованни Аспрони . «Код есть архитектура» и «простой код» — так звучат их мантры . Хотя мы не должны забывать , что интерфейс и есть программа и что его структурные элементы несут много информации о структуре программы , очень важно помнить , что архитектура живет в коде . И если пераработка в производственной метафоре ведет к затратам , переработка в архитектурной метафоре ведет к повышению ценности . Рассматривайте свой код как красивое воплощение благородных усилий по проектированию — как процесса , а не как статической конечной точки . Архитектурные метрики привязки и связности проявляются именно в коде . Если вы послушаете , как Ларри Константайн описывает привязку и связность , он говорит о них в контексте кода , а не величественных абстрактных концепций , которые обычно встречаются в . Ричард Гэбриел в своем эссе « » утверждает , что абстракция — зло . Так вот , код — это антизло , а чистый код , вероятно , имеет божественную природу . Возвращаясь к своему примеру с коробочкой - , подчеркну один важный момент : датская народная мудрость рекомендует нам не только обращать внимание на мелочи , но и бытьчестнымив мелочах . Это означает честность в коде , честность с коллегами и , что самое важное , — честность перед самим собой по поводу состояния вашего кода . Действительно лимы сделали все возможное для того , чтобы «оставить место лагеря чище , чем было до нашего прихода» ? Переработали ли свой код перед тем , как сдавать его ? Эти проблемы лежат в самом сердце системы ценностей . Методология указывает , чтобы переработка кода должна стать частью концепции «готовности» . Ни архитектура , ни чистый код не требуют от нас совершенства — просто будьте честны и делайте все , что можете . Человеку свойственно ошибаться небесам свойственно прощать . В методологии все тайное становится явным . Мы выставляем напоказ свое грязное белье . Мы честно демонстрируем состояние нашего кода , а ведь код никогда не бывает идеальным . Мы становимся более человечными и приближаемая к величию в мелочах . В нашей профессии нам отчаянно нужна вся помощь , которую мы можем получить . Если чистый пол в магазине сокращает вероятность несчастных случаев , а аккуратно разложенные инструменты повышают производительность , то я обеими руками «за» . Что касается этой книги , то она является лучшим практическим применением принципов в области разработки программного обеспечения , которое я когда - либо видел в печатном виде . Впрочем , я иного и не ожидал от этой небольшой группы мыслящих личностей , которые в течение многих лет стремятся не только узнать что - то новое , но и делятся своими знаниями с нами в книгах , одну из которых вы сейчас держите в руках . Мир стал чуть более совершенным , чем был до того момента , когда Дядюшка Боб прислал мне рукопись . Завершая свои высокопарные размышления , я отправляюсь наводить порядок на своем столе . Джеймс О . КоплинМёрруп , Дания Введение Картинка : _ . С любезного разрешения Тома Холверда : . . _ Какая из двух дверей характерна для вашего кода ? Какая дверь характерна для вашей группы или компании ? Почему вы попали именно в эту комнату ? В ней идет нормальный анализ кода или сразу же после выпуска программы обнаружился целый поток ужасных ошибок ? Отладка идет в панике , вы просматриваете код , который , как считалось , уже работает ? Клиенты уходят от вас целыми толпами , а начальство дышит в затылок ? Как оказаться заправильнойдверью , когда дела пойдут плохо ? Ответ : профессионализм . Профессионализм имеет две составляющие : знания и практический опыт . Вы должны узнать принципы , паттерны , приемы и эвристические правила , известные каждому профессионалу , а также «втереть» полученные знания в свои пальцы , глаза и внутренности усердной работой и практикой . Я могу объяснить вам физику езды на велосипеде . В самом деле , классическая физика относительно прямолинейна . Сила тяжести , сила трения , ротационный момент , центр тяжести и т . д . — все это можно описать менее чем на одной странице уравнений . Этими формулами я докажу вам , что езда на велосипеде возможна , и предоставлю всю необходимую для этого информацию . Но когда вы впервые заберетесь на велосипед , вы все равно неизбежно упадете . С программированием дело обстоит точно так же . Конечно , мы могли бы записать все «хорошие» принципы чистого кода , а потом доверить вам всю практическую работу другими словами , позволить вам упасть , забравшись на велосипед , но какие бы из нас тогда были учителя ? Нет . В этой книге мы пойдем по другому пути . Умение писать чистый код —тяжелая работа . Она не ограничивается знанием паттернов и принципов . Над кодом необходимопопотеть . Необходимо пытаться и терпеть неудачи . Необходимо наблюдать за тем , как другие пытаются и терпят неудачи . Необходимо видеть , как они спотыкаются и возвращаются к началу как мучительно принимаются решения и какую цену приходится платить за неверный выбор . Приготовьтесь основательно потрудиться во время чтения книги . Перед вами не «легкое чтиво» , которое можно проглотить в самолете и перевернуть последнюю страницу перед посадкой . Книга заставит вас потрудиться , и потрудиться усердно . Какая работа вам предстоит ? Вы будете читать код — много кода . И вам придется как следует подумать , что в этом коде правильно , а что нет . Вы будете наблюдать за тем , как мы разбираем эти модули , а потом собираем заново . Это потребует немало времени и усилий но мы считаем , что результат того стоит . Книга разделена на три части . В первых нескольких главах излагаются принципы , паттерны и приемы написания чистого кода . В них приводится довольно солидный объем кода , и читать их будет непросто . Весь этот материал подготовит вас ко второй части . Если вы отложите книгу после первой части — всего хорошего ! Во второй части книги трудиться придется еще больше . Она состоит из нескольких практических сценариев нарастающей сложности . Каждый сценарий представляет собой упражнение по чистке кода — или преобразовании проблемного кода в код с меньшим количеством проблем . Чтобы усвоить материал этой части , необходимоосновательно потрудиться . Вам придется переключаться туда - сюда между текстом и листингами . Вам придется анализировать и разбирать код , с которым мы работаем , и осознать причину каждого вносимого изменения . Выделите на это время , потому чторабота займет не один день . Третья часть книги — концентрированное выражение ее сути . Она состоит из одной главы с перечнем эвристических правил и «запахов кода» , собранных во время анализа . В ходе очистки кода в практических сценариях мы документировали причину каждого выполняемого действия в виде эвристического правила или «запаха» . Мы пытались понять нашу собственную реакцию на код в процессе его чтения и изменения старались объяснить , почему мы чувствовали то , что чувствовали , или делали то , что делали . Результат представляет собой базу знаний , описывающую наш путь мышления в процессе чтения , написания и чистки кода . Впрочем , без тщательного чтения всех практических сценариев из второй части книги пользы от базы знаний будет немного . В этих сценариях мы тщательно пометили каждое вносимое изменение ссылкой на соответствующее эвристическое правило . Ссылки заключаются в квадратные скобки и выглядят примерно так : . Это позволяет читателю видетьконтекст , в котором применяются эвристики ! Главная ценность заключается даже не в самих эвристиках , а связях между ними и конкретными решениями , принимаемыми в ходе чистки кода практических сценариев . Чтобы помочь вам отслеживать эти связи , мы разместили в конце книги список перекрестных ссылок . В нем приведены номера страниц всех ссылок . По этому списку можно найти каждое место , в котором применялась та или иная эвристика . Если вы прочитаете первую и третью часть , пропустив анализ практических сценариев , — считайте , что вы прочитали еще одну «легкую» книгу о написании качественного кода . Но если вы потратите время на проработку всех сценариев , проследите за каждым крошечным шагом , за каждым решением , если вы поставите себя на наше место и заставите себя думать в том же направлении , то ваше понимание этих принципов , паттернов , приемов и эвристик значительно углубится . Знания уже не будут «внешними» . Они проникнут в ваши пальцы , глаза и сердце . Они станут частью вашей личности — как велосипед становится продолжением вашего тела , когда вы научитесь на нем ездить . Благодарности Я благодарю двух художников , Дженнифер Конке и Анджелу Брукс . Дженнифер создала отличные остроумные рисунки в начале каждой главы , а также нарисовала портреты Кента Бека , Уорда Каннингема , Бьёрна Страуструпа , Рона Джеффриса , Грэди Бучаа , Дэйва Томаса , Майкла Физерса… и меня . Анджела занималась рисунками , поясняющими материал внутри глав . За прошедшие годы она подготовила немало иллюстраций для моих книг , в том числе для книги « : , , » . Кроме того , она мой первенец , и я ей горжусь . Глава . Чистый код Картинка : _ . Вы читаете эту книгу по двум причинам . Во - первых , вы программист . Во - вторых , вы хотите повысить свою квалификацию как программиста . Отлично . Хороших программистов не хватает . Эта книга посвящена хорошему программированию . Она полна реальных примеров кода . Мы будем рассматривать код с направлений : сверху вниз , снизу вверх , и даже изнутри . К последней странице книги вы узнаете много нового о коде . Более того , вы научитесь отличать хороший код от плохого . Вы узнаете , как писать хороший код и как преобразовать плохой код в хороший . Да будет код Возможно , кто - то скажет , что книга о коде отстала от времени — код сейчас уже не так актуален вместо него внимание следует направить на модели и требования . Нам даже доводилось слышать мнение , что код как таковой скоро перестанет существовать . Что скоро весь код будет генерироваться , а не писаться вручную . Что программисты станут попросту не нужны , потому что бизнесмены будут генерировать программы по спецификациям . Ерунда ! Код никогда не исчезнет , потому что код представляет подробности требований . На определенном уровне эти подробности невозможно игнорировать или абстрагировать их приходится определять . А когда требования определяются настолько подробно , чтобы они могли быть выполнены компьютером , это и есть программирование . А их определение есть код . Вероятно , уровень абстракции наших языков продолжит расти . Я также ожидаю , что количество предметно - ориентированных языков продолжит расти . И это хорошо . Но код отэтого существовать не перестанет . В самом деле , все определения , написанные на этих высокоуровневых , предметно - ориентированных языках , станут кодом ! И этот код должен быть достаточно компактным , точным , формальным и подробным , чтобы компьютер мог понять и выполнить его . Люди , полагающие , что код когда - нибудь исчезнет , напоминают математиков , которые надеются когда - нибудь обнаружить неформальную математическую дисциплину . Они надеются , что когда - нибудь будут построены машины , которые будут делать то , что мы хотим , а не то , что мы приказываем сделать . Такие машины должны понимать нас настолько хорошо , чтобы преобразовать набор нечетких потребностей в идеально выполняемые программы , точно отвечающие этим потребностям . Но этого никогда не произойдет . Даже люди , со всей их интуицией и изобретательностью , не способны создавать успешные системы на основе туманных представлений своих клиентов . Если дисциплина определения требований нас чему - то научила , так это тому , что четко определенные требования так же формальны , как сам код , и могут использоваться как исполняемые тесты этого кода ! В сущности , код представляет собой язык , на котором в конечном итоге выражаются потребности . Мы можем создавать языки , близкие к потребностям . Мы можем создавать инструменты , помогающие нам обрабатывать и собирать эти потребности в формальные структуры . Но необходимая точность никогда не исчезнет — а следовательно , код останется всегда . Плохой код Картинка : _ . Недавно я читал предисловие к книге Кента Бека « » . Автор говорит : «…эта книга базируется на довольно непрочной предпосылке : что хороший код важен…» Непрочная предпосылка ? Не согласен ! На мой взгляд , эта предпосылка является одной из самых мощных , основополагающих и многогранных положений нашего ремесла и я думаю , что Кенту это известно . Мы знаем , что хороший код важен , потому что нам приходилось так долго мириться с его отсутствием . Одна компания в конце - х годов написала приложение - бестселлер . Приложение стало чрезвычайно популярным , многие профессионалы покупали и использовали его . Но потом циклы выпуска новых версий стали затягиваться . Ошибки не исправлялись между версиями . Время загрузки росло , а сбои происходили все чаще . Помню тот день , когда я в раздражении закрыл этот продукт и никогда не запускал его . Вскоре эта компания разорилась . Два десятилетия спустя я встретил одного из работников той компании и спросил его , что же произошло . Ответ подтвердил мои опасения . Они торопились с выпуском продукта на рынок и не обращали внимания на качество кода . С добавлением новых возможностей код становился все хуже и хуже , пока в какой - то момент не вышел из - под контроля . Плохой код привел к краху компании . Плохой код когда - нибудь мешал вашей работе ? Любой сколько - нибудь опытный программист неоднократно попадал в подобную ситуацию . Мы продираемся через плохой код . Мывязнем в хитросплетении ветвей , попадаем в скрытые ловушки . Мы с трудом прокладываем путь , надеясь получить хоть какую - нибудь подсказку , что же происходит в коде но не видим вокруг себя ничего , кроме новых залежей невразумительного кода . Конечно , плохой код мешал вашей работе . Почему же вы писали его ? Пытались поскорее решить задачу ? Торопились ? Возможно . А может быть , вам казалось , что у вас нет времени качественно выполнить свою работу что ваше начальство будет недовольно , если вы потратите время на чистку своего кода . А может , вы устали работать над программой и вам хотелось поскорее избавиться от нее . А может , вы посмотрели на список запланированных изменений и поняли , что вам необходимо поскорее «прикрутить» этот модуль , чтобы перейти к следующему . Такое бывало с каждым . Каждый из нас смотрел на тот хаос , который он только что сотворил , и решал оставить его на завтра . Каждый с облегчением видел , что бестолковая программа работает , и решал , что рабочая мешанина — лучше , чем ничего . Каждый обещал себе вернуться и почистить код… потом . Конечно , в те дни мы еще не знали закон Леблана : потом равносильно никогда . Расплата за хаос Если вы занимались программированием более двух - трех лет , вам наверняка доводилось вязнуть в чужом — или в своем собственном — беспорядочном ходе . Замедление может быть весьма значительным . За какие - нибудь год - два группы , очень быстро двигавшиеся вперед в самом начале проекта , начинают ползти со скоростью улитки . Каждое изменение , вносимое в код , нарушает работу кода в двух - трех местах . Ни одно изменение не проходит тривиально . Для каждого дополнения или модификации системы необходимо«понимать» все хитросплетения кода — чтобы в программе их стало еще больше . Со временем неразбериха разрастается настолько , что справиться с ней уже не удается . Выхода просто нет . По мере накопления хаоса в коде производительность группы начинает снижаться , асимптотически приближаясь к нулю . В ходе снижения производительности начальство делает единственное , что оно может сделать : подключает к проекту новых работников в надежде повысить производительность . Но новички ничего не понимают в архитектуре системы . Они не знают , какие изменения соответствуют намерениям проектировщика , а какие им противоречат . Более того , они — и все остальные участники группы — находятся под страшным давлением со стороны начальства . В спешке они работают все небрежнее , отчего производительность только продолжает падать рис . . . Картинка : _ . Рис . . . Зависимость производительности от времени Грандиозная переработка В конечном итоге группа устраивает бунт . Она сообщает начальству , что не может продолжать разработку отвратительной кодовой базы , и требует переработки архитектуры . Начальство не хочет тратить ресурсы на полную переработку проекта , но не может отрицать , что производительность просто ужасна . Со временем начальство поддаетсяна требования разработчиков и дает разрешение на проведение грандиозной переработки . Набирается новая «ударная группа» . Все хотят в ней участвовать , потому что проект начинается «с нуля» . Разработчики будут строить «на пустом месте» , и создадут нечто воистину прекрасное . Но в «ударную группу» отбирают только самых лучших и умных . Всем остальным приходится сопровождать текущую систему . Между двумя группами начинается гонка . «Ударная группа» должна построить новую систему , которая делает то же самое , что делала старая . Более того , она должна своевременно учитывать изменения , непрерывно вносимые в старую систему . Начальство не заменяет старую систему до тех пор , пока новая система не будет полностью повторять ее функциональность . Такая гонка может продолжаться очень долго . Мне известны случаи , как она продолжалась по лет . И к моменту ее завершения оказывалось , что исходный состав давно покинул «ударную группу» , а текущие участники требовали переработать новую систему , потому что в ней творился сущий хаос . Если вы сталкивались хотя бы с некоторыми частями истории , которую я сейчас поведал , то вы уже знаете , что поддержание чистоты кода не только окупает затраченное время оно является делом профессионального выживания . Отношение Вам доводилось продираться через код настолько запутанный , что у вас уходили недели на то , что должно было занять несколько часов ? Вы видели , как изменение , котороевроде бы должно вноситься в одной строке , приходится вносить в сотнях разных модулей ? Эти симптомы стали слишком привычными . Почему это происходит с кодом ? Почему хороший код так быстро загнивает и превращается в плохой код ? У нас обычно находится масса объяснений . Мы жалуемся на изменения в требованиях , противоречащие исходной архитектуре . Мы стенаем о графиках , слишком жестких для того , чтобы делать все , как положено . Мы сплетничаем о глупом начальстве , нетерпимых клиентах и бестолковых типах из отдела маркетинга . Однако вина лежит вовсе не на них , а на нас самих . Дело в нашем непрофессионализме . Возможно , проглотить эту горькую пилюлю будет непросто . Разве мы виноваты в этом хаосе ? А как же требования ? График ? Глупое начальство и бестолковые типы из отдела маркетинга ? Разве по крайней мере часть вины не лежит на них ? Нет . Начальство и маркетологи обращаются к нам за информацией , на основании которой они выдвигают свои обещания и обязательства но даже если они к нам не обращаются , мы не должны бояться говорить им то , что мы думаем . Пользователи обращаются к нам , чтобы мы высказали свое мнение относительно того , насколько уместны требованияв системе . Руководители проектов обращаются к нам за помощью в составлении графика . Мы принимаем самое деятельное участие в планировании проекта и несем значительную долю ответственности за любые провалы особенно если эти провалы обусловлены плохим кодом ! «Но постойте ! — скажете вы . — Если я не сделаю то , что говорит мой начальник , меня уволят» . Скорее всего , нет . Обычно начальники хотят знать правду , даже если по их поведению этого не скажешь . Начальники хотят видеть хороший код , даже если они помешаны на рабочем графике . Они могут страстно защищать график и требования но это их работа . А ваша работа — так же страстно защищать код . Чтобы стало понятнее , представьте , что вы — врач , а ваш пациент требует прекратить дурацкое мытье рук при подготовке к операции , потому что это занимает слишком много времени ! Естественно , пациент — это ваш начальник и все же врач должен наотрез отказаться подчиниться его требованиям . Почему ? Потому что врач знает об опасности заражения больше , чем пациент . Было бы слишком непрофессионально а то и преступно подчиниться воле пациента . Таким образом , программист , который подчиняется воле начальника , не понимающего опасность некачественного кода , проявляет непрофессионализм . Основной парадокс Программисты сталкиваются с основным парадоксом базовых ценностей . Каждый разработчик , имеющий сколько - нибудь значительный опыт работы , знает , что предыдущий беспорядок замедляет его работу . Но при этом все разработчики под давлением творят беспорядок в своем коде для соблюдения графика . Короче , у них нет времени , чтобы работать быстро ! Настоящие профессионалы знают , что вторая половина этого парадокса неверна . Невозможно выдержать график , устроив беспорядок . На самом деле этот беспорядок сразу же замедлит вашу работу , и график будет сорван . Единственный способ выдержать график — и единственный способ работать быстро — заключается в том , чтобы постоянно поддерживать чистоту в коде . Искусство чистого кода ? Допустим , вы согласились с тем , что беспорядок в коде замедляет вашу работу . Допустим , вы согласились , что для быстрой работы необходимо соблюдать чистоту . Тогда выдолжны спросить себя : «А как мне написать чистый код ? » Бесполезно пытаться написать чистый код , если вы не знаете , что это такое ! К сожалению , написание чистого кода имеет много общего с живописью . Как правило , мы способны отличить хорошую картину от плохой , но это еще не значит , что мы умеем рисовать . Таким образом , умение отличать чистый код от грязного еще не означает , что вы умеете писать чистый код ! Чтобы написать чистый код , необходимо сознательно применять множество приемов , руководствуясь приобретенным усердным трудом чувством «чистоты» . Ключевую роль здесь играет «чувство кода» . Одни с этим чувством рождаются . Другие работают , чтобы развить его . Это чувство не только позволяет отличить хороший код от плохого , но и демонстрирует стратегию применения наших навыков для преобразования плохого кода в чистый код . Программист без «чувства кода» посмотрит на грязный модуль и распознает беспорядок , но понятия не имеет , что с ним делать . Программист с «чувством кода» смотрит нагрязный модуль и видит различные варианты и возможности . «Чувство кода» поможет ему выбрать лучший вариант и спланировать последовательность преобразований , сохраняющих поведение программы и приводящих к нужному результату . Короче говоря , программист , пишущий чистый код , — это художник , который проводит пустой экран через серию преобразований , пока он не превратится в элегантно запрограммированную систему . Что такое «чистый код» ? Вероятно , сколько существует программистов , столько найдется и определений . Поэтому я спросил у некоторых известных , чрезвычайно опытных программистов , что они думают по этому поводу . Картинка : _ . Бьёрн Страуструп , создатель и автор книги « » Я люблю , чтобы мой код был элегантным и эффективным . Логика должны быть достаточно прямолинейной , чтобы ошибкам было трудно спрятаться зависимости — минимальными , чтобы упростить сопровождение обработка ошибок — полной в соответствии с выработанной стратегией а производительность — близкой к оптимальной , чтобы не искушать людей загрязнять код беспринципными оптимизациями . Чистый код хорошо решает одну задачу . Бьёрн использует слово «элегантный» . Хорошее слово ! Словарь в моем ® выдает следующие определения : доставляющий удовольствие своим изяществом и стилем сочетающий простоту с изобретательностью . Обратите внимание на оборот «доставляющий удовольствие» . Очевидно , Бьёрн считает , что чистый код приятно читать . При чтении чистого кода вы улыбаетесь , как при виде искусно сделанной музыкальной шкатулки или хорошо сконструированной машины . Бьёрн также упоминает об эффективности — притом дважды . Наверное , никого не удивят эти слова , произнесенные изобретателем , но я думаю , что здесь кроется нечто большее , чем простое стремление к скорости . Напрасные траты процессорного времени неэлегантны , они не радуют глаз . Также обратите внимание на слово «искушение» , которым Бьёрн описывает последствия неэлегантности . В этом кроется глубокая истина . Плохой кодискушает , способствуя увеличению беспорядка ! Когда другие программисты изменяют плохой код , они обычно делают его еще хуже . Прагматичные Дэйв Томас и Энди Хант высказали ту же мысль несколько иначе . Они сравнили плохой код с разбитыми окнами . Здание с разбитыми окнами выглядит так , словно никому до него нет дела . Поэтому люди тоже перестают обращать на него внимание . Они равнодушно смотрят , как на доме появляются новые разбитые окна , а со временем начинают сами бить их . Они уродуют фасад дома надписями и устраивают мусорную свалку . Одно разбитое окно стало началом процесса разложения . Бьёрн также упоминает о необходимости полной обработки ошибок . Это одно из проявлений внимания к мелочам . Упрощенная обработка ошибок — всего лишь одна из областей , в которых программисты пренебрегают мелочами . Утечка — другая область , состояния гонки — третья , непоследовательный выбор имен — четвертая… Суть в том , что чистый код уделяет пристальное внимание мелочам . В завершение Бьёрн говорит о том , что чистый код хорошо решает одну задачу . Не случайно многие принципы проектирования программного обеспечения сводятся к этому простому наставлению . Писатели один за другим пытаются донести эту мысль . Плохой код пытается сделать слишком много всего , для него характерны неясные намерения и неоднозначность целей . Для чистого кода характерна целенаправленность . Каждая функция , каждый класс , каждый модуль фокусируются на конкретной цели , не отвлекаются от нее и не загрязняются окружающими подробностями . Картинка : _ . Грэди Буч , автор книги « » Чистый код прост и прямолинеен . Чистый код читается , как хорошо написанная проза . Чистый код никогда не затемняет намерения проектировщика он полон четких абстракций и простых линий передачи управления . Грэди частично говорит о том же , о чем говорил Бьёрн , но с точки зренияудобочитаемости . Мне особенно нравится его замечание о том , что чистый код должен читаться , как хорошо написанная проза . Вспомните какую - нибудь хорошую книгу , которую вы читали . Вспомните , как слова словно исчезали , заменяясь зрительными образами ! Как кино , верно ? Лучше ! Вы словно видели персонажей , слышали звуки , испытывали душевное волнение исопереживали героям . Конечно , чтение чистого кода никогда не сравнится с чтением «Властелина колец» . И все же литературная метафора в данном случае вполне уместна . Чистый код , как и хорошая повесть , должен наглядно раскрыть интригу решаемой задачи . Он должен довести эту интригу до высшей точки , чтобы потом читатель воскликнул : «Ага ! Ну конечно ! » , когда все вопросы и противоречия благополучно разрешатся в откровении очевидного решения . На мой взгляд , использованный Грэди оборот «четкая абстракция» представляет собой очаровательный оксюморон ! В конце концов , слово «четкий» почти всегда является синонимом для слова «конкретный» . В словаре моего приведено следующее определение слова «четкий» : краткий , решительный , фактический , без колебаний или лишних подробностей . Несмотря на кажущееся смысловое противоречие , эти слова несут мощный информационный посыл . Наш код должен быть фактическим , а не умозрительным . Он должен содержать только то , что необходимо . Читатель должен видеть за кодом нашу решительность . Картинка : _ . «Большой» Дэйв Томас , основатель , крестный отец стратегии Чистый код может читаться и усовершенствоваться другими разработчиками , кроме его исходного автора . Для него написаны модульные и приемочные тесты . В чистом коде используются содержательные имена . Для выполнения одной операции в нем используется один путь вместо нескольких разных . Чистый код обладает минимальными зависимостями , которые явно определены , и четким , минимальным . Код должен быть грамотным , потому что в зависимости от языка не вся необходимая информация может быть четко выражена в самом коде . Большой Дэйв разделяет стремление Грэди к удобочитаемости , но с одной важной особенностью . Дэйв утверждает , что чистота кода упрощает его доработку другими людьми . На первый взгляд это утверждение кажется очевидным , но его важность трудно переоценить . В конце концов , код , который легко читается , и код , который легко изменяется , — не одно и то же . Дэйв связывает чистоту с тестами ! Десять лет назад это вызвало бы множество недоуменных взглядов . Однако методология разработки через тестирование оказала огромное влияние на нашу отрасль и стала одной из самых фундаментальных дисциплин . Дэйв прав . Код без тестов не может быть назван чистым , каким бы элегантным он ни был и как бы хорошо он ни читался . Дэйв использует слово «минимальный» дважды . Очевидно , он отдает предпочтение компактному коду перед объемистым кодом . В самом деле , это положение постоянно повторяется в литературе по программированию от начала ее существования . Чем меньше , тем лучше . Дэйв также говорил , что код должен бытьграмотным . Это ненавязчивая ссылка на концепцию «грамотного программирования» Дональда Кнута . Итак , код должен быть написан в такой форме , чтобы он хорошо читался людьми . Картинка : _ . Майкл Физерс , автор книги « » Я мог бы перечислить все признаки , присущие чистому коду , но существует один важнейший признак , из которого следуют все остальные . Чистый код всегда выглядит так , словно его автор над ним тщательно потрудился . Вы не найдете никаких очевидных возможностей для его улучшения . Все они уже были продуманы автором кода . Попытавшись представить возможные усовершенствования , вы снова придете к тому , с чего все началось : вы рассматриваете код , тщательно продуманный и написанный настоящим мастером , небезразличным к своему ремеслу . Всего одно слово : тщательность . На самом деле оно составляет тему этой книги . Возможно , ее название стоило снабдить подзаголовком : «Как тщательно работать над кодом» . Майкл попал в самую точку . Чистый код — это код , над которым тщательно поработали . Кто - то не пожалел своего времени , чтобы сделать его простым и стройным . Кто - то уделил должное внимание всем мелочам и относился к коду с душой . Картинка : _ . Рон Джеффрис , автор книг « » и « # » Карьера Рона началась с программирования на языке . С тех пор он писал код практически на всех языках и на всех компьютерах . К его словам стоит прислушаться . За последние коды я постоянно руководствуюсь «правилами простого кода» , сформулированными Беком . В порядке важности , простой код : — проходит все тесты — не содержит дубликатов — выражает все концепции проектирования , заложенные в систему — содержит минимальное количество сущностей : классов , методов , функций и т . д . Из всех правил я уделяю основное внимание дублированию . Если что - то делается в программе снова и снова , это свидетельствует о том , что какая - то мысленная концепция не нашла представления в коде . Я пытаюсь понять , что это такое , а затем пытаюсь выразить идею более четко . Выразительность для меня прежде всего означает содержательность имен . Обычно я провожу переименования по несколько раз , пока не остановлюсь на окончательном варианте . В современных средах программирования — таких , как — переименование выполняется легко , поэтому изменения меня не беспокоят . Впрочем , выразительность не ограничивается одними лишь именами . Я также смотрю , не выполняет ли объект или метод более одной операции . Если это объект , то его , вероятно , стоит разбить на два и более объекта . Если это метод , я всегда применяю к нему прием «извлечения метода» в итоге у меня остается основной метод , который более четко объясняет , что он делает , и несколько подметодов , объясняющих , как он это делает . Отсутствие дублирования и выразительности являются важнейшими составляющими чистого кода в моем понимании . Даже если при улучшении грязного кода вы будете руководствоваться только этими двумя целями , разница в качестве кода может быть огромной . Однако существует еще одна цель , о которой я также постоянно помню , хотя объяснить ее будет несколько сложнее . После многолетней работы мне кажется , что все программы состоят из очень похожих элементов . Для примера возьмем операцию «найти элемент в коллекции» . Независимо от того , работаем ли мы с базой данных , содержащий информацию о работниках , или хеш - таблицей с парами «ключ - значение» , или массивом с однотипными объектами , на практике часто возникает задача извлечь конкретный элемент из этой коллекции . В подобных ситуациях я часто инкапсулирую конкретную реализацию в более абстрактном методе или классе . Это открывает пару интересных возможностей . Я могу определить для нужной функциональности какую - нибудь простую реализацию например , хеш - таблицу , но поскольку все ссылки прикрыты моей маленькой абстракцией , реализацию можно в любой момент изменить . Я могу быстро двигаться вперед , сохраняя возможность внести изменения позднее . Кроме того , абстракция часто привлекает мое внимание к тому , что же «действительно» происходит в программе , и удерживает меня от реализации поведения коллекций там , где в действительности достаточно более простых способов получения нужной информации . Сокращение дублирования , высокая выразительность и раннее построение простых абстракций . Все это составляет чистый код в моем понимании . В нескольких коротких абзацах Рон представил сводку содержимого этой книги . Устранение дублирования , выполнение одной операции , выразительность , простые абстракции . Все на месте . Картинка : _ . Уорд Каннингем , создатель , создатель , один из создателей экстремального программирования . Вдохновитель написания книги « » . Духовный лидер и объектно - ориентированного подхода . Крестный отец всех , кто тщательно относится к написанию кода . Вы работаете с чистым кодом , если каждая функция делает примерно то , что вы ожидали . Код можно назвать красивым , если у вас также создается впечатление , что язык былсоздан специально для этой задачи . Подобные заявления — отличительная способность Уорда . Вы читаете их , киваете головой и переходите к следующей теме . Это звучит настолько разумно , настолько очевидно , что не выглядит чем - то глубоким и мудрым . Вроде бы все само собой разумеется . Но давайте присмотримся повнимательнее . «…примерно то , что вы ожидали» . Когда вы в последний раз видели модуль , который делал примерно то , что вы ожидали ? Почему попадающиеся нам модули выглядят сложными , запутанными , приводят в замешательство ? Разве они не нарушают это правило ? Как часто вы безуспешно пытались понять логику всей системы и проследить ее в том модуле , который вы сейчас читаете ? Когда в последний раз при чтении кода вы кивали головой так , как при очевидном заявлении Уорда ? Уорд считает , что чтение чистого кода вас совершенно не удивит . В самом деле , оно даже не потребует от вас особых усилий . Вы читаете код , и он делает примерно то , что вы ожидали . Чистый код очевиден , прост и привлекателен . Каждый модуль создает условия для следующего . Каждый модуль показывает , как будет написан следующий модуль . Чистые программы написаны настолько хорошо , что вы этого даже не замечаете . Благодаря автору код выглядит до смешного простым , как и все действительно выдающиеся творения . А как насчет представления Уорда о красоте ? Все мы жаловались на языки , не предназначенные для решения наших задач . Однако утверждение Уорда возлагает ответственность на нас . Он говорит , что при чтении красивого кода язык кажется созданным для решения конкретной задачи ! Следовательно , мы сами должны позаботиться о том , чтобы язык казался простым ! Языковые фанатики , задумайтесь ! Не язык делает программы простыми . Программа выглядит простой благодаря работе программиста ! Школы мысли Картинка : _ . А как насчет меня Дядюшка Боб ? Что я думаю по поводу чистого кода ? Эта книга расскажет вам во всех подробностях , что я и мои соратники думаем о чистом коде . Вы узнаете , как , по нашему мнению , должно выглядит чистое имя переменной , чистая функция , чистый класс и т . д . Мы излагаем свои мнения в виде беспрекословных истин и не извиняемся за свою категоричность . Для нас , на данном моменте наших карьер , ониявляютсябеспрекословными истинами . Они составляют нашушколу мыслив области чистого кода . Мастера боевых искусств не достигли единого мнения по поводу того , какой из видов единоборств является лучшим , а какие приемы — самыми эффективными . Часто ведущиемастера создают собственную школу и набирают учеников . Так появилась школа дзю - дзюцу Грейси , основанная семьей Грейси в Бразилии . Так появилась школа дзю - дзюцу Хаккорю , основанная Окуямой Рюхо в Токио . Так появилась школа Джит Кун - до , основанная Брюсом Ли в Соединенных Штатах . Ученики этих разных школ погружаются в учение основателя школы . Они посвящают себя изучению того , чему учит конкретный мастер , часто отказываясь от учений других мастеров . Позднее , когда уровень их мастерства возрастет , они могут стать учениками другого мастера , чтобы расширить свои познания и проверить их на практике . Некоторые переходят к совершенствованию своих навыков , открывают новые приемы и открывают собственные школы . Ни одна из этих разных школ не обладаетабсолютной истиной . Тем не менее в рамках конкретной школы мы действуем так , будто ее учение и арсенал приемов верны . Именно так и следует тренироваться в школе Хаккорю или Джит Кун - до . Но правильность принципов в пределах одной школы не делает ошибочными учения других школ . Считайте , что эта книга является описанием Школы учителей Чистого кода . В ней представлены те методы и приемы , которыми мы сами пользуемся в своем искусстве . Мы утверждаем , что если вы последуете нашему учению , то это принесет вам такую же пользу , как и нам , и вы научитесь писать чистый и профессиональный код . Но не стоит думать , что наше учение «истинно» в каком - то абсолютном смысле . Существуют другие школы и мастера , которые имеют ничуть не меньше оснований претендовать на профессионализм . Не упускайте возможности учиться у них . В самом деле , многие рекомендации в этой книге противоречивы . Вероятно , вы согласитесь не со всеми из них . Возможно , против некоторых вы будете яростно протестовать . Это нормально . Мы не претендуем на абсолютную истину . С другой стороны , приведенные в книге рекомендации являются плодами долгих , непростых размышлений . Мы пришли к ним после десятилетий практической работы , непрестанных проб и ошибок . Независимо от того , согласитесь вы с нами или нет , нашу точку зрения стоит по крайней мере узнать и уважать . Мы — авторы Поле @ комментария говорит о том , кто мы такие . Мы — авторы . А как известно , у каждого автора имеются свои читатели . Автор несет ответственность за то , чтобы хорошо изложить свои мысли читателям . Когда вы в следующий раз напишете строку кода , вспомните , что вы — автор , и пишете для читателей , которые будут оценивать плоды вашей работы . Кто - то спросит : так ли уж часто читается наш код ? Разве большая часть времени не уходит на его написание ? Вам когда - нибудь доводилось воспроизводить запись сеанса редактирования ? В - х и - х годах существовали редакторы , записывавшие все нажатия клавиш например , . Вы могли проработать целый час , а потом воспроизвести весь сеанс , словно ускоренное кино . Когда я это делал , результаты оказывались просто потрясающими . Большинство операций относилось к прокрутке и переходу к другим модулям ! Боб открывает модуль . Он находит функцию , которую необходимо изменить . Задумывается о последствиях . Ой , теперь он переходит в начало модуля , чтобы проверить инициализацию переменной . Снова возвращается вниз и начинает вводить код . Стирает то , что только что ввел . Вводит заново . Еще раз стирает ! Вводит половину чего - то другого , но стирает и это ! Прокручивает модуль к другой функции , которая вызывает изменяемую функцию , чтобы посмотреть , как она вызывается . Возвращается обратно и восстанавливает только что стертый код . Задумывается . Снова стирает ! Открывает другое окно и просматривает код субкласса . Переопределяется ли в нем эта функция ? . . . В общем , вы поняли . На самом деле соотношение времени чтения и написания кода превышает : . Мы постоянно читаем свой старый код , поскольку это необходимо для написания нового кода . Из - за столь высокого соотношения наш код должен легко читаться , даже если это затрудняет его написание . Конечно , написать код , не прочитав его , невозможно , так что упрощение чтения в действительности упрощает и написание кода . Уйти от этой логики невозможно . Невозможно написать код без предварительного чтения окружающего кода . Код , который вы собираетесь написать сегодня , будет легко или тяжело читаться в зависимости от того , насколько легко или тяжело читается окружающий код . Если вы хотите быстро справиться со своей задачей , если вы хотите , чтобываш код было легко писать — позаботьтесь о том , чтобы он легко читался . Правило бойскаута Хорошо написать код недостаточно . Необходимо поддерживать чистоту кода с течением времени . Все мы видели , как код загнивает и деградирует с течением времени . Значит , мы должны активно поработать над тем , чтобы этого не произошло . У бойскаутов существует простое правило , которое применимо и к нашей профессии : Оставь место стоянки чище , чем оно было до твоего прихода . Если мы все будем оставлять свой код чище , чем он был до нашего прихода , то код попросту не будет загнивать . Чистка не обязана быть глобальной . Присвойте более понятное имя переменной , разбейте слишком большую функцию , устраните одно незначительное повторение , почистите сложную цепочку . Представляете себе работу над проектом , код которогоулучшаетсяс течением времени ? Но может ли профессионал позволить себе нечто иное ? Разве постоянное совершенствование не является неотъемлемой частью профессионализма ? Предыстория и принципы Эта книга во многих отношениях является «предысторией» для книги , написанной мной в году : « : , , » сокращенно . Книга посвященапринципам объектно - ориентированного проектирования и практическим приемам , используемым профессиональными разработчиками . Если вы еще не читали , скажу , что там развивается тема , начатая в этой книге . Прочитавшие убедятся , что многие идеи перекликаются с идеями , изложенными в этой книге на уровне кода . В этой книге периодически встречаются ссылки на различные принципы проектирования . В частности , упоминается принцип единой ответственности , принцип открытости закрытости и принцип обращения зависимостей . Все эти принципы подробно описаны в . Заключение Книги по искусству не обещают сделать из вас художника . Все , что они могут — познакомить вас с приемами , инструментами и направлением мысли других художников . Эта книга тоже не обещает сделать из вас хорошего программиста . Она не обещает сформировать у вас «чувство кода» . Я могу лишь показать , в каком направлении мыслят хорошие программисты и какие приемы , трюки и инструменты они применяют в своей работе . Подобно книгам по искусству , эта книга насыщена подробностями . В ней много кода — как хорошего , так и плохого . Вы увидите , как плохой код преобразуется в хороший . Вынайдете списки эвристических правил , дисциплин и методов . Вы увидите множество примеров . А дальше дело только за вами . Помните старый анекдот о скрипаче , который заблудился по пути на концерт ? Он остановил старика на углу и спросил , как попасть в Карнеги - холл . Старик посмотрел на скрипача , на зажатую у него под мышкой скрипку и сказал : «Старайся , сынок . Старайся ! » Литература : , , - , . : , . , , , . Глава . Содержательные именаТим Оттингер Картинка : _ . Имена встречаются в программировании повсеместно . Мы присваиваем имена своим переменным , функциям , аргументам , классам и пакетам . Мы присваиваем имена исходным файлам и каталогам , в которых они хранятся . Мы присваиваем имена файлам , и . Имена , имена , имена… Но то , что делается так часто , должно делаться хорошо . Далее приводятся некоторые простые правила создания хороших имен . Имена должны передавать намерения программиста Легко сказать : имена должны передавать намерения программиста . И все же к выбору имен следует относиться серьезно . Чтобы выбрать хорошее имя , понадобится время , ноэкономия окупит затраты . Итак , следите за именами в своих программах и изменяйте их , если найдете более удачные варианты . Этим вы упростите жизнь каждому , кто читает ваш код в том числе и себе самому . Имя переменной , функции или класса должно отвечать на все главные вопросы . Оно должно сообщить , почему эта переменная и т . д . существует , что она делает и как используется . Если имя требует дополнительных комментариев , значит , оно не передает намерений программиста . Прошедшее время Имя не передает ровным счетом ничего . Оно не ассоциируется ни с временными интервалами , ни с днями . Его следует заменить другим именем , которое указывает , что именно измеряется и в каких единицах : Содержательные имена существенно упрощают понимание и модификацию кода . Например , что делает следующий фрагмент ? : . Почему мы не можем сразу сказать , что делает этот код ? В нем нет сложных выражений . Пробелы и отступы расставлены грамотно . В коде задействованы только три переменные и две константы . В нем нет никаких хитроумных классов или полиморфных методов , только список массивов по крайней мере на первый взгляд . Проблема кроется не в сложности кода , а в егонеочевидности , то есть степени , в которой контекст не следует явно из самого кода . Код подразумевает , что мы знаем ответы на вопросы : . Какие данные хранятся в ? . Чем так важен элемент с нулевым индексом ? . Какой особый смысл имеет значение ? . Как будет использоваться возвращаемый список ? Ответы на все эти вопросы не следуют из примера , хотя и могли бы . Допустим , мы работаем над игрой «Сапер» . Игровое поле представлено в виде списка ячеек с именем . Переименуем его в . Каждая ячейка игрового поля представлена простым массивом . Далее выясняется , что в элементе с нулевым индексом хранится код состояния , а код означает «флажок установлен» . Даже простое присваивание имен всем этим концепциям существенно улучшает код : : _ . Обратите внимание : простота кода несколько не изменилась . Новая версия содержит точно такое же количество операторов и констант , с абсолютно таким же количеством уровней вложенности . Однако код стал существенно более понятным . Можно пойти еще дальше и написать простой класс для представления ячеек вместо использования массива . В класс включается функция , передающая намерения программиста назовем ее она скрывает «волшебные» числа . В результате мы получаем новую версию функции : : . . Не изменилось ничего , кроме имен — но теперь можно легко понять , что здесь происходит . Такова сила выбора хороших имен . Избегайте дезинформации Программисты должны избегать ложных ассоциаций , затемняющих смысл кода . Не используйте слова со скрытыми значениями , отличными от предполагаемого . Например , переменным не стоит присваивать имена , , , потому что они ассоциируются с платформами и разновидностями . Даже если в переменной хранится длина гипотенузы и имя кажется хорошим сокращением , оно может ввести в заблуждение читателя кода . Не обозначайте группу учетных записей именем , если только она действительно не хранится в списке . Слово «список» имеет для программиста вполне конкретный смысл . Если записи хранятся не в , а в другом контейнере , это может привести к ложным выводам . В этом примере лучше подойдет имя , и даже просто . Остерегайтесь малозаметных различий в именах . Сколько времени понадобится , чтобы заметить незначительное различие в в одном модуле и где - то в другом месте ? Эти имена выглядят устрашающе похожими . Сходное представление сходных концепций — информация . Непоследовательное представление — дезинформация . Современные среды поддерживают удобный механизм автоматического завершения кода . Вы вводите несколько символов имени , нажимаете некую комбинацию клавиш а иногда обходится и без этого и получаете список возможныхвариантов завершения имени . Очень удобно , если имена похожих объектов сортируются по алфавиту , и если различия предельно очевидны — ведь разработчик , скорее всего , выберет ваш объект по имени , не увидев ни ваших обширных комментариев , ни хотя бы списка методов класса . По - настоящему устрашающие примеры дезинформирующих имен встречаются при использовании строчной « » и прописной « » в именах переменных , особенно в комбинациях . Естественно , проблемы возникают из - за того , что эти буквы почти не отличаются от констант « » и « » соответственно . Возможно , некоторым читателям этот совет покажется надуманным , однако мы неоднократно видели код , в котором подобных ухищрений было предостаточно . В одном случае автор кода даже предложил использовать другой шрифт , чтобы различия стали более очевидными — в дальнейшем это решение должно было передаваться всем будущим разработчикам на словах или в письменном документе . Простое переименование решает проблему окончательно и без создания новых документов . Используйте осмысленные различия Картинка : _ . Когда программист пишет код исключительно для того , чтобы удовлетворить запросы компилятора или интерпретатора , он сам себе создает проблемы . Например , посколькуодно имя в одной области имени не может обозначать две разные вещи , возникает соблазн произвольно изменить одно из имен . Иногда для этого имя записывается заведомо неправильно и возникает удивительная ситуация : после исправления грамматической ошибки программа перестает компилироваться . Недостаточно добавить в имя серию цифр или неинформативные слова , даже если компилятору этого будет достаточно . Если имена различаются , то они должны обозначать разные понятия . «Числовые ряды» вида , , . . являются противоположностью сознательного присваивания имен . Такие имена не дезинформируют — они просто не несут информации и не дают представления о намерениях автора . Пример : , . Такая функция будет читаться намного лучше , если присвоить аргументам имена и . Неинформативные слова также применяются для создания бессодержательных различий . Допустим , у вас имеется класс . Создав другой класс с именем или , вы создаете разные имена , которые по сути обозначают одно и то же . и не несут полезной информации , как и артикли , и . Следует учесть , что использование префиксов и вовсе не является ошибкой , но только при условии , что они создают осмысленные различия . Например , префикс может присваиваться всем локальным переменным , а префикс — всем аргументам функций . Проблема возникает тогда , когда вы называете переменную , потому что в программе уже есть другая переменная с именем . Неинформативные слова избыточны . Слово никогда не должно встречаться в именах переменных . Слово никогда не должно встречаться в именах таблиц . Чем имя лучше ? Разве имя может быть , скажем , вещественным числом ? Если может , то это нарушает предыдущее правило о дезинформации . Представьте , что в программе присутствуют два класса с именами и . Что вы можете сказать о различиях между ними ? Какой класс предоставляет лучший путь к истории платежей клиента ? Эта проблема встретилась нам в одном реально существующем приложении . Мы изменили имена , чтобы защитить виновных , но точная форма ошибки выглядит так : Как участвующему в проекте программисту понять , какую из этих функций вызывать в конкретном случае ? При отсутствии жестких именных схем имя не отличается от , не отличается от , не отличается от , а — от . Записывайте различающиеся имена так , чтобы читатель кода понимал , какой смысл заложен в этих различиях . Используйте удобопроизносимые имена Людям удобно работать со словами . Значительная часть нашего мозга специализируется на концепции слов , а слова по определению удобопроизносимы . Было бы обидно не использовать ту изрядную часть мозга , которая развивалась для разговорной речи . Следовательно , имена должны нормально произноситься . Если имя невозможно нормально произнести , то при любом его упоминании в обсуждении вы выглядите полным идиотом . «Итак , за этим би - си - эр - три - си - эн - тэ у нас идет пи - эс - зэт - кью , видите ? » А это важно , потому что программирование является социальной деятельностью . В одной известной мне компании используется переменная дата генерирования , год , месяц , день , час , минуты и секунды , поэтому программисты упоминали в своих разговорах «ген - уай - эм - ди - эйч - эм - эс» . У меня есть противная привычка произносить все так , как написано , поэтому я начал говорить «генъя - мадда - химс» . Потом переменную начали так называть многие проектировщики и аналитики , и это звучало довольно глупо . Впрочем , мы делали это в шутку . Но как бы то ни было , мы столкнулись с типичным примером неудачного выбора имен . Новым разработчикам приходилось объяснять смысл переменных , после чего они начинали изъясняться дурацкими неестественными словами вместо нормальной разговорной речи . Сравните : " " … и " " … Теперь становится возможным осмысленный разговор : «Эй , Майк , глянь - ка на эту запись ! В поле временного штампа заносится завтрашняя дата ! Разве такое возможно ? » Выбирайте имена , удобные для поиска У однобуквенных имен и числовых констант имеется один специфический недостаток : их трудно искать в большом объеме текста . Строка _ _ _ отыскивается легко , а с числом могут возникнуть проблемы . Система поиска находит эту цифру в именах файлов , в определениях констант и в различных выражениях , где значение используется с совершенно другим смыслом . Еще хуже , если константа представляет собой длинное число , в котором были случайно переставлены цифры в программе появляется ошибка , которая одновременно скрывается от поиска . Также не стоит присваивать имя переменной , которая может использоваться при поиске . Самая распространенная буква английского алфавита с большой вероятностью встречается в любом текстовом фрагменте каждой программы . В этом отношении длинные имена лучше коротких , а имена , удобные для поиска , лучше констант в коде . Лично я считаю , что однобуквенные имена могут использоваться ТОЛЬКО для локальных переменных в коротких методах . Длина имени должна соответствовать размеру его области видимости . Если переменная или константа может встречаться или использоваться в нескольких местах кодового блока , очень важно присвоить ей имя , удобное для поиска . Снова сравните : и _ _ _ _ _ _ _ _ Имя в этом фрагменте не слишком содержательно , но по крайней мере его удобно искать . Сознательное присваивание имен увеличивает длину функции , но подумайте , насколько проще найти _ _ _ , чем искать все вхождения цифры и фильтровать список до позиций с нужным смыслом . Избегайте схем кодирования имен У нас и так хватает хлопот с кодированием , чтобы искать новые сложности . Кодирование информации о типе или области видимости в именах только создает новые хлопоты по расшифровке . Вряд ли разумно заставлять каждого нового работника изучать очередной «язык» кодирования — в дополнение к изучению обычно немалого объема кода , скоторым он будет работать . Это только усложняет его работу при попытке решения задачи . Как правило , кодированные имена плохо произносятся и в них легко сделать опечатку . Венгерская запись В доисторические времена , когда в языках действовали ограничения на длину имен , мы нарушали это правило по необходимости — и не без сожалений . В первая буква имени переменной обозначала код типа . В ранних версиях имена могли состоять только из одной буквы и одной цифры . Венгерская запись , подняла эту проблему на новый уровень . Венгерская запись играла важную роль во времена , когда программы работали с целочисленными дескрипторами , длинными указателями , указателями на или различными реализациями «строк» с разным применением и атрибутами . Компиляторы в те дни не поддерживали проверку типов , поэтому программистам были нужны «подсказки» для запоминания типов . В современных языках существует куда более развитая система типов , а компиляторы запоминают типы и обеспечивают их соблюдение . Более того , появилась тенденция к использованию меньших классов и более коротких функций , чтобы программисты видели точку объявления каждой используемой переменной . - программисту кодировать типы в именах не нужно . Объекты обладают сильной типизацией , а рабочие среды развились до такой степени , что могут выявить ошибку типа еще до начала компиляции ! Таким образом , в наши дни венгерская запись и другие формы кодирования типов в именах превратились в обычные пережитки прошлого . Они усложняют изменение имени или типа переменных , функций и классов . Они затрудняют чтение кода . Наконец , они повышают риск того , что система кодирования собьет с толку читателя кода . Имя не изменяется при изменении типа ! Префиксы членов классов Префиксы _ , которыми когда - то снабжались переменные классов , тоже стали ненужными . Классы и функции должны быть достаточно компактными , чтобы вы могли обходиться без префиксов . Также следует использовать рабочую среду с цветовым выделением членов классов , обеспечивающим их наглядную идентификацию : _ Текстовое описание _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ . Кроме того , люди быстро учатся игнорировать префиксы и суффиксы , чтобы видеть содержательную часть имени . Чем больше мы читаем код , тем реже замечаем префиксы . В конечном итоге префикс превращается в невидимый балласт , характерный для старого кода . Интерфейсы и реализации Иногда в программах встречается особый случай кодирования . Допустим , вы строите АБСТРАКТНУЮ ФАБРИКУ для создания геометрических фигур . Фабрика представляет собой интерфейс , который реализуется конкретным классом . Как их назвать ? и ? Я предпочитаю оставлять имена интерфейсов без префиксов . Префикс , столь распространенный в старом коде , в лучшем случае отвлекает , а в худшем — передает лишнюю информацию . Я не собираюсь сообщать своим пользователям , что они имеют дело с интерфейсом . Им достаточно знать , что это , то есть фабрика фигур . Следовательно , при необходимости закодировать в имени либо интерфейс , либо реализацию , я выбираю реализацию . Имя , или даже уродливое , все равно лучше кодирования информации об интерфейсе . Избегайте мысленных преобразований Не заставляйте читателя мысленно преобразовывать ваши имена в другие , уже известные ему . Обычно эта проблема возникает из - за нежелания использовать понятия как из пространства задачи , так и из пространства решения . Такая проблема часто возникает при использовании однобуквенных имен переменных . Конечно , счетчик цикла можно назвать , или но только не ! , если его область видимости очень мала , и он не конфликтует с другими именами . Это связано с тем , что однобуквенные имена счетчиков циклов традиционны . Однако в большинстве других контекстов однобуквенные имена нежелательны в сущности , вы создаете временный заменитель , который должен быть мысленно преобразован пользователем в реальную концепцию . Нет худшей причины для выбора имени , чем та , что имена и уже заняты . Как правило , программисты весьма умны . А умные люди иногда любят показывать мощь интеллекта , демонстрируя свои способности к мысленному жонглированию . В конце концов , если вы помните , что переменная содержит - адрес с удаленным хостом и схемой , преобразованный к нижнему регистру , это совершенно очевидно свидетельствует о вашем уме . Одно из различий между умным и профессиональным программистом заключается в том , что профессионал понимает : ясность превыше всего . Профессионалы используют свою силу во благо и пишут код , понятный для других людей . Имена классов Имена классов и объектов должны представлять собой существительные и их комбинации : , , и . Старайтесь не использовать в именах классов такие слова , как , , или . Имя класса не должно быть глаголом . Имена методов Имена методов представляют собой глаголы или глагольные словосочетания : , , и т . д . Методы чтения записи и предикаты образуются из значения и префикса , и согласно стандарту . . . " " . … При перегрузке конструкторов используйте статические методы - фабрики с именами , описывающими аргументы . Например , запись . . обычно лучше записи . Рассмотрите возможность принудительного использования таких методов для этого соответствующие конструкторы объявляются приватными . Избегайте остроумия Картинка : _ . Если ваши имена будут излишне остроумными , то их смысл будет понятен только людям , разделяющим чувство юмора автора — и только если они помнят шутку . Все ли догадаются , что делает функция с именем ? Конечно , это очень мило , но , возможно , в данном случае лучше подойдет имя . Отдавайте предпочтение ясности перед развлекательной ценностью . Остроумие часто воплощается в форме просторечий или сленга . Например , не используйте имя вместо . Не используйте шуточки , привязанные к конкретной культуре , — например , вместо . Выберите одно слово для каждой концепции Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его . Например , существование в разных классах эквивалентных методов с именами , и неизбежно создаст путаницу . Как запомнить , к какому классу относится то или иное имя метода ? К сожалению , чтобы запомнить , какой термин использовался в той или иной библиотеке или классе , нередко приходится помнить , какой компанией , группой или программистом эта библиотека была создана . В противном случае вы потратите массу времени на просмотр заголовков и предыдущих примеров кода . Современные рабочие среды такие , как и предоставляют контекстно - зависимые подсказки — скажем , список методов , которые могут вызываться для конкретногообъекта . Однако следует учитывать , что в этом списке обычно не приводятся комментарии , которые вы записываете рядом с именами функций и списками параметров . И вам еще повезло , если в нем будут указаны имена параметров из объявлений функций . Имена функций должны быть законченными и логичными , чтобы программист мог сразу выбрать правильный метод без сбора дополнительной информации . Аналогичным образом , использование терминов , и в одной кодовой базе тоже вызывает путаницу . Чем принципиально отличается от ? Почему в двух случаях не используются одинаковые термины ? Такие имена создают ложное впечатление , что два объекта обладают совершенно разными типами , а также относятся к разным классам . Единый , согласованный лексикон окажет неоценимую помощь программистам , которые будут пользоваться вашим кодом . Воздержитесь от каламбуров Старайтесь не использовать одно слово в двух смыслах . В сущности , обозначение двух разных идей одним термином — это каламбур . Если следовать принципу «одно слово для каждой концепции» , в программе может появиться много классов , содержащих , например , метод . Пока списки параметров и возвращаемые значения разных методов остаются семантически эквивалентными , все хорошо . Однако программист может решить использовать имя «ради единообразия» независимо от того , выполняет ли этот метод добавление в прежнем смысле или нет . Допустим , программа содержит много классов с методами , которые создают новое значение сложением или конкатенацией двух существующих значений . Вы пишете новый класс с методом , помещающим свой единственный параметр в коллекцию . Стоит ли присвоить этому методу имя ? На первый взгляд это выглядит последовательно , потому что в программе уже используется множество других методов , но новый метод имеет другую семантику , поэтому ему лучше присвоить имя или . Присваивая новому методу имя , вы создаете нежелательный каламбур . Задача автора — сделать свой код как можно более понятным . Код должен восприниматься с первого взгляда , не требуя тщательного изучения . Ориентируйтесь на модель популярной литературы , в которой сам автор должен доступно выразить свои мысли , а не на академическую модель , в которой ученик усердным трудом постигает скрытый смысл публикации . Используйте имена из пространства решения Не забывайте : ваш код будут читать программисты . А раз так , не стесняйтесь использовать термины из области информатики , названия алгоритмов и паттернов , математические термины и т . д . Не ограничивайтесь именами исключительно из пространства задачи не заставляйте своих коллег постоянно бегать к клиенту и спрашивать , что означает каждое имя , когда соответствующая концепция уже знакома им под другим названием . Имя сообщит много полезной информации программисту , знакомому с паттерном «Посетитель» . И какой программист не знает , что такое «очередь заданий» ? Существует множество сугубо технических понятий , с которыми имеют дело программисты . Как правило , таким понятиям разумнее всего присваивать технические имена . Используйте имена из пространства задачи Если для того , что вы делаете , не существует подходящего «программизма» , используйте имя из пространства задачи . По крайней мере программист , занимающийся сопровождением кода , сможет узнать у специалиста в предметной области , что означает это имя . Разделение концепций из пространств задачи и решения — часть работы хорошего программиста и проектировщика . В коде , главным образом ориентированном на концепциииз пространства задачи , следует использовать имена из пространства задачи . Добавьте содержательный контекст Лишь немногие имена содержательны сами по себе . Все остальные имена следует помещать в определенный контекст для читателя кода , заключая их в классы , функции и пространства имен с правильно выбранными названиями . В крайнем случае контекст имени можно уточнить при помощи префикса . Допустим , в программе используются переменные с именами , , , , , и . Вполне очевидно , что в совокупности они образуют адрес . Но что , если переменная встретилась вам отдельно от других переменных внутри метода ? Сразу ли вы поймете , что она является частью адреса ? Контекст можно добавить при помощи префиксов : , , и т . д . По крайней мере читатель кода поймет , что переменные являются частью более крупной структуры . Конечно , правильнее было бы создать класс с именем , чтобы даже компилятор знал , что переменные являются частью чего - то большего . Возьмем метод из листинга . . Нужен ли переменным более содержательный контекст ? Имя функции определяет только часть контекста алгоритм предоставляет все остальное . При чтении функции становится видно , что три переменные , и являются компонентами сообщения М . К сожалению , контекст приходится вычислять . При первом взгляде на метод смысл переменных остается неясным . Листинг . . Переменные с неясным контекстом , " " " " " " " " " " " " Листинг . продолжение . " " " " . " % % % % " , , , , Функция длинновата , а переменные используются на всем ее протяжении . Чтобы разделить функцию на меньшие смысловые фрагменты , следует создать класс и сделать три переменные полями этого класса . Тем самым мы предоставим очевидный контекст для трех переменных — теперь абсолютно очевидно , что эти переменные являются частью . Уточнение контекста также позволяет заметно улучшить четкость алгоритма за счет его деления на меньшие функции листинг . . Листинг . . Переменные с контекстом , . " % % % % " , , , , . " " " " " " " " " " " " " " " " Не добавляйте избыточный контекст Если вы работаете над вымышленным приложением « » , не стоит снабжать имя каждого класса префиксом . В сущности , вы работаете против собственного инструментария . Введите букву « » , нажмите клавишу завершения — и вы получите длинный - предлинный список всех классов в системе . Разумно ли это ? пытается помочь вам , так стоит ли ей мешать ? Допустим , вы изобрели класс в учетном модуле и присвоили ему имя . Позднее адрес используется в приложении , обеспечивающем связь с клиентами . Будете ли вы использовать ? Насколько подходящим выглядит это имя ? Десять из символов либо избыточны , либо не относятся к делу . Короткие имена обычно лучше длинных , если только их смысл понятен читателю кода . Не включайте в имя больше контекста , чем необходимо . Имена и хорошо подходят для экземпляров класса , но для классов такой выбор неудачен . — вот хорошее имя класса . Если потребуется подчеркнуть различия между - адресами , адресами портов и веб - адресами , я подумаю об использовании имен , и . Полученные имена становятся более точными , а это , собственно , и является главной целью всего присваивания имен . Несколько слов напоследок Основные трудности с выбором хороших имен обусловлены необходимостью хороших описательных навыков и единого культурного фона . Это вопрос преподавания , а не вопрос техники , экономики или управления . В результате многие специалисты , работающие в этой области , так и не научились хорошо справляться с этой задачей . Люди также опасаются переименований из страха возражений со стороны других разработчиков . Мы не разделяем эти опасения , а изменение имен в лучшую сторону вызывает у нас только благодарность . Большей частью мы не запоминаем имена классов и методов . Современные инструменты берут на себя подобные мелочи , а мы следим за тем , чтобы программный код читался как абзацы и предложения или хотя бы как таблицы и структуры данных предложение не всегда является лучшим способом отображения данных . Возможно , своими переименованиями — как и любыми другими усовершенствованиями кода — вы кого - то удивите . Пусть это вас не останавливает . Последуйте этим правилам и посмотрите , не станет ли ваш код более удобочитаемым . Если вы занимаетесь сопровождением чужого кода , попробуйте решить проблемы средствами рефакторинга . Это даст немедленный результат и продолжит приносить плоды в долгосрочной перспективе . Глава . Функции Картинка : _ . На заре эпохи программирования системы строились из программ , функций и подпрограмм . До наших дней дожили только функции . Они образуют первый уровень структуризации в любой программе , и их грамотная запись является основной темой этой главы . Рассмотрим код в листинге . . В трудно найти длинную функцию , но после некоторых поисков мне это все же удалось . Функция не только длинна , но она содержит повторяющиеся фрагменты кода , множество загадочных строк , а также странные и неочевидные типы данных и функции . Попробуйте разобраться в ней за три минуты . Посмотрим , что вам удастся понять . Листинг . . . , . . " " . . _ _ , ! . . . . " ! - . " . . " \ " . " " , ! . . . " . " ! - . " . . " \ " . . . " " . " " , ! . . . . " \ " . " ! - . " . . " \ " . . _ _ , ! . . . . " ! - . " . . " \ " . . . Удалось ли вам разобраться с функцией за три минуты ? Вероятно , нет . В ней происходит слишком много всего , и притом на разных уровнях абстракции . Загадочные строки и непонятные вызовы функций смешиваются в конструкциях двойной вложенности , к тому же зависящих от состояния флагов . Но после выделения нескольких методов , переименований и небольшой реструктуризации мне удалось представить смысл этой функции в девяти строках листинга . . Посмотрим , удастся ли вам разобраться в ней за следующие три минуты . Листинг . . . переработанная версия , . " " . , , . . , , . . . Если только вы не занимаетесь активным изучением , скорее всего , вы не разберетесь во всех подробностях . Но по крайней мере вы поймете , что функция включает в тестовую страницу какие - то начальные и конечные блоки , а потом генерирует код . Если вы знакомы с , то , скорее всего , поймете , что эта функция является частью тестовой инфраструктуры на базе . И конечно , это правильное предположение . Прийти к такому выводу на основании листинга . несложно , но из листинга . это , мягко говоря , неочевидно . Что же делает функцию из листинга . такой понятной и удобочитаемой ? Как заставить функцию передавать намерения разработчика ? Какие атрибуты функции помогут случайному читателю составить интуитивное представление о выполняемых ей задачах ? Компактность ! Первое правило : функции должны быть компактными . Второе правило : функции должны быть еще компактнее . Я не могу научно обосновать свое утверждение . Не ждите от меня ссылок на исследования , доказывающие , что очень маленькие функции лучше больших . Я могу всего лишь сказать , что я почти четыре десятилетия писал функции всевозможных размеров . Мне доводилось создавать кошмарных монстров в строк . Я написал бесчисленное множество функций длиной от до строк . И я писал функции от до строк . Мой практический опыт научил меня ценой многих проб и ошибок , что функции должны быть очень маленькими . В - е годы считалось , что функция должна занимать не более одного экрана . Конечно , тогда экраны состояли из строк и столбцов , а редакторы использовали строки для административных целей . В наши дни с мелким шрифтом на хорошем большом мониторе можно разместить символов в строке и и более строк на экране . Однако строки не должны состоять из символов , а функции — из строк . Желательно , чтобы длина функции не превышала строк . Насколько короткой может быть функция ? В году я заехал к Кенту Беку в его дом в Орегоне . Мы посидели и позанимались программированием . В один момент он показал мне симпатичную маленькую программу , которую он назвал . Программа создавала на экране визуальный эффект , очень похожий на эффект волшебной палочки феи - крестной из фильма «Золушка» . При перемещении мыши с курсора рассыпались замечательные блестящие искорки , которые осыпались к нижнему краю экрана под воздействием имитируемого гравитационного поля . Когда Кент показал мне код , меня поразило , насколько компактными были все функции . Многие из моих функций в программах растягивались по вертикали чуть ли не на километры . Однако каждая функция в программе Кента занимала всего две , три или четыре строки . Все функции были предельно очевидными . Каждая функция излагала свою историю , и каждая история естественным образом подводила вас к началу следующей истории . Воткакими короткими должны быть функции ! Более того , функции должны быть еще короче , чем в листинге . ! На деле листинг . следовало бы сократить до листинга . . Листинг . . . переработанная версия , , . Блоки и отступы Из сказанного выше следует , что блоки в командах , , и т . д . должны состоять из одной строки , в которой обычно содержится вызов функции . Это не только делает вмещающую функцию более компактной , но и способствует документированию кода , поскольку вызываемой в блоке функции можно присвоить удобное содержательное имя . Кроме того , функции не должны содержать вложенных структур , так как это приводит к их увеличению . Максимальный уровень отступов в функции не должен превышать одного - двух . Разумеется , это упрощает чтение и понимание функций . Правило одной операции Картинка : _ . Совершенно очевидно , что функция из листинга . выполняет множество операций . Она создает буферы , производит выборку данных , ищет унаследованные страницы , строит пути , присоединяет загадочные строки , генерирует код … и это еще не все . С другой стороны , в листинге . выполняется всего одна простая операция : включение в тестовую страницу начальных и конечных блоков . Следующий совет существует в той или иной форме не менее лет . ФУНКЦИЯ ДОЛЖНА ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ . ОНА ДОЛЖНА ВЫПОЛНЯТЬ ЕЕ ХОРОШО . И НИЧЕГО ДРУГОГО ОНА ДЕЛАТЬ НЕ ДОЛЖНА . Проблема в том , что иногда бывает трудно определить , что же считать «одной операцией» . В листинге . выполняется одна операция ? Легко возразить , что в нем выполняются минимум три операции : . Функция проверяет , является ли страница тестовой страницей . . Если является , то в нее включаются начальные и конечные блоки . . Для страницы генерируется код . Так как же ? Сколько операций выполняет функция — одну или три ? Обратите внимание : три этапа работы функции находятся на одном уровне абстракции под объявленным именем функции . Ее можно было бы описать в виде короткого - абзаца : • , мы проверяем , является ли страница тестовой , и если является — включаем начальные и конечные блоки . В любом случае для страницы генерируетсякод . Если функция выполняет только те действия , которые находятся на одном уровне под объявленным именем функции , то эта функция выполняет одну операцию . В конце концов , функции пишутся прежде всего для разложения более крупной концепции иначе говоря , имени функции на последовательность действий на следующем уровне абстракции . Вполне очевидно , что листинг . содержит множество различных действий на разных уровнях абстракции . Поэтому в нем явно выполняется более одной операции . Даже листинг . содержит два уровня абстракции это доказывается тем , что нам удалось его сократить . С другой стороны , осмысленно сократить листинг . очень трудно . Команду можно вынести в функцию с именем , но это простая переформулировка кода без изменения уровня абстракции . Итак , чтобы определить , что функция выполняет более одной операции , попробуйте извлечь из нее другую функцию , которая бы не являлась простой переформулировкой реализации . Секции в функциях Взгляните на листинг . на с . . Обратите внимание : функция разделена на секции объявления , инициализация , отбор . Это очевидный признак того , что функция выполняет более одной операции . Функцию , выполняющую только одну операцию , невозможно осмысленно разделить на секции . Один уровень абстракции на функцию Чтобы убедиться в том , что функция выполняет «только одну операцию» , необходимо проверить , что все команды функции находятся на одном уровне абстракции . Легко убедиться , что листинг . нарушает это правило . Некоторые из его концепций — например , — находятся на очень высоком уровне абстракции другие скажем , . — на среднем уровне . Наконец , третьи — такие , как . " \ " — относятся к чрезвычайно низкому уровню абстракции . Смешение уровней абстракции внутри функции всегда создает путаницу . Читатель не всегда понимает , является ли некоторое выражение важной концепцией или второстепенной подробностью . Что еще хуже , при их смешении функция постепенно начинает обрастать все большим количеством второстепенных подробностей . Чтение кода сверху вниз : правило понижения Код должен читаться как рассказ — сверху вниз , . . За каждой функцией должны следовать функции следующего уровня абстракции . Это позволяет читать код , последовательно спускаясь по уровням абстракции в ходе чтения списка функций . Я называю такой подход «правилом понижения» . Сказанное можно сформулировать и иначе : программа должна читаться так , словно она является набором - абзацев , каждый из которых описывает текущий уровень абстракции и ссылается на последующие - абзацы следующего нижнего уровня . • Чтобы включить начальные и конечные блоки , мы сначала включаем начальные блоки , затем содержимое тестовой страницы , а затем включаем конечные блоки . • Чтобы включить начальные блоки , мы сначала включаем пакетные начальные блоки , если имеем дело с пакетом тестов , а затем включаем обычные начальные блоки . • Чтобы включить пакетные начальные блоки , мы ищем в родительской иерархии страницу и добавляем команду с путем к этой странице . • Чтобы найти в родительской иерархии… Опыт показывает , что программистов очень трудно научить следовать этому правилу и писать функции , остающиеся на одном уровне абстракции . Тем не менее освоить этотприем очень важно . Он играет ключевую роль для создания коротких функций , выполняющих только одну операцию . Построение кода по аналогии с набором последовательных - абзацев — эффективный метод поддержания единого уровня абстракции . Взгляните на листинг . в конце этой главы . В нем приведен полный код функции , переработанной в соответствии с описанными здесь принципами . Обратите внимание на то , как каждая функция «представляет» читателю следующую функцию и как каждая функция остается на едином уровне абстракции . Команды Написать компактную команду довольно сложно . Даже команда всего с двумя условиями занимает больше места , чем в моем представлении должен занимать один блок или функция . Также трудно создать команду , которая делает что - то одно — по своей природе команды всегда выполняют операций . К сожалению , обойтись без команд удается не всегда , но по крайней мере мыможемпозаботиться о том , чтобы эти команды были скрыты в низкоуровневом классе и не дублировались в коде . И конечно , в этом нам может помочь полиморфизм . В листинге . представлена всего одна операция , зависящая от типа работника . Листинг . . . . : : : : . Эта функция имеет ряд недостатков . Во - первых , она велика , а при добавлении новых типов работников она будет разрастаться . Во - вторых , она совершенно очевидно выполняет более одной операции . В - третьих , она нарушает принцип единой ответственности , так как у нее существует несколько возможных причин изменения . В - четвертых , она нарушает принцип открытости закрытости , потому что код функции должен изменяться при каждом добавлении новых типов . Но , пожалуй , самый серьезный недостаток заключается в том , что программа может содержать неограниченное количество других функций с аналогичной структурой , например : , или , и так далее . Все эти функции будут иметь все ту же ущербную структуру . Решение проблемы листинг . заключается в том , чтобы похоронить команду в фундаменте АБСТРАКТНОЙ ФАБРИКИ и никому ее не показывать . Фабрика использует команду для создания соответствующих экземпляров потомков , а вызовы функций , , и т . д . проходят полиморфную передачу через интерфейс . Листинг . . и - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - . : : : : . Мое общее правило в отношении команд гласит , что эти команды допустимы , если они встречаются в программе однократно , используются для создания полиморфных объектов и скрываются за отношениями наследования , чтобы оставаться невидимыми для остальных частей системы . Конечно , правил без исключений не бывает и в некоторых ситуациях приходится нарушать одно или несколько условий этого правила . Используйте содержательные имена В листинге . я переименовал нашу функцию в . . Новое имя гораздо лучше , потому что оно точнее описывает , что делает функция . Кроме того , всем приватным методам были присвоены столь же содержательные имена , и т . д . Трудно переоценить пользу хороших имен . Вспомните принцип Уорда : «Вы работаете с чистым кодом , если каждая функция в основном делает то , что вы от нее ожидали» . Половина усилий по реализации этого принципа сводится к выбору хороших имен для компактных функций , выполняющих одну операцию . Чем меньше и специализированнее функция , тем проще выбрать для нее содержательное имя . Не бойтесь использовать длинные имена . Длинное содержательное имя лучше короткого невразумительного . Выберите схему , которая позволяет легко прочитать слова в имени функции , а затем составьте из этих слов имя , которое описывает назначение функции . Не бойтесь расходовать время на выбор имени . Опробуйте несколько разных имен и посмотрите , как читается код с каждым из вариантов . В современных рабочих средах таких , как и задача смены имени решается тривиально . Используйте одну из этих сред и поэкспериментируйте с разными именами , пока не найдете самое содержательное . Выбор содержательных имен прояснит архитектуру модуля и поможет вам усовершенствовать ее . Нередко поиски хороших имен приводят к полезной реструктуризации кода . Будьте последовательны в выборе имен . Используйте в именах функций те же словосочетания , глаголы и существительные , которые используются в ваших модулях . Для примера можно взять имена , , и . Благодаря единой фразеологии эти имена рассказывают связную историю . В самом деле , если бы япоказал вам только эту последовательность , вы бы спросили : «А где же , и ? » Вспомните — «…в основном делает то , что вы от нее ожидали» . Аргументы функций В идеальном случае количество аргументов функции равно нулю нуль - арная функция . Далее следуют функции с одним аргументом унарные и с двумя аргументами бинарные . Функций с тремя аргументами тернарных следует по возможности избегать . Необходимость функций с большим количеством аргументов полиарных должна быть подкреплена очень вескими доводами — и все равно такие функции лучше не использовать . Картинка : _ . Аргументы усложняют функции и лишают их значительной части концептуальной мощи . Именно по этой причине я почти полностью избавился от них в этом примере . Возьмем хотя бы переменную . Ее можно было бы передать в аргументе вместо того , чтобы делать ее переменной экземпляра , но тогда читателям кода пришлось бы интерпретировать ее каждый раз , когда она встречается в коде . Когда вы читаете историю , рассказываемую модулем , вызов выглядит намного более понятным , чем вызов . Аргумент и имя функции находятся на разных уровнях абстракции , а читателю приходится помнить о подробностях то есть , которые на данный момент не особенно важны . Аргументы создают еще больше проблем с точки зрения тестирования . Только представьте , как трудно составить все тестовые сценарии , проверяющие правильность работы кода со всеми комбинациями аргументов . Если аргументов нет — задача тривиальна . При одном аргументе все обходится без особых сложностей . С двумя аргументами ситуация усложняется . Если же аргументов больше двух , задача тестирования всех возможных комбинаций выглядит все более устрашающе . Выходные аргументы запутывают ситуацию еще быстрее , чем входные . Читая код функции , мы обычно предполагаем , что функция получает информацию в аргументах , и выдает ее в возвращаемом значении . Как правило , никто не ожидает , что функция будет возвращать информацию в аргументах . Таким образом , выходные аргументы часто заставляют нас браться за чтение функции заново . Если уж обойтись без аргументов никак не удается , постарайтесь хотя бы ограничиться одним входным аргументом . Смысл вызова . вполне прозрачен — понятно , что мы собираемся сгенерировать данные для объекта . Стандартные унарные формы Существует два очень распространенных случая вызова функции с одним аргументом . Первая — проверка некоторого условия , связанного с аргументом , как в вызове " " . Вторая — обработка аргумента , его преобразование и возвращение . Например , вызов " " преобразует имя файла в формате в возвращаемое значение . Выбирайте имена , которые четко отражают различия , и всегда используйте две формы в логически непротиворечивом контексте . См . далее «Разделение команди запросов» . Несколько менее распространенным , но все равно очень полезным частным случаем функции с одним аргументом являетсясобытие . В этой форме имеется входной аргумент , а выходного аргумента нет . Предполагается , что программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния системы , например , . Будьте внимательны при использовании данной формы . Читателю должно быть предельно ясно , что перед ним именно событие . Тщательно выбирайте имена и контексты . Старайтесь избегать унарных функций , не относящихся к этим формам , например . Преобразования , в которых вместо возвращаемого значения используется выходной аргумент , сбивают читателя с толку . Если функция преобразует свой входной аргумент , то результат должен передаваться в возвращаемом значении . В самом деле , вызов лучше вызова , даже если реализация в первом случае просто возвращает входной аргумент . По крайней мере она соответствует основной форме преобразования . Аргументы - флаги Аргументы - флаги уродливы . Передача логического значения функции — воистину ужасная привычка . Она немедленно усложняет сигнатуру метода , громко провозглашая , чтофункция выполняет более одной операции . При истинном значении флага выполняется одна операция , а при ложном — другая ! В листинге . у нас нет выбора , потому что вызывающая сторона уже передает этот флаг , а я хотел ограничить область переработки границами функции . Тем не менее вызов метода откровенно сбивает с толку бедного читателя . Если навести указатель мыши на вызов и увидеть , ситуация слегка проясняется , но ненамного . Эту функцию следовало бы разбить на две : и . Бинарные функции Функцию с двумя аргументами понять сложнее , чем унарную функцию . Например , вызов выглядит более доступно , чем , . Хотя смысл обеих форм понятен , первая форма просто проскальзывает под нашим взглядом , моментально раскрывая свой смысл . Во второй форме приходится сделать непродолжительную паузу , пока вы не поймете , что первый параметр должен игнорироваться . И конечно , это в конечном итоге создает проблемы , потому что никакие части кода игнорироваться не должны . Именно в проигнорированных частях чаще всего скрываются ошибки . Конечно , в некоторых ситуациях форма с двумя аргументами оказывается уместной . Например , вызов , абсолютно разумен . Точка в декартовом пространстве естественным образом создается с двумя аргументами . В самом деле , вызов выглядел бы довольно странно . Однако два аргумента в нашем случае являются упорядоченными компонентами одного значения ! Напротив , и не имеют ни естественной связи , ни естественного порядка . Даже с очевидными бинарными функциями вида , возникают проблемы . Сколько раз вы помещали туда , где должен был находиться аргумент ? Эти два аргумента не имеют естественного порядка . Последовательность , — не более чем условное правило , которое запоминается не сразу . Бинарные функции не являются абсолютным злом , и вам почти наверняка придется писать их . Тем не менее следует помнить , что за их использование приходится расплачиваться , а вам стоит воспользоваться всеми доступными средствами для их преобразования в унарные . Например , можно сделать метод членом класса , чтобы использовать запись . . Другой вариант — преобразование в поле текущего класса , чтобы переменную не приходилось передавать при вызове . Также можно создать новый класс , который получает в конструкторе и содержит метод . Тернарные функции Разобраться в функции с тремя аргументами значительно сложнее , чем в бинарной функции . Проблемы соблюдения порядка аргументов , приостановки чтения и игнорирования увеличиваются более чем вдвое . Я рекомендую очень хорошо подумать , прежде чем создавать тернарную функцию . Для примера возьмем стандартную перегруженную версию с тремя аргументами : , , . Сколько раз вы читали значение и думали , что перед вами ? Я сталкивался с этой конкретной тернарной функцией и задерживался на ней много раз . Более того , каждый раз , когда я ее вижу , мне приходится делать новый заход и вспоминать о необходимости игнорировать . С другой стороны , следующая тернарная функция не столь коварна : . , , . . Хотя и она не воспринимается с первого раза , в данном случае эта трудность оправдана . Всегда полезно лишний раз вспомнить , что равенство вещественных значений — понятие относительное . Объекты как аргументы Если функция должна получать более двух или трех аргументов , весьма вероятно , что некоторые из этих аргументов стоит упаковать в отдельном классе . Рассмотрим следующие два объявления : , , , Сокращение количества аргументов посредством создания объектов может показаться жульничеством , но это не так . Если переменные передаются совместно как единое целое как переменные и в этом примере , то , скорее всего , вместе они образуют концепцию , заслуживающую собственного имени . Списки аргументов Иногда функция должна получать переменное количество аргументов . Для примера возьмем метод . : . " % % . . " , , Если все переменные аргументы считаются равноправными , как в этом примере , то их совокупность эквивалентна одному аргументу типа . По этой причине функция . фактически является бинарной . И действительно , следующее объявление . подтверждает это : , … Следовательно , в данном случае действуют уже знакомые правила . Функции с переменным списком аргументов могут быть унарными , бинарными и даже тернарными , но использовать большее количество аргументов было бы ошибкой . … , … , , … Глаголы и ключевые слова Выбор хорошего имени для функции способен в значительной мере объяснить смысл функции , а также порядок и смысл ее аргументов . В унарных функциях сама функция и ее аргумент должны образовывать естественную пару «глагол существительное» . Например , вызов вида смотрится весьма информативно . Читатель понимает , что чем бы ни было «имя» , оно куда - то «записывается» . Еще лучше запись , которая сообщает , что «имя» записывается в «поле» какой - то структуры . Последняя запись является примером использования ключевых слов в имени функции . В этой форме имена аргументов кодируются в имени функции . Например , можно записать в виде , . Это в значительной мере решает проблему запоминания порядка аргументов . Избавьтесь от побочных эффектов Побочные эффекты суть ложь . Ваша функция обещает делать что - то одно , но делает что - то другое , скрытое от пользователя . Иногда она вносит неожиданные изменения в переменные своего класса — скажем , присваивает им значения параметров , переданных функции , или глобальных переменных системы . В любом случае такая функция является коварной и вредоносной ложью , которая часто приводит к созданию противоестественных временных привязок и других зависимостей . Для примера возьмем безвредную на первый взгляд функцию из листинга . . Функция использует стандартный алгоритм для проверки пары «имя пользователя пароль» . Она возвращает в случае совпадения или при возникновении проблем . Но у функции также имеется побочный эффект . Сможете ли вы обнаружить его ? Листинг . . . , . ! . . . , " " . . Разумеется , побочным эффектом является вызов . . Имя сообщает , что функция проверяет пароль . Оно ничего не говорит о том , что функция инициализирует сеанс . Таким образом , тот , кто поверит имени функции , рискует потерять текущие сеансовые данные , когда он решит проверить данные пользователя . Побочный эффект создает временную привязку . А именно , функция может вызываться только в определенные моменты времени когда инициализация сеанса может быть выполнена безопасно . Несвоевременный вызов может привести к непреднамеренной потере сеансовых данных . Временные привязки создают массу проблем , особенно когда они прячутся в побочных эффектах . Если без временной привязки не обойтись , этот факт должен быть четко оговорен в имени функции . В нашем примере функцию можно былобы переименовать в , хотя это безусловно нарушает правило «одной операции» . Выходные аргументы Аргументы естественным образом интерпретируются как входные данные функции . Каждый , кто занимался программированием более нескольких лет , наверняка сталкивалсяс необходимостью дополнительной проверки аргументов , которые на самом деле оказывались выходными , а не входными . Пример : Присоединяет ли эта функция в качестве завершающего блока к чему - то другому ? Или она присоединяет какой - то завершающий блок к ? Является ли входным или выходным аргументом ? Конечно , можно посмотреть на сигнатуру функции и получить ответ : Вопрос снимается , но только после проверки объявления . Все , что заставляет обращаться к сигнатуре функции , нарушает естественный ритм чтения кода . Подобных «повторных заходов» следует избегать . До наступления эпохи объектно - ориентированного программирования без выходных аргументов иногда действительно не удавалось обойтись . Но в ОО - языках эта проблема в целом исчезла , потому что сама функция может вызываться для выходного аргумента . Иначе говоря , функцию лучше вызывать в виде . В общем случае выходных аргументов следует избегать . Если ваша функция должна изменять чье - то состояние , пусть она изменяет состояние своего объекта - владельца . Разделение команд и запросов Функция должна что - то делать или отвечать на какой - то вопрос , но не одновременно . Либо функция изменяет состояние объекта , либо возвращает информацию об этом объекте . Совмещение двух операций часто создает путаницу . Для примера возьмем следующую функцию : , Функция присваивает значение атрибуту с указанным именем и возвращает , если присваивание прошло успешно , или , если такой атрибут не существует . Это приводитк появлению странных конструкций вида " " , " " … Представьте происходящее с точки зрения читателя кода . Что проверяет это условие ? Что атрибут " " содержит ранее присвоенное значение " " ? Или что проверяет атрибуту " " успешно присвоено значение " " ? Смысл невозможно вывести из самого вызова , потому что мы не знаем , чем в данном случае является слово — глаголом или прилагательным . Автор предполагал , что является глаголом , но в контексте команды это имя скорее воспринимается как прилагательное . Таким образом , команда читается в виде «Если атрибуту ранее было присвоено значение » , а не «присвоить атрибуту значение , и если все прошло успешно , то…» Можно было бы попытаться решить проблему , переименовав функцию в , но это не особенно улучшает удобочитаемость команды . Полноценное решение заключается в отделении команды от запроса , чтобы в принципе исключить любую неоднозначность . " " " " , " " … Используйте исключения вместо возвращения кодов ошибок Возвращение кодов ошибок функциями - командами является неочевидным нарушением принципа разделения команд и запросов . Оно поощряет использование команд в предикатных выражениях : _ Такие конструкции не страдают от смешения глаголов с прилагательными , но они приводят к созданию структур слишком глубокой вложенности . При возвращении кода ошибки возникает проблема : вызывающая сторона должна немедленно отреагировать на ошибку . _ . . _ . . . _ . " " . " " . " " . " " _ С другой стороны , если вместо возвращения кодов ошибок используются исключения , то код обработки ошибок изолируется от ветви нормального выполнения и упрощается : . . . . . . . Изолируйте блоки Блоки выглядят весьма уродливо . Они запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой . По этой причине тела блоков и рекомендуется выделять в отдельные функции . . . . . . . . В этом примере функция специализируется на обработке ошибок . В этой функции легко разобраться , а потом забыть о ней . Функция специализируется напроцессе полного удаления страницы . Читая ее , можно не обращать внимания на обработку ошибок . Таким образом , код нормального выполнения отделяется от кода обработки ошибок , а это упрощает его понимание и модификацию . Обработка ошибок как одна операция Функции должны выполнять одну операцию . Обработка ошибок — это одна операция . Значит , функция , обрабатывающая ошибки , ничего другого делать не должна . Отсюда следует , что если в функции присутствует ключевое слово , то оно должно быть первым словом в функции , а после блоков ничего другого быть не должно как в предыдущем примере . Магнит зависимостей . Возвращение кода ошибки обычно подразумевает , что в программе имеется некий класс или перечисление , в котором определяются все коды ошибок . , , _ , , _ _ , _ _ Подобные классы называютсямагнитами зависимостей они должны импортироваться и использоваться многими другими классами . При любых изменениях перечисления все эти классы приходится компилировать и развертывать заново . Это обстоятельство создает негативную нагрузку на класс . Программистам не хочется добавлять новые ошибки , чтобы не создавать себе проблем со сборкой и развертыванием . Соответственно , вместо добавления новых кодов ошибок они предпочитают использовать старые . Если вместо кодов ошибок использовать исключения , то новые исключения определяютсяпроизводнымиот класса исключения . Их включение в программу не требует перекомпиляции или повторного развертывания . Не повторяйтесь Картинка : _ . Внимательно присмотревшись к листингу . , можно заметить , что один из алгоритмов повторяется в нем четыре раза : по одному разу для , , и . Обнаружить это дублирование нелегко , потому что четыре вхождения алгоритма перемешаны с другим кодом , а в дублировании фрагментов имеются некоторые различия . Тем не менеедублирование создает проблемы , потому что оно увеличивает объем кода , а при изменении алгоритма вам придется вносить изменения сразу в четырех местах . Также вчетверо возрастает вероятность ошибки . В листинге . дублирование устраняется при помощи метода . Снова прочитайте код и обратите внимание , насколько проще читается весь модуль после устранения дублирования . Дублирование иногда считается корнем всего зла в программировании . Было создано много приемов и методологий , направленных на контроль и устранение дублирования . Возьмем хотя бы нормальные формы баз данных Кодда , предназначенные для устранения дубликатов в данных . Или другой пример : объектно - ориентированные языки помогают сконцентрировать в базовых классах код , который в других обстоятельствах мог бы дублироваться в разных местах . Структурное программирование , аспектно - ориентированное программирование , компонентно - ориентированное программирование — все эти технологии отчасти являются стратегиями борьбы с дублированием . Похоже , с момента изобретения подпрограмм все новшества в разработке программного обеспечения были направлены исключительно на борьбу с дублированием в исходном коде . Структурное программирование Некоторые программисты следуют правилам структурного программирования , изложенным Эдгаром Дейкстрой . Дейкстра считает , что каждая функция и каждый блок внутри функции должны иметь одну точку входа и одну точку выхода . Выполнение этого правила означает , что функция должна содержать только одну команду , в циклах не должны использоваться команды или , а команды не должны использоваться никогда и ни при каких условиях . Хотя мы с симпатией относимся к целям и методам структурного программирования , в очень компактных функциях эти правила не приносят особой пользы . Только при увеличении объема функций их соблюдение обеспечивает существенный эффект . Итак , если ваши функции остаются очень компактными , редкие вкрапления множественных , команд и не принесут вреда , а иногда даже повышают выразительность по сравнению с классической реализацией с одной точкой входа и одной точкой выхода . С другой стороны , команда имеет смысл только в больших функциях , поэтому ее следует избегать . Как научиться писать такие функции ? Написание программ сродни любому другому виду письменной работы . Когда вы пишете статью или доклад , вы сначала излагаете свои мысли , а затем «причесываете» их до тех пор , пока они не будут хорошо читаться . Первый вариант может быть неуклюжим и нелогичным вы переделываете , дополняете и уточняете его , пока он не будет читаться так , как вам хочется . Когда я пишу свои функции , они получаются длинными и сложными . В них встречаются многоуровневые отступы и вложенные циклы . Они имеют длинные списки аргументов . Имена выбираются хаотично , а в коде присутствуют дубликаты . Но у меня также имеется пакет модульных тестов для всех этих неуклюжих строк до последней . Итак , я начинаю «причесывать» и уточнять свой код , выделять новые функции , изменять имена и устранять дубликаты . Я сокращаю методы и переупорядочиваю их . Иногда приходится ломать целые классы , но при этом слежу за тем , чтобы все тесты выполнялись успешно . В конечном итоге у меня остаются функции , построенные по правилам , изложенным в этой главе . Я не записываю их так с самого начала . И вообще не думаю , что кому - нибудь это под силу . Завершение Каждая система строится в контексте языка , отражающего специфику предметной области и разработанного программистами для описания этой системы . В этом языке функции играют роль глаголов , а классы — существительных . Не стоит полагать , что мы возвращаемся к кошмарной древней практике , по которой существительные и глаголы в документе с требованиями становились первыми кандидатами для классов и функций системы . Скорее речь идет о гораздо более древней истине . Искусство программирования является и всегда было искусством языкового проектирования . Опытные программисты рассматривают систему как историю , которую они должны рассказать , а не как программу , которую нужно написать . Они используют средства выбранного ими языка программирования для конструирования гораздо более богатого и выразительного языка , подходящего для этого повествования . Частью этого предметно - ориентированного языка является иерархия функций , которые описывают все действия , выполняемые в рамках системы . В результате искусной рекурсии эти действия формулируются на том самом предметно - ориентированном языке , который они определяют для изложения своей маленькой части истории . Эта глава была посвящена механике качественного написания функций . Если вы будете следовать этим правилам , ваши функции будут короткими , удачно названными и хорошо организованными . Но никогда не забывайте , что ваша настоящая цель — «рассказать историю» системы , а написанные вами функции должны четко складываться в понятный и точный язык , который поможет вам в этом . Листинг . . . . . . . . . , , . . . . . . . " " . _ _ , " - " " " , " - " . . " " , " - " . _ _ , " - " . . , ! , . , . . , . " \ ! " . . " . " Листинг . продолжение . . " \ " Литература : , , . . , - , . : . , : , , , , . : : , . , - , . : , , , - , . : , . - . , . . , . . . , , , . Глава . Комментарии Картинка : _ . Не комментируйте плохой код — перепишите его . Брайан У . Керниган и П . Дж . Плауэр Ничто не помогает так , как уместный комментарий . Ничто не загромождает модуль так , как бессодержательные и безапелляционные комментарии . Ничто не приносит столько вреда , как старый , утративший актуальность комментарий , распространяющий ложь и дезинформацию . Комментарии — не список Шиндлера . Не стоит относиться к ним как к «абсолютному добру» . На самом деле комментарии в лучшем случае являются неизбежным злом . Если бы языки программирования были достаточно выразительными или если бы мы умели искусно пользоваться этими языками для выражения своих намерений , то потребность в комментариях резко снизилась бы , а может , и вовсе сошла «на нет» . Грамотное применение комментариев должно компенсировать нашу неудачу в выражении своих мыслей в коде . Обратите внимание на слово «неудачу» . Я абсолютно серьезно . Комментарий — всегда признак неудачи . Мы вынуждены использовать комментарии , потому что нам не всегда удается выразить свои мысли без них , однако гордиться здесь нечем . Итак , вы оказались в ситуации , в которой необходимо написать комментарий ? Хорошенько подумайте , нельзя ли пойти по другому пути и выразить свои намерения в коде . Каждый раз , когда вам удается это сделать , — похлопайте себя по плечу . Каждый раз , когда вы пишете комментарий , — поморщитесь и ощутите свою неудачу . Почему я так настроен против комментариев ? Потому что они лгут . Не всегда и не преднамеренно , но это происходит слишком часто . Чем древнее комментарий , чем дальше он расположен от описываемого им кода , тем больше вероятность того , что он просто неверен . Причина проста : программисты не могут нормально сопровождать комментарии . Программный код изменяется и эволюционирует . Его фрагменты перемещаются из одного места в другое , раздваиваются , размножаются и сливаются . К сожалению , комментарии не всегда сопровождают их — и не всегдамогутсопровождать их . Слишком часто комментарии отделяются от описываемого ими кода и превращаются в пометки непонятной принадлежности , с постоянно снижающейся точностью . Посмотрите , что произошло с этим комментарием и той строкой , которую он должен описывать : _ _ " - \ \ , \ \ - \ \ - \ \ " " - \ \ - \ \ : - \ \ : - \ \ " Пример : " , : : " Другие переменные экземпляра вероятно , добавленные позднее вклинились между константой _ _ и пояснительным комментарием . На это можно возразить , что программисты должны быть достаточно дисциплинированными , чтобы поддерживать в своем коде актуальные , точные и релевантные комментарии . Согласен , должны . Но я бы предпочел , чтобы вместо этого программист постарался сделать свой код настолько четким и выразительным , чтобы комментарии были попростуне нужны . Неточные комментарии гораздо вреднее , чем полное отсутствие комментариев . Они обманывают и сбивают с толку . Они создают у программиста невыполнимые ожидания . Они устанавливают устаревшие правила , которые не могут или не должны соблюдаться в будущем . Истину можно найти только в одном месте : в коде . Только код может правдиво сообщить , что он делает . Это единственный источник действительно достоверной информации . Таким образом , хотя комментарии иногда необходимы , мы потратим немало усилий для того , чтобы свести их использование к минимуму . Комментарии не компенсируют плохого кода Одной из распространенных причин для написания комментариев является низкое качество кода . Вы пишете модуль и видите , что код получился запутанным и беспорядочным . Вы знаете , что разобраться в нем невозможно . Поэтому вы говорите себе : «О , да это стоит прокомментировать ! » Нет ! Лучше исправьте свой код ! Ясный и выразительный код с минимумом комментариев гораздо лучше громоздкого , сложного кода с большим количеством комментариев . Не тратьте время на написание комментариев , объясняющих созданную вами путаницу , — лучше потратьте его на исправление . Объясните свои намерения в коде И все же в некоторых ситуациях код оказывается не лучшим средством для объяснений . К сожалению , многие программисты воспринимают этот факт иначе : они полагают , чтокодникогдане является хорошим средством для объяснений . А это , разумеется , неправда . С каким бы кодом вы предпочли работать — с таким : Проверить , положена ли работнику полная премия . _ . Или с таким : . Чтобы объяснить большую часть ваших намерений в коде , достаточно нескольких секунд . Нередко задача сводится с созданию функции , которая сообщает то же , что и комментарий , который вы собираетесь написать . Хорошие комментарии Впрочем , необходимые и полезные комментарии все же существуют . Мы рассмотрим несколько примеров , которые , на мой взгляд , стоят затраченных на них битов . И все же следует помнить , что по - настоящему хороший комментарий — тот , без которого вам удастся обойтись . Юридические комментарии Иногда корпоративные стандарты кодирования заставляют нас вставлять комментарии по юридическим соображениям . Например , заявление об авторских правах — необходимая информация , которая вполне может размещаться в комментарии в начале каждого файла с исходным кодом . Ниже приведен стандартный заголовок комментария , который вставляется в начало каждого исходного файла в . К счастью , наша автоматически сворачивает этот комментарий , чтобы он не загромождал экран . , , , . . Публикуется на условиях лицензии версии и выше . Такие комментарии не должны представлять собой комментарии или юридические трактаты . Вместо того чтобы перечислять в комментарии все условия , по возможности ограничьтесь ссылкой на стандартную лицензию или другой внешний документ . Информативные комментарии Иногда бывает полезно включить в комментарий пояснение к коду . Возьмем следующий комментарий , объясняющий возвращаемое значение абстрактного метода : Возвращает тестируемый экземпляр . Такие комментарии бывают полезными , но там , где это возможно , информацию лучше передавать в имени функции . Например , в данном примере вполне можно обойтись и без комментария — достаточно переименовать функцию в . А вот другой , более уместный пример : Поиск по формату : : : , , . " \ \ : \ \ : \ \ \ \ , \ \ \ \ , \ \ " На этот раз комментарий сообщает , что регулярное выражение предназначено для идентификации времени и даты , отформатированных функцией . с заданной форматной строкой . И все же код стал бы лучше и понятнее , если бы мы переместили этот код в специальный класс , преобразующий форматы даты и времени . Тогда комментарий , вероятно , стал бы излишним . Представление намерений Иногда комментарий выходит за рамки полезной информации о реализации и описывает намерения , заложенные в решение . В следующем примере мы видим интересный пример архитектурного решения , документированного в комментарии . Автор решил , что при сравнении двух объектов объекты его класса должны находиться в порядке сортировки выше , чем объекты любого другого класса . . , " " . . , " " . Больше , потому что относится к правильному типу . Или другой , еще лучший пример . Возможно , вы не согласитесь с тем , как программист решает проблему , но по крайней мере вы знаете , что он пытается сделать . . " ' ' ' ' ' ' " , " ' ' ' ' ' ' " . Мы пытаемся спровоцировать " состояние гонки " , создавая большое количество программных потоков . , , , . , . Прояснение Иногда смысл загадочного аргумента или возвращаемого значения бывает удобно преобразовать в удобочитаемую форму . В общем случае лучше подумать , как сделать так , чтобы этот аргумент или возвращаемое значение говорили сами за себя но если они являются частью стандартной библиотеки или используются в коде , который вы не можете изменить , то пояснительный комментарий может быть весьма полезным . . " " . " . " . " " . " . " . " . " . " . " . . ! ! . . - . - . - . . . Конечно , при этом возникает существенный риск , что пояснительный комментарий окажется неверным . Просмотрите код примера и убедитесь , как трудно проверить его правильность . Это объясняет как необходимость пояснений , так и связанный с ними риск . Итак , прежде чем писать такие комментарии , убедитесь в том , что лучшего способа не существует , и еще внимательнее следите за их правильностью . Предупреждения о последствиях Картинка : _ . Иногда бывает полезно предупредить других программистов о нежелательных последствиях от каких - либо действий . Например , следующий комментарий объясняет , почему конкретный тестовый сценарий был отключен : Не запускайте , если только не располагаете излишками свободного времени . _ . . . " - : " , Конечно , в наше время тестовый сценарий следовало бы отключить при помощи атрибута @ с соответствующей пояснительной строкой : @ " Слишком долго выполняется " . Но до появления запись с начальным символом подчеркивания перед именем метода считалась стандартной . Комментарий , при всей его несерьезности , хорошо доносит свое сообщение до читателя . А вот другой , более выразительный пример : Класс не является потоково - безопасным , поэтому экземпляры должны создаваться независимо друг от друга . " , : : " . . " " Возможно , вы возразите , что у задачи есть и более удачные решения . Пожалуй , я соглашусь с вами . Однако комментарий в том виде , в котором он здесь приведен , выглядит абсолютно разумно . По крайней мере он помешает излишне ретивому программисту использовать статический инициализатор по соображениям эффективности . Комментарии Иногда бывает полезно оставить заметки «на будущее» в форме комментариев . В следующем примере комментарий объясняет , почему функция имеет вырожденную реализацию и что она должна делать в будущем . - На данный момент эта функция не используется . Ситуация изменится при переходе к отладочной модели . Комментарии напоминают о том , что , по мнению программиста , сделать необходимо , но по какой - то причине нельзя сделать прямо сейчас . Например , комментарий может напомнить о необходимости удаления устаревшей функции или предложить кому - то другому поучаствовать в решении проблемы — скажем , придумать более удачное имя или внести изменения , зависящие от запланированного события . Впрочем , чем бы ни был комментарий , это не повод оставлять плохой код в системе . В наши дни в любой хорошей рабочей среде имеется функция поиска всех комментариев , так что потеря таких комментариев маловероятна . И все же код не должен загромождаться лишними комментариями . Регулярно просматривайте их и удаляйте те , которые потеряли актуальность . Усиление Комментарий может подчеркивать важность обстоятельства , которое на первый взгляд кажется несущественным . . . Вызов очень важен . Он удаляет начальные пробелы , чтобы строка успешно интерпретировалась как список . , , . . . Комментарии в общедоступных С хорошо документированным общедоступным приятно и легко работать . Документация для стандартной библиотеки убедительно доказывает это утверждение . Безнее писать - программы было бы в лучшем случае непросто . Если вы разрабатываете для общего пользования , несомненно , для него следует написать хорошие комментарии . Однако не забывайте об остальных советах этой главы . Комментарии могут быть такими же и недостоверными и лживыми , как и любые другие комментарии . Плохие комментарии Большинство комментариев относится именно к этой категории . Обычно такие комментарии представляют собой «подпорки» для некачественного кода или оправдания сомнительных решений , а их текст напоминает рассуждения вслух самого программиста . Бормотание Не стоит лепить комментарии «на скорую руку» только потому , что вам кажется , что это уместно или этого требует процесс . Если уж вы решаете написать комментарий , не жалейте времени и напишите лучший из всех возможных комментариев . Например , следующий фрагмент я обнаружил в . В самом деле , комментарий здесь бы пригодился . Но автор то ли торопился , то ли не придал особого значения тому , что он пишет . Его бормотание оставляет читателя в недоумении : " " _ . Если нет файла свойств , загружаются настройки по умолчанию Что означает комментарий в блоке ? Очевидно , он что - то означал для автора , но для читателя этот смысл не доходит . Видимо , если мы получаем , это означает , что файл свойств отсутствует в этом случае должны загружаться все настройки по умолчанию . Но кто загружает эти настройки ? Были ли они загружены перед вызовом . ? Или вызов . перехватывает исключение , загружает настройки по умолчанию , а затем передает исключение нам , чтобы мы могли его проигнорировать ? Или . загружает настройки по умолчанию до того , как вы попытались загрузить файл ? Автор пытался успокоить себя относительно того факта , что он оставил блок пустым ? Или — и это самая пугающая возможность — автор хотел напомнить себе , что позднее нужно вернуться и написать код загрузки настроек по умолчанию ? Чтобы разобраться в происходящем , нам остается только изучить код других частей системы . Любой комментарий , смысл которого приходится искать в других модулях , не несет полезной информации и не стоит битов , затраченных на его написание . Избыточные комментарии В листинге . приведена простая функция с совершенно лишним заголовочным комментарием . Вероятно , чтение комментария займет больше времени , чем чтение самого кода . Листинг . . Вспомогательный метод возвращает управление , когда значение . истинно . Инициирует исключение при достижении тайм - аута . ! ! " " Какой цели достигает этот комментарий ? Конечно , он несет не больше информации , чем программный код . Он не объясняет код , не предоставляет обоснований и не раскрывает намерений . Он читается не проще , чем сам код . Более того , комментарий уступает коду в точности и навязывает читателю эту неточность взамен истинного понимания . Оннапоминает жуликоватого торговца подержанными машинами , уверяющего , что вам незачем заглядывать под капот . А теперь рассмотрим легион бесполезных , избыточных комментариев из листинга . , позаимствованных из . Эти комментарии только загромождают код и скрывают его смысл . Никакой пользы для документирования от них нет . Что еще хуже , я привел только несколько начальных комментариев — в этом модуле их намного больше . Листинг . . . , , , , Задержка процессора для этого компонента . - Поддержка событий жизненного цикла для этого компонента . Слушатели контейнерных событий для этого контейнера . Реализация загрузчика , связанная с контейнером . Реализация журнального компонента , связанная с контейнером . Имя журнального компонента . Реализация менеджера , связанная с контейнером . Кластер , связанный с контейнером . Удобочитаемое имя контейнера . Родительский контейнер , по отношению к которому данный контейнер является дочерним . Загрузчик родительского класса , задаваемый при назначении загрузчика . Объект , связанный с данным контейнером . Объект , связанный с контейнером . Объект ресурсов , связанный с контейнером Недостоверные комментарии Иногда с самыми лучшими намерениями программист делает в комментариях заявления , неточные и не соответствующие истине . Еще раз взгляните на совершенно лишний , но при этом слегка вводящий в заблуждение комментарий из листинга . . А вы нашли , в чем этот комментарий обманывает читателя ? Метод не возвращает управление , когдазначение . становится истинным . Он возвращает управление , если значение . истинно в противном случае метод ожидает истечения тайм - аута , а затем инициирует исключение , если значение . так и не стало истинным . Эта крошечная дезинформация в комментарии , который читается хуже , чем сам код , может заставить другого программиста вызвать функцию в предположении , что она вернет управление сразу же , как только значение . станет истинным . После этого бедный программист будет долго отлаживать программу , пытаясь понять , почему его код выполняется так медленно . Обязательные комментарии Правила , говорящие , что каждая функция должна иметь комментарий или что каждая переменная должна быть помечена комментарием , — обычная глупость . Такие комментарии только загромождают код , распространяют недостоверную информацию и вызывают общую путаницу и дезориентацию . Например , требование обязательного комментария для каждой функции приводит к появлению монстров вроде листинга . . Бессмысленные комментарии не приносят никакой пользы . Они только запутывают код , повышая риск обмана и недоразумений . Листинг . . @ Название диска @ Автор диска @ Количество дорожек на диске @ Продолжительность воспроизведения в минутах , , , . . . . . Журнальные комментарии Некоторые программисты добавляют комментарий в начало модуля при каждом его редактировании . Такие комментарии накапливаются , образуя своего рода журнал всех вносимых изменений . Я видел модули , в которых эти журнальные записи растягивались на десятки страниц . Изменения начиная с октября - - - - - - - - - - - - - - - - - - - - - - - - - - . . : Реорганизация класса и его перемещение в новый пакет . . . . : Добавление метода , устранение класса . . : С устранением класса требует включения метода исправление ошибок в методах , и . . : Исправление ошибки в классе . . : Перемещение констант месяцев в отдельный интерфейс . . : Исправление ошибки в методе с подачи ? ? ? . . : Исправление ошибок по сообщениям . . : Реализация . . : Исправление ошибки в методе . . : Реализация . Обновление . . : Исправление ошибки в методе Когда - то создание и сопровождение журнальных записей в начале каждого модуля было оправдано . У нас еще не было систем управления исходным кодом , которые делали это за нас . В наши дни длинные журналы только загромождают и усложняют код . Их следует полностью удалить из ваших программ . Шум Также в программах нередко встречаются комментарии , не содержащие ничего , кроме «шума» . Они лишь утверждают очевидное , не предоставляя никакой новой информации . Конструктор по умолчанию . Да неужели ? А как насчет этого : День месяца . И наконец , апофеоз избыточности : Возвращает день месяца . @ день месяца . Эти комментарии настолько бесполезны , что мы учимся не обращать на них внимания . В процессе чтения кода наш взгляд просто скользит мимо них . Рано или поздно код вокруг таких комментариев изменяется , и они начинают лгать . Первый комментарий в листинге . кажется уместным . Он объясняет , почему блок игнорируется . Но второй комментарий не несет полезной информации . Видимо , программист настолько вышел из себя при написании этих блоков в этой функции , что ему понадобилось «выпустить пар» . Листинг . . Нормально . Кто - то прервал запрос . . . . Ну хватит уже ! Вместо того чтобы давать выход чувствам в бесполезном комментарии , программисту следовало понять , что раздражение можно было снять улучшением структуры кода . Емустоило направить свою энергию на выделение последнего блока в отдельную функцию , как показано в листинге . . Листинг . . переработанная версия Нормально . Кто - то прервал запрос . . . . Искушение создать очередной «шумовой комментарий» следует заменить решимостью очистить код . Вы сами увидите , что это сделает вашу работу более приятной и эффективной . Опасный шум Комментарии тоже бывают «шумовыми» . Какую пользу приносят следующие комментарии из хорошо известной библиотеки , распространяемой с открытым кодом ? Ответ : никакой . Это избыточные шумовые комментарии , вызванные неуместным желанием как - то документировать свои действия . Имя . Версия . Название лицензии . Версия . Прочитайте эти комментарии повнимательнее . Заметили ошибку копирования вставки ? Если авторы не следят за ними в момент написания или вставки , то как можно ожидать , что эти комментарии принесут пользу читателю ? Не используйте комментарии там , где можно использовать функцию или переменную Возьмем следующий фрагмент кода : Зависит ли модуль из глобального списка от подсистемы , частью которой является наш код ? . . . Его можно было бы перефразировать без комментария в следующем виде : . . . Возможно хотя и маловероятно , автор исходного кода сначала написал комментарий , а затем — соответствующий ему код . Но после этого автор должен был переработать свой код , как это сделал я , чтобы комментарий можно было удалить . Позиционные маркеры Некоторые программисты любят отмечать определенные позиции в исходных файлах . Например , недавно я обнаружил в одной из просматриваемых программ следующую строку : Действия В отдельных случаях объединение функций под такими заголовками имеет смысл . Но в общем случае они составляют балласт , от которого следует избавиться — особенно от назойливой серии косых черт в конце . Взгляните на дело под таким углом : заголовки привлекают внимание только в том случае , если они встречаются не слишком часто . Используйте их умеренно и только тогда , когда они приносят ощутимую пользу . При слишком частом употреблении заголовков читатель воспринимает их как фоновый шум и перестает обращать на них внимание . Комментарии за закрывающей фигурной скобкой Иногда программисты размещают специальные комментарии за закрывающими фигурными скобками , как в листинге . . Применение таких комментариев оправдано в длинных функциях с многоуровневой вложенностью , но они только загромождают компактные специализированные функции , которым мы отдает предпочтение . Итак , если у вас возникает желание прокомментировать закрывающие фигурные скобки , лучше постарайтесь укоротить свои функции . Листинг . . . . . ! . . " \ \ " . . . " " . . " " . . " " . . " : " . Ссылки на авторов Добавлено Риком Системы контроля исходного кода отлично запоминают , кто и когда внес то или иное исправление . Нет необходимости загрязнять код подобными ссылками . Может показаться , что такие комментарии помогают другим определить , с кем следует обсуждать данный фрагмент кода . Однако в действительности эти комментарии остаются в коде на долгие годы и со временем становятся все менее точными и актуальными . И снова лучшим источником подобной информации является система контроля исходного кода . Закомментированный код В программировании редко встречаются привычки более отвратительные , чем закрытие комментариями неиспользуемого кода . Никогда не делайте этого ! . . , . . . . . У других программистов , видящих закомментированный код , не хватает храбрости удалить его . Они полагают , что код оставлен не зря и слишком важен для удаления . В итоге закомментированный код скапливается , словно осадок на дне бутылки плохого вина . Следующий код взят из общих модулей : . , . . , . . . Почему эти две строки кода закомментированы ? Они важны ? Их оставили как напоминание о будущих изменениях ? Или это «хлам» , который кто - то закомментировал сто лет назад и не удосужился убрать из программы ? В - е годы закомментированный код мог быть действительно полезен . Но с тех пор у нас давно появились хорошие системы контроля исходного кода . Эти системы запоминают изменения в коде за нас . Нам уже не нужно закрывать их комментариями . Просто удалите ненужный код . Он никуда не исчезнет . Честное слово . Комментарии Как видно из следующего фрагмента , в комментариях к исходному коду выглядит отвратительно . Он затрудняет чтение комментариев именно там , где они должны легко читаться — в редакторе . Если комментарии должны извлекаться внешним инструментом например , для отображения в веб - странице , то за украшение комментариев соответствующим кодом должен отвечать этот инструмент , а не программист . Задача для запуска тестов . Задача запускает тесты и публикует результаты . : - - . . . - - . $ . - . Нелокальная информация Если вы должны написать комментарий , проследите за тем , чтобы он описывал находящийся поблизости код . Не излагайте информацию системного уровня в контексте локального комментария . Примером служит приведенный ниже комментарий . Не считая того факта , что комментарий ужасающе избыточен , в него также включена информация о порте по умолчанию , притом что функция никоим образом не может управлять этим значением . И конечно , ничто не гарантирует , что комментарий будет изменен при изменениикода , в котором это значение определяется . Порт , на котором будет работать . По умолчанию . @ . Слишком много информации Не включайте в комментарии интересные исторические дискуссии или описания подробностей , не относящиеся к делу . Следующий комментарий был извлечен из модуля , который должен был проверять , что функция кодирует и декодирует данные в формате . Читателю кода совершенно не нужна заумная информация , содержащаяся в этом комментарии , — вполне достаточно номера . - Часть : Формат тел сообщений раздел . . Кодирование данных В процессе кодирования - разрядные группы входных битов представляются в виде выходных строк из закодированных символов . Слева направо - разрядная входная группа образуется посредством конкатенации - разрядных входных групп . Далее эти бита интерпретируются как конкатенированных - разрядных группы , каждая из которых преобразуется в одну цифру алфавита . При кодировании потока битов в кодировке предполагается , что битовый поток упорядочивается от старшего значащего бита . Иначе говоря , первым битом потока будет старший бит первого - битового байта , а восьмым - младший бит первого - битого байта и т . д . Неочевидные комментарии Связь между комментарием и кодом , который он описывает , должна быть очевидной . Если уж вы берете на себя хлопоты , связанные с написанием комментария , то по крайней мере читатель должен посмотреть на комментарий и на код и понять , о чем говорится в комментарии . Для примера возьмем следующий комментарий из общих модулей : Начать с массива , размер которого достаточен для хранения всех пикселов плюс байты фильтра , плюс еще байт для данных заголовка . . . Что такое «байты фильтра» ? Они как - то связаны с ? Или с ? И с тем и с другим ? Один пиксел соответствует одному байту ? И почему ? Цель комментария — объяснить код , который не объясняет сам себя . Плохо , когда сам комментарий нуждается в объяснениях . Заголовки функций Короткие функции не нуждаются в долгих описаниях . Хорошо выбранное имя компактной функции , которая выполняет одну операцию , обычно лучше заголовка с комментарием . Заголовки во внутреннем коде При всей полезности комментариев для общего пользования не применяйте их в коде , не предназначенном для общего потребления . Генерирование страниц для внутренних классов и функций системы обычно не приносит реальной пользы , а формализм комментариев только отвлекает читателя . Пример Модуль в листинге . был написан для первого учебного курса « » . Предполагалось , что он является примером плохого кодирования и стиля комментирования . Кент Бек переработал этот код в куда более приятную форму перед несколькими десятками увлеченных слушателей . Позднее я приспособил этот пример для своей книги « , , , » и статьи в журнале « » . Любопытно , что в то время многие из нас считали этот модуль «хорошо документированным» . Теперь мы видим , что он представляет собой ералаш . Посмотрим , сколько разных ошибок комментирования вам удастся найти . Листинг . . . Класс генерирует простые числа в диапазоне до максимального значения , заданного пользователем , по алгоритму " Решета Эратосфена " . Эратосфен Киренский , год до н . э . , Ливия - - год до н . э . , Александрия . Первый ученый , вычисливший длину земного меридиана . Известен своими работами о календарях с високосным годом , заведовал Александрийской библиотекой . Алгоритм весьма прост . Берем массив целых чисел , начиная с , и вычеркиваем из него все числа , кратные . Находим следующее невычеркнутое число и вычеркиваем все его кратные . Повторяем до тех пор , пока не дойдем до квадратного корня верхней границы диапазона . @ Альфонс @ февраля . . @ - верхняя граница диапазона . Единственно допустимый случай Объявления Размер массива Инициализировать массив значениями . Удалить числа , заведомо не являющиеся простыми . Отсев . Если элемент не вычеркнут , вычеркнуть кратные ему . Кратные числа не являются простыми . Сколько простых чисел осталось ? Приращение счетчика Переместить простые числа в результат , Если простое Вернуть простые числа Вернуть пустой массив при недопустимых входных данных . В листинге . приведена переработанная версия того же модуля . Обратите внимание : применение комментариев стало намного более ограниченным . Во всем модуле осталось всего два комментария пояснительного характера . Листинг . . . переработанная версия Класс генерирует простые числа до максимального значения , заданного пользователем , по алгоритму " Решета Эратосфена " . Берем массив целых чисел , начиная с , и вычеркиваем из него все числа , кратные . Находим следующее невычеркнутое число и вычеркиваем все числа , кратные ему . Повторяем до тех пор , пока из массива не будут вычеркнуты все кратные . . Каждое кратное в массиве имеет простой множитель , больший либо равный квадратному корню из размера массива . Следовательно , вычеркивать элементы , кратные числам , превышающих квадратный корень , не нужно . . . . , . . Можно возразить , что первый комментарий избыточен , потому что он практически полностью повторяет код самой функции . И все же я считаю , что этот комментарийупрощает понимание алгоритма пользователем , поэтому я склонен оставить его . Второй комментарий почти стопроцентно необходим . Он объясняет смысл использования квадратного корня как верхней границы цикла . Мне не удалось найти ни простого имени переменной , ни другой структуры кода , которые бы наглядно передавали это обстоятельство . С другой стороны , само использование квадратного корня может быть иллюзией . Действительно ли ограничение цикла квадратным корнем способно сэкономить время ? Не уйдет ли на его вычисление больше времени , чем я экономлю ? Об этом стоит подумать . Использование квадратного корня в качестве верхней границы цикла тешит мои наклонности старого хакера , работавшего на и ассемблере , но я не уверен , что оно оправдает время и усилия , необходимые читателям кода для его понимания . Литература : , , . . , - , . Глава . Форматирование Картинка : _ . Мы хотим , чтобы читатель , заглянувший «под капот» программы , был поражен увиденным — нашей аккуратностью , логичностью и вниманием к мелочам . Мы хотим , чтобы на него произвела впечатление стройность кода . Мы хотим , чтобы он уважительно поднял брови при просмотре модулей . Мы хотим , чтобы наша работа выглядела профессионально . Если вместо этого читатель видит беспорядочную массу кода , словно написанного шайкой пьяных матросов , то он заключит , что такое же неуважение к мелочам проникло и вовсе остальные аспекты проекта . Вы должны позаботиться о том , чтобы ваш код был хорошо отформатирован . Выберите набор простых правил , определяющих формат кода , и последовательно применяйте их в своей работе . Если вы работаете в составе группы , то группа должна выработать согласованный набор правил форматирования , соблюдаемых всеми участниками . Также полезно иметь средства автоматизации , которые применяют правила форматирования за вас . Цель форматирования Прежде всего я твердо заявляю : форматирование кода важно . Оно слишком важно , чтобы не обращать на него внимания , и слишком важно , чтобы относиться к нему с религиозным пылом . Форматирование кода направлено на передачу информации , а передача информации является первоочередной задачей профессионального разработчика . Возможно , вы думали , что первоочередная задача профессионального разработчика – «сделать так , чтобы программа заработала» . Надеюсь , к этому моменту книга уже заставила вас отказаться от этих представлений . Функциональность , созданная сегодня , вполне может измениться в следующей версии , но удобочитаемость вашего кода окажет сильное воздействие на все изменения , которые когда - либо будут внесены . Стиль кодирования и удобочитаемость создают прецеденты , которые продолжают влиять на сопровождаемость и расширяемость кода уже после того , как исходный код изменился до неузнаваемости . Стиль и дисциплина программирования продолжают жить , даже если ваш код остался в прошлом . Так какие же аспекты форматирования помогают нам лучше передать свои мысли ? Вертикальное форматирование Начнем с вертикальных размеров . Насколько большим должен быть исходный файл ? В размер файла тесно связан с размером класса . Мы поговорим о размерах классов , когда речь пойдет о классах , а пока давайте займемся размером файлов . Насколько большими должны быть исходные файлы ? Оказывается , существует широчайший диапазон размеров и весьма заметные различия в стиле . Некоторые из этих различий показаны на рис . . . На рисунке изображены семь разных проектов : , , , , , и . Отрезки , проходящие через прямоугольники , показывают минимальную и максимальную длину файла в каждом проекте . Прямоугольник изображает приблизительно одну треть стандартное отклонение от диапазона длин файлов . Середина прямоугольника соответствует среднему арифметическому . Таким образом , средний размер файла в проекте составляет около строк , а около трети файлов имеет размер от до строк . Наибольший файл занимает около строк , а наименьший — всего строк . Обратите внимание : на графике используется логарифмическая шкала , поэтому незначительные изменения в вертикальной координате подразумевают очень большие изменения в абсолютном размере . Картинка : _ . Рис . . . Распределение длин файлов по логарифмической шкале высота прямоугольника сигма , и состоят из относительно небольших файлов . Ни один размер файла не превышает строк , а большинство файлов не превышает строк . Напротив , в и встречаются файлы из нескольких тысяч строк , а около половины имеет длину более строк . Что это означает для нас ? То , что достаточно серьезную систему объем приближается к строк можно построить из файлов , типичная длина которых составляет строк , с верхним пределом в строк . Хотя это не должно считаться раз и навсегда установленным правилом , такие показатели весьма желательны . Маленькие файлы обычно более понятны , чем большие . Газетная метафора Представьте себе хорошо написанную газетную статью . Естественно , статья читается по вертикали . В самом начале обычно располагается заголовок с общей темой статьи он помогает вам решить , представляет ли статья интерес для вас . В первом абзаце приводится краткое изложение сюжета на уровне общих концепций , без приведения каких - либо подробностей . По мере продвижения к концу статьи объем детализации непрерывно растет , пока вы не узнаете все даты , имена , цитаты и т . д . Исходный файл должен выглядеть как газетная статья . Имя файла должно быть простым , но содержательным . Одного имени должно быть достаточно для того , чтобы читатель понял , открыл ли он нужный модуль или нет . Начальные блоки исходного файла описывают высокоуровневые концепции и алгоритмы . Степень детализации увеличивается при перемещении к концу файла , а в самом конце собираются все функции и подробности низшего уровня в исходном файле . Газета состоит из множества статей , в большинстве своем очень коротких . Другие статьи чуть длиннее . И лишь немногие статьи занимают всю газетную страницу . Собственно , именно этим газеты так удобны . Если бы они состояли из одной длинной статьи с неупорядоченной подборкой фактов , дат и имен , то мы бы просто не смогли их читать . Вертикальное разделение концепций Практически весь код читается слева направо и сверху вниз . Каждая строка представляет выражение или условие , а каждая группа строк представляет законченную мысль . Эти мысли следует отделять друг от друга пустыми строками . Для примера возьмем листинг . . Объявление пакета , директива - ы импорта и все функции разделяются пустыми строками . Это чрезвычайно простое правило оказывает глубокое воздействие на визуальную структуру кода . Каждая пустая строка становится зрительной подсказкой , указывающей на начало новой самостоятельной концепции . В ходе просмотра листинга ваш взгляд привлекает первая строка , следующая за пустой строкой . Листинг . . . . . . . . " ' ' ' . ? ' ' ' " . " ' ' ' . ? ' ' ' " , . . , . . . Листинг . продолжение " " . . " " . Удаление пустых строк , как в листинге . , имеет весьма тяжелые последствия для удобочитаемости кода . Листинг . . . . . . . . " ' ' ' . ? ' ' ' " . " ' ' ' . ? ' ' ' " , . . , . . . " " . . " " . Эффект становится еще более заметным , если на секунду отвести глаза от листинга . В первом примере группировка строк сразу бросается в глаза , а второй пример выглядит как сплошная каша , притом что два листинга различаются только вертикальными разделителями . Вертикальное сжатие Если вертикальные пропуски разделяют концепции , то вертикальное сжатие подчеркивает тесные связи . Таким образом , строки кода , между которыми существует тесная связь , должны быть «сжаты» по вертикали . Обратите внимание на то , как бесполезные комментарии в листинге . нарушают группировку двух переменных экземпляров . Листинг . Имя класса слушателя _ Свойства слушателя _ _ . Листинг . читается гораздо проще . Он нормально воспринимается «с одного взгляда» — по крайней мере , для меня . Я смотрю на него и сразу вижу , что передо мной класс с двумя переменными и одним методом для этого мне не приходится вертеть головой или бегать по строчкам глазами . В предыдущем листинге для достижения того же уровня понимания приходится потрудиться намного больше . Листинг . _ _ _ . Вертикальные расстояния Вам когда - нибудь доводилось метаться по классу , прыгая от одной функции к другой , прокручивая исходный файл вверх - вниз , пытаясь разобраться , как функции связаны друг с другом и как они работают , — только для того , чтобы окончательно заблудиться в его запутанных нагромождениях ? Когда - нибудь искали определение функции или переменной по цепочкам наследования ? Все это крайне неприятно , потому что вы стараетесь понять , как работает система , а вместо этого вам приходится тратить время и интеллектуальные усилия на поиски и запоминание местонахождения отдельных фрагментов . Концепции , тесно связанные друг с другом , должны находиться поблизости друг от друга по вертикали . Разумеется , это правило не работает для концепций , находящихся в разных файлах . Но тесно связанные концепции и не должны находиться в разных файлах , если только это не объясняется очень вескими доводами . Кстати , это одна из причин , по которой следует избегать защищенных переменных . Если концепции связаны настолько тесно , что они находятся в одном исходном файле , их вертикальное разделение должно показывать , насколько они важны для понимания друг друга . Не заставляйте читателя прыгать туда - сюда по исходным файлам и классам . Объявления переменных . Переменные следует объявлять как можно ближе к месту использования . Так как мы имеем дело с очень короткими функциями , локальные переменные должны перечисляться в начале каждой функции , как в следующем примере из . . . ! . Управляющие переменные циклов обычно объявляются внутри конструкции цикла , как в следующей симпатичной маленькой функции из того же источника . : . В отдельных случаях переменная может объявляться в начале блока или непосредственно перед циклом в длинной функции . Пример такого объявления представлен в следующем фрагменте очень длинной функции из . … : _ . _ . , . _ _ . . : . . . , : . . . , … Переменные экземпляров , напротив , должны объявляться в начале класса . Это не увеличивает вертикальное расстояние между переменными , потому что в хорошо спроектированном классе они используются многими , если не всеми , методами класса . Размещение переменных экземпляров становилось причиной ожесточенных споров . В обычно применялось так называемоеправило ножниц , при котором все переменные экземпляров размещаются внизу . С другой стороны , в они обычно размещаются в начале класса . Я не вижу причин для использования каких - либо других конвенций . Здесь важно то , что переменные экземпляров должны объявляться в одном хорошо известном месте . Все должны знать , где следует искать объявления . Для примера рассмотрим странный класс из . . . Я основательно сократил этот класс , чтобы лучше выразить свою мысль . Где - то в середине листинга вдруг обнаруживаются объявления двух переменных экземпляров . Если бы автор сознательно хотел спрятать их , трудно найти более подходящее место . Читатель кода может наткнуться на эти объявления только случайно как я . ? , … ? ? … … … ? … ? , … … … … … … Зависимые функции . Если одна функция вызывает другую , то эти функции должны располагаться вблизи друг от друга по вертикали , а вызывающая функция должна находиться над вызываемой если это возможно . Тем самым формируется естественная структура программного кода . Если это правило будет последовательно соблюдаться , читатели кода будут увереныв том , что определения функций следуют неподалеку от их вызовов . Для примера возьмем фрагмент из листинга . . Обратите внимание на то , как верхняя функция вызывает нижние , и как они , в свою очередь , вызывают функцииболее низкого уровня . Такая структура позволяет легко найти вызываемые функции и значительно улучшает удобочитаемость всего модуля . Листинг . . . , , " " , , , . . , . . . . . . , ! . , . , . . . . … Заодно этот фрагмент дает хороший пример хранения констант на соответствующем уровне . Константу « » можно было бы объявить в функции , но тогда хорошо известная и ожидаемая константа оказалась бы погребенной в функции неуместно низкого уровня . Лучше переместить эту константу вниз – от того места , где ее следовало бы ввести , к месту ее фактического использования . Концептуальное родство . Некоторые фрагменты кодатребуют , чтобы их разместили вблизи от других фрагментов . Такие фрагменты обладают определенным концептуальным родством . Чем сильнее родство , тем меньше должно быть вертикальное расстояние между ними . Картинка : _ . Как мы уже видели , родство может быть основано на прямой зависимости когда одна функция вызывает другую или на использовании переменных в функциях . Однако существуют и другие разновидности родства . Например , родство возникает в том случае , если группа функций выполняет аналогичные операции . Возьмем следующий фрагмент кода из . . : , ! , , , ! , … Эти функции обладают сильным концептуальным родством , потому что они используют единую схему выбора имен и выполняют разные варианты одной базовой операции . Тот факт , что они вызывают друг друга , вторичен . Даже без него эти функции все равно следовало бы разместить поблизости друг от друга . Вертикальное упорядочение Как правило , взаимозависимые функции должны размещаться в нисходящем порядке . Иначе говоря , вызываемая функция должна располагаться ниже вызывающей функции . Так формируется логичная структура модуля исходного кода – от высокого уровня к более низкому . Как и в газетных статьях , читатель ожидает , что самые важные концепции будут изложены сначала , причем с минимальным количеством второстепенных деталей . Низкоуровневые подробности естественно приводить в последнюю очередь . Это позволяет нам бегло просматривать исходные файлы , извлекая суть из нескольких начальных функций , без погружения в подробности . Листинг . имеет именно такую структуру . Возможно , еще лучшие примеры встречаются в листинге . на с . и в листинге . на с . . Горизонтальное форматирование Насколько широкой должна быть строка ? Чтобы ответить на этот вопрос , мы проанализируем ширину строк в типичных программах . Как и в предыдущем случае , будут проанализированы семь разных проектов . На рис . . показано распределение длин строк во всех семи проектах . Закономерность впечатляет , особенно около символов . Фактическикаждый размер от до соответствует примерно одному проценту от общего количества строк . Целых процентов ! Возможно , еще процентов составляют строки с длиной менее символов . Помните , что на графике используется логарифмическая шкала , поэтому разброс в области свыше символов очень важен . Программисты явно предпочитают более короткие строки . Это наводит на мысль , что строки лучше делать по возможности короткими . Установленное Холлеритом старое ограничение в символов выглядит излишне жестким я ничего не имеют против строк длиной в и даже символов . Но более длинные строки , вероятно , вызваны небрежностью программиста . Картинка : _ . Рис . . . Распределение ширины строк в Прежде я использовал это правило , чтобы мне не приходилось прокручивать программный код вправо . Но современные мониторы стали настолько широкими , а молодые программисты выбирают настолько мелкие шрифты , что на экране помещается до символов . Не делайте этого . Лично я установил себе «верхнюю планку» в символов . Горизонтальное разделение и сжатие Горизонтальные пропуски используются для группировки взаимосвязанных элементов и разделения разнородных элементов . Рассмотрим следующую функцию : . . , Знаки присваивания окружены пробелами , обеспечивающими их визуальное выделение . Операторы присваивания состоят из двух основных элементов : левой и правой частей . Пробелы наглядно подчеркивают это разделение . С другой стороны , я не стал отделять имена функций от открывающих скобок . Это обусловлено тем , что имя функции тесно связано с ее аргументами . Пробелы изолируют их вместо того , чтобы объединять . Я также разделил аргументы в скобках пробелами , чтобы выделить запятые и подчеркнуть , что аргументы не зависят друг от друга . Пробелы также применяются для визуального обозначения приоритета операторов : , , , , - . , , , , - - . , , - Обратите внимание , как хорошо читаются формулы . Между множителями нет пробелов , потому что они обладают высоким приоритетом . Слагаемые разделяются пробелами , так как сложение и вычитание имеют более низкий приоритет . К сожалению , в большинстве программ форматирования кода приоритет операторов не учитывается , и во всех случаях применяются одинаковые пропуски . Нетривиальные изменения расстояний , как в приведенном примере , теряются после переформатирования кода . Горизонтальное выравнивание Когда я был ассемблерным программистом , горизонтальное выравнивание использовалось для визуального выделения некоторых структур . Когда я перешел на , , а в конце концов и на , я продолжал выравниватьвсе имена переменных в группах объявлений или все правосторонние значения в группах команд присваивания . Мой код выглядел примерно так : , . . . Однако потом я обнаружил , что такое выравнивание не приносит пользы . Оно визуально выделяет совсем не то , что требуется , и отвлекает читателя от моих истинных намерений . Например , в приведенном выше списке объявлений читатель просматривает имена переменных , не обращая внимания на их типы . Аналогичным образом в списке команд присваивания возникает соблазн просмотреть правосторонние значения , не замечая оператора присваивания . Ситуация усугубляется тем , что средства автоматического форматирования обычно удаляют подобное выравнивание . Поэтому в итоге я отказался от этого стиля форматирования . Сейчас я отдаю предпочтение невыровненным объявлениям и присваиваниям , как в следующем фрагменте , потому что они помогают выявить один важный дефект . Если в программе встречаются длинные списки , нуждающиеся в выравнивании , то проблема кроется в длине списка , а не в отсутствии выравнивания . Длина списков объявлений в классе наводит на мысль , что этот класс необходимо разделить . , . . . Отступы Исходный файл имеет иерархическую структуру . В нем присутствует информация , относящаяся к файлу в целом к отдельным классам в файле к методам внутри классов к блокам внутри методов и рекурсивно – к блокам внутри блоков . Каждый уровень этой иерархии образует область видимости , в которой могут объявляться имена и в которой интерпретируются исполняемые команды . Чтобы создать наглядное представление этой иерархии , мы снабжаем строки исходного кода отступами , размер которых соответствует их позиции в иерархии . Команды уровня файла такие , как большинство объявлений классов отступов не имеют . Методы в классах сдвигаются на один уровень вправо от уровня класса . Реализации этих методов сдвигаются на один уровень вправо от объявления класса . Реализации блоков сдвигаются на один уровень вправо от своих внишних блоков и т . д . Программисты широко используют эту схему расстановки отступов в своей работе . Чтобы определить , к какой области видимости принадлежат строки кода , они визуально группируют строки по левому краю . Это позволяет им быстро пропускать области видимости , не относящиеся к текущей ситуации например , реализации команд и . У левого края ищутся объявления новых методов , новые переменные и даже новые классы . Без отступов программа становится практически нечитаемой для людей . Следующие программы идентичны с синтаксической и семантической точки зрения : . , , , . . . - - - - - . , , , . . . Наше зрение быстро охватывает структуру файла с отступами . Мы почти мгновенно находим переменные , конструкторы и методы . Всего за несколько секунд можно понять , что класс предоставляет простой интерфейс для работы с сокетом , с поддержкой тайм - аута . С другой стороны , разобраться в версии без отступов без тщательного анализа практически невозможно . Нарушения отступов . Иногда возникает соблазн нарушить правила расстановки отступов в коротких командах , коротких циклах или коротких функциях . Но каждый раз , когда я поддавался этому искушению , я почти всегда возвращался и расставлял отступы , как положено . Таким образом , я стараюсь не сворачивать блоки в одну строку , как в этом фрагменте : " ^ # ^ \ \ ? : ? : \ \ | \ | \ ? " , , " " Вместо этого я предпочитаю развернутые блоки с правильными отступами : " ^ # ^ \ \ ? : ? : \ \ | \ | \ ? " , , " " Вырожденные области видимости Иногда тело цикла или команды не содержит команд , то есть является вырожденным , как в следующем фрагменте . Я не люблю такие структуры и стараюсь избегать их . А когда это невозможно , я по крайней мере слежу за тем , чтобы пустое тело имело правильные отступы и было заключено в фигурные скобки . Вы не представляете , как часто меня обманывала точка с запятой , молчаливо прячущаяся в конце цикла в той же строке . Если не сделать эту точку хорошо заметной , разместив ее в отдельной строке , ее попросту слишком сложно разглядеть : . , , ! - Правила форматирования в группах Картинка : _ . У каждого программиста есть свои любимые правила форматирования , но если он работает в группе , то должен руководствоваться групповыми правилами . Группа разработчиков согласует единый стиль форматирования , который в дальнейшем применяется всеми участниками . Код программного продукта должен быть оформлен в едином стиле . Он не должен выглядеть так , словно был написан несколькими личностями , расходящимися во мнениях по поводу оформления . В начале работы над проектом в году я провел встречу с группой для выработки общего стиля программирования . На это потребовалось около минут . Мы решили , где будем расставлять фигурные скобки , каким будет размер отступов , по какой схеме будут присваиваться имена классов , переменных и методов и т . д . Затем эти правила были закодированы в системе форматирования кода нашей рабочей среды , и в дальнейшем мы неуклонно придерживались их . Это были не те правила , которые предпочитаю лично я это были правила , выбранные группой . И я , как участник группы , неуклонно соблюдал их при написании кода в проекте . Хорошая программная система состоит из набора удобочитаемых документов , оформленных в едином , согласованном стиле . Читатель должен быть уверен в том , что форматные атрибуты , встречающиеся в одном исходном файле , будут иметь точно такой же смысл в других файлах . Ни в коем случае не усложняйте исходный код , допуская его оформление в нескольких разных стилях . Правила форматирования от дядюшки Боба Правила , которые использую лично я , очень просты они представлены в коде листинга . . Перед вами пример того , как сам код становится лучшим документом , описывающим стандарты кодирования . Листинг . . . , , : . . . " . " . . , . ! . . , Листинг . продолжение : " " . . . . . Глава . Объекты и структуры данных Картинка : _ . Существует веская причина для ограничения доступа к переменным в программах : мы не хотим , чтобы другие программисты зависели от них . Мы хотим иметь возможность свободно менять тип или реализацию этих переменных так , как считаем нужным . Тогда почему же многие программисты автоматически включают в свои объекты методы чтения записи , предоставляя доступ к приватным переменным так , словно они являются открытыми ? Абстракция данных Давайте сравним между собой листинги . и . . В обоих случаях код представляет точку на декартовой плоскости . Однако в одном случае реализация открыта , а в другом она полностью скрыта от внешнего пользователя . Листинг . . Конкретная реализация Листинг . . Абстрактная реализация , , Элегантность решения из листинга . заключается в том , что внешний пользователь не знает , какие координаты использованы в реализации — прямоугольные или полярные . А может , еще какие - нибудь ! Тем не менее интерфейс безусловно напоминает структуру данных . Однако он представляет нечто большее , чем обычную структуру данных . Его методы устанавливают политику доступа к данным . Пользователь может читать значения координат независимо друг от друга , но присваивание координат должно выполняться одновременно , в режиме атомарной операции . С другой стороны , листинг . явно реализован в прямоугольных координатах , а пользователь вынужден работать с этими координатами независимо . Более того , такое решение раскрывает реализацию даже в том случае , если бы переменные были объявлены приватными , и мы использовали одиночные методы чтения записи . Скрытие реализации не сводится к созданию прослойки функций между переменными . Скрытие реализации направлено на формирование абстракций ! Класс не просто ограничивает доступ к переменным через методы чтения записи . Вместо этого он предоставляет абстрактные интерфейсы , посредством которых пользователь оперирует ссущностьюданных . Знать , как эти данные реализованы , ему при этом не обязательно . Возьмем листинги . и . . В первом случае для получения информации о запасе топлива используются конкретные физические показатели , а во втором — абстрактные проценты . В первом , конкретном случае можно быть уверенным в том , что методы представляют собой обычные методы доступа к переменным . Во втором , абстрактном случае пользователь не имеет ни малейшего представления о фактическом формате данных . Листинг . . Конкретная реализация Листинг . . Абстрактная реализация В обоих примерах вторая реализация является предпочтительной . Мы не хотим раскрывать подробности строения данных . Вместо этого желательно использовать представление данных на абстрактном уровне . Задача не решается простым использованием интерфейсов и или методов чтения записи . Чтобы найти лучший способ представления данных , содержащихся в объекте , необходимо серьезно поразмыслить . Бездумное добавление методов чтения и записи — худший из всех возможных вариантов . Антисимметрия данных объектов Два предыдущих примера показывают , чем объекты отличаются от структур данных . Объекты скрывают свои данные за абстракциями и предоставляют функции , работающие с этими данными . Структуры данных раскрывают свои данные и не имеют осмысленных функций . А теперь еще раз перечитайте эти определения . Обратите внимание на то , как они дополняют друг друга , фактически являясь противоположностями . Различия могут показаться тривиальными , но они приводят к далеко идущим последствиям . Возьмем процедурный пример из листинга . . Класс работает с тремя классами геометрических фигур . Классы фигур представляют собой простые структуры данных , лишенные какого - либо поведения . Все поведение сосредоточено в классе . Листинг . . Процедурные фигуры Листинг . продолжение . . . . . . . Объектно - ориентированный программист недовольно поморщится и пожалуется на процедурную природу реализации — и будет прав . Но возможно , его презрительная усмешка не обоснована . Подумайте , что произойдет при включении в функции . Классы фигур остаются неизменными ! И все остальные классы , зависящие от них , тоже остаются неизменными ! С другой стороны , при добавлении новой разновидности фигур мне придется изменять все функции , чтобы они могли работать с ней . Перечитайте ещераз . Обратите внимание на то , что эти два условия диаметрально противоположны . Теперь рассмотрим объектно - ориентированное решение из листинга . . Метод является полиморфным , класс становится лишним . Добавление новой фигуры не затрагивает ни одну из существующихфункций , но при добавлении новой функции приходится изменять всефигуры ! Листинг . . Полиморфные фигуры . И снова мы наблюдаем взаимодополняющую природу этих двух определений . В этом проявляется основополагающая дихотомия между объектами и структурами данных . Процедурный код код , использующий структуры данных позволяет легко добавлять новые функции без изменения существующих структур данных . Объектно - ориентированный код , напротив , упрощает добавление новых классов без изменения существующих функций . Обратные утверждения также истинны . Процедурный код усложняет добавление новых структур данных , потому что оно требует изменения всех функций . Объектно - ориентированный код усложняет добавление новых функций , потому что для этого должны измениться все классы . Таким образом , то , что сложно в ОО , просто в процедурном программировании , а то , что сложно в процедурном программировании , просто в ОО ! В любой сложной системе возникают ситуации , когда вместо новых функций в систему требуется включить новые типы данных . Для таких ситуаций объекты и объектно - ориентированное программирование особенно уместны . Впрочем , бывает и обратное — вместо новых типов данных требуется добавить новые функции . Тогда лучше подходит процедурный код и структуры данных . Опытные программисты хорошо знают : представление о том , что все данные должны представляться в виде объектов —миф . Иногда предпочтительны простые структуры данных и процедуры , работающие с ними . Закон Деметры Хорошо известное эвристическое правило , называемоезаконом Деметры , гласит , что модуль не должен знать внутреннее устройство тех объектов , с которыми он работает . Как мы видели в предыдущем разделе , объекты скрывают свои данные и предоставляют операции для работы с ними . Это означает , что объект не должен раскрывать свою внутреннюю структуру через методы доступа , потому что внутреннюю структуру следует скрывать . В более точной формулировке закон Деметры гласит , что метод класса должен ограничиваться вызовом методов следующих объектов : • • объекты , созданные • объекты , переданные в качестве аргумента • объекты , хранящиеся в переменной экземпляра . Методне долженвызывать методы объектов , возвращаемых любыми из разрешенных функций . Другими словами , разговаривать можно с друзьями , но не с чужаками . Следующий код нарушает закон Деметры среди прочего , потому что он вызывает функцию для возвращаемого значения , а затем вызывает для возвращаемого значения . . . . Крушение поезда Подобная структура кода часто называется «крушением поезда» , потому что цепочки вызовов напоминают сцепленные вагоны поезда . Такие конструкции считаются проявлением небрежного стиля программирования и их следует избегать . Обычно цепочки лучше разделить в следующем виде : . . . Картинка : _ . Нарушают ли эти два фрагмента закон Деметры ? Несомненно , вмещающий модуль знает , что объект контекста содержит значения параметров , в число которых входит и временный каталог , обладающий абсолютным путем . Это довольно большой объем информации для одной функции . Вызывающая функция должна знать , как перемещаться между множеством разных объектов . Нарушает ли этот код закон Деметры или нет ? Все зависит от того , чем являются , и — объектами или структурами данных . Если это объекты , то их внутренняя структура должна скрываться , поэтому необходимость информации об их строении является явным нарушением закона Деметры . С другой стороны , если , и представляют собой обычные структуры данных , не обладающие поведением , то они естественным образом раскрывают свою внутреннюю структуру , а закон Деметры на них не распространяется . Применение функций доступа затрудняет ситуацию . Если бы код был записан следующим образом , вероятно , у нас не возникало бы вопросов по поводу нарушения закона Деметры : . . . Ситуация существенно упростилась бы , если бы структуры данных просто содержали открытые переменные без функций , а объекты — приватные переменные с открытыми функциями . Однако некоторые существующие инфраструктуры и стандарты например , требуют , чтобы даже простые структуры данных имели методы чтения и записи . Гибриды Вся эта неразбериха иногда приводит к появлению гибридных структур — наполовину объектов , наполовину структур данных . Гибриды содержат как функции для выполнения важных операций , так и открытые переменные или открытые методы чтения записи , которые во всех отношениях делают приватные переменные открытыми . Другим внешним функциям предлагается использовать эти переменные так , как в процедурных программах используются структуры данных . Подобные гибриды усложняют как добавление новых функций , так и новых структур данных . Они объединяют все худшее из обеих категорий . Не используйте гибриды . Они являются признаком сумбурного проектирования , авторы которого не уверены или еще хуже , не знают , что они собираются защищать : функции или типы . Скрытие структуры А если , и представляют собой объекты с реальным поведением ? Поскольку объекты должны скрывать свою внутреннюю структуру , мы не сможем перемещаться между ними . Как же в этом случае узнать абсолютный путь временного каталога ? . или . . Первый вариант приведет к разрастанию набора методов объекта . Второй вариант предполагает , что возвращает структуру данных , а не объект . Ни один из вариантов не вызывает энтузиазма . Если является объектом , то мы должны приказать ему выполнить некую операцию , а не запрашивать у него информацию о его внутреннем устройстве . Зачем нам понадобился абсолютный путь к временному каталогу ? Что мы собираемся с ним делать ? Рассмотрим следующий фрагмент того же модуля расположенный на много строк ниже : " " . ' . ' , ' ' " . " Смешение разных уровней детализации выглядит немного пугающе . Точки , косые черты , расширения файлов и объекты не должны так беспечно перемешиваться междусобой и с окружающим кодом . Но если не обращать на это внимания , мы видим , что абсолютный путь временного каталога определялся для создания временного файла с заданным именем . Так почему бы не приказать объекту выполнить эту операцию ? . Выглядит вполне разумно ! Такое решение позволяет объекту скрыть свое внутреннее строение , а текущей функции не приходится нарушать закон Деметры , перемещаясь между объектами , о которых ей знать не положено . Объекты передачи данных Квинтэссенцией структуры данных является класс с открытыми переменными и без функций . Иногда такие структуры называютсяобъектами передачи данных , или . Структуры чрезвычайно полезны , особенно при работе с базами данных , разборе сообщений из сокетов и т . д . С них часто начинается серия фаз преобразования низкоуровневых данных , полученных из базы , в объекты кода приложения . Несколько большее распространение получила форма - компонентов , представленная в листинге . . - компоненты состоят из приватных переменных , операции с которымиосуществляются при помощи методов чтения записи . Подобная форма псевдоинкапсуляции поднимает настроение некоторым блюстителям чистоты ОО , но обычно не имеет других преимуществ . Листинг . . . , , , , . . . . . Активные записи Активные записи составляют особую разновидность . Они тоже представляют собой структуры данных с открытыми переменными или переменными с - доступом , но обычно в них присутствуют навигационные методы — такие , как или . Активные записи чаще всего являются результатами прямого преобразования таблиц баз данных или других источников данных . К сожалению , разработчики часто пытаются интерпретировать такие структуры данных , как объекты , и включают в них методы , реализующие бизнес - логику . Однако такой подход нежелателен , так как он создает гибрид между структурой данных и объектом . Конечно , проблема решается иначе : активные записи интерпретируются как структуры данных , а в программе создаются отдельные объекты , которые содержат бизнес - логику и скрывают свои внутренние данные которые , возможно , представляют собой обычные экземпляры класса активной записи . Заключение Объекты предоставляют поведение и скрывают данные . Это позволяет программисту легко добавлять новые виды объектов , не изменяя существующего поведения . С другой стороны , объекты усложняют добавление нового поведения к существующим объектам . Структуры данных предоставляют данные , но не обладают сколько - нибудь значительным поведением . Они упрощают добавление нового поведения в существующие структуры данных , но затрудняют добавление новых структур данных в существующие функции . Если в некоторой системе нас прежде всего интересует гибкость в добавлении новых типов данных , то в этой части системы предпочтение отдается объектной реализации . В других случаях нам нужна гибкость расширения поведения , и тогда в этой части используются типы данных и процедуры . Хороший программист относится к этой проблеме без предубеждения и выбирает то решение , которое лучше всего подходит для конкретной ситуации . Литература : : , . , - , . Глава . Обработка ошибок Майкл Физерс Картинка : _ . На первый взгляд глава , посвященная обработке ошибок , в книге о чистом коде выглядит немного странно . Обработка ошибок — одна из тех рутинных вещей , которыми нам всем приходится заниматься при программировании . Программа может получить аномальные входные данные , на устройстве могут произойти сбои . Короче говоря , выполнение программы может пойти по неверному пути , и если это случается , мы , программисты , должны позаботиться , чтобы наш код сделал то , что ему положено сделать . Однако связь этих двух тем — обработки ошибок и чистого кода — очевидна . Во многих кодовых базах обработка ошибок выходит на первый план . Я вовсе не хочу сказать , что код не делает ничего полезного , кроме обработки ошибок я имею в виду , что из - за разбросанной повсюду обработки ошибок практически невозможно понять , что же делает код . Обработка ошибок важна , но если они заслоняют собой логику программы — значит , она реализована неверно . В этой главе представлены некоторые соображения и приемы , которые помогают писать чистый и надежный код , то есть код , в котором ошибки обрабатываются стильно и элегантно . Используйте исключения вместо кодов ошибок В далеком прошлом многие языки программирования не поддерживали механизма обработки исключений . В таких языках возможности обработки и получения информации об ошибках были ограничены . Программа либо устанавливала флаг ошибки , либо возвращала код , который проверялся вызывающей стороной . Оба способа продемонстрированы в листинге . . Листинг . . . … Проверить состояние устройства ! . Сохранить состояние устройства в поле записи Если устройство не приостановлено , отключить его . ! _ . " . " . " : " . … У обоих решений имеется общий недостаток : они загромождают код на стороне вызова . Вызывающая сторона должна проверять ошибки немедленно после вызова . К сожалению , об этом легко забыть . По этой причине при обнаружении ошибки лучше инициировать исключение . Код вызова становится более понятным , а его логика не скрывается за кодом обработки ошибок . В листинге . представлен тот же код с выдачей исключений в методах , способных обнаруживать ошибки . Обратите внимание , насколько чище стал код . Причем дело даже не в эстетике . Качество кода возросло , потому что два аспекта , которые прежде были тесно переплетены — алгоритм отключения устройства и обработка ошибок , — теперь изолированы друг от друга . Вы можете рассмотреть их по отдельности и разобраться в каждом из них независимо . Листинг . . . с исключениями … . … " : " . … … Начните с написания команды - - У исключений есть одна интересная особенность : они определяют область видимости в вашей программе . Размещая код в секции команды - - , вы утверждаете , что выполнение программы может прерваться в любой точке , а затем продолжиться в секции . Блоки в каком - то отношении напоминают транзакции . Секция должна оставить программу в целостном состоянии , что бы и произошло в секции . По этой причине написание кода , который может инициировать исключения , рекомендуется начинать с конструкции - - . Это поможет вам определить , чего должен ожидать пользователь кода , что бы ни произошло в коде . Допустим , требуется написать код , который открывает файл и читает из него сериализованные объекты . Начнем с модульного теста , который проверяет , что при неудачном обращении к файлу будет выдано исключение : @ . . " - " Для теста необходимо создать следующую программную заглушку : Пусто , пока не появится реальная реализация Тест завершается неудачей , потому что код не инициирует исключения . Затем мы изменяем свою реализацию так , чтобы она попыталась обратиться к несуществующему файлу . При попытке выполнения происходит исключение : " " , Теперь тест проходит успешно , потому что мы перехватили исключение . На этой стадии можно переработать код . Тип перехватываемого исключения сужается до типа , реально инициируемого конструктором , то есть : . " " , Определив область видимости при помощи структуры - , мы можем использовать методологию для построения остальной необходимой логики . Эта логика размещается между созданием и закрытием , а в ее коде можно считать , что все операции были выполнены без ошибок . Попробуйте написать тесты , принудительно инициирующие исключения , а затем включите в обработчик поведение , обеспечивающее прохождение тестов . Это заставит вас построить транзакционную область видимости блока и поможет сохранить ее транзакционную природу . Используйте непроверяемые исключения Время споров прошло . - программисты годами обсуждали преимущества и недостатки проверяемых исключений . Когда проверяемые исключения появились в первой версии , всем казалось , что это отличная идея . В сигнатуре каждого метода должны быть перечислены все исключения , которые могут передаваться вызывающей стороне . Фактически исключения становились частью типа метода . Если сигнатура не соответствовала тому , что происходит в коде , то программа просто не компилировалась . В то время мы с энтузиазмом относились к проверяемым исключениям в самом деле , они бывают полезными . Но сейчас стало ясно , что они не являются необходимыми для создания надежных программ . В # нет проверяемых исключений , и несмотря на все доблестные попытки , в они так и не появились . Их также нет в и . Тем не менее на всех этих языках можно писать надежные программы . А раз так , нам приходится решать , оправдывают ли проверяемые исключения ту цену , которую за них приходится платить . Какую цену , спросите вы ? Цена проверяемых исключений — нарушение принципа открытости закрытости . Если вы инициируете проверяемое исключение из метода своего кода , а находится тремя уровнями выше , то это исключение должно быть объявлено в сигнатурах всех методов между вашим методом и . Следовательно , изменение на низком уровне программного продукта приводит к изменениям сигнатур на многих более высоких уровнях . Измененные модули приходится строить и развертывать заново , притом что в программе не изменилось ничего , что было бы существенно для них . Представьте иерархию вызовов большой системы . Функции верхнего уровня вызывают функции нижележащего уровня , которые , в свою очередь , вызывают функции низких уровней и т . д . Теперь допустим , что одна из низкоуровневых функций изменилась таким образом , что она должна инициировать исключение . Если это исключение является проверяемым , то в сигнатуру функции должна быть добавлена секция . Но тогда каждая функция , вызывающая нашу измененную функцию , тоже должна быть изменена с перехватом нового исключения или присоединением соответствующей секции к ее сигнатуре . И так до бесконечности . В итоге мы имеем каскад изменений , пробивающихся с нижних уровней программного продукта на верхние уровни ! При этом нарушается инкапсуляция , потому что все функции на пути инициирования должны располагать подробной информацией об этом низкоуровневом исключении . Учитывая , что главной целью исключений является возможность обработки ошибок «на расстоянии» , такое нарушение инкапсуляции проверяемыми исключениями выглядит особенно постыдно . Проверяемые исключения иногда могут пригодиться при написании особо важных библиотек : программист обязан перехватить их . Но в общем случае разработки приложенийпроблемы , создаваемые зависимостями , перевешивают преимущества . Передавайте контекст с исключениями Каждое исключение , инициируемое в программе , должно содержать достаточно контекстной информации для определения источника и местонахождения ошибки . В из любого исключения можно получить данные трассировки стека однако по трассировке невозможно узнать , с какой целью выполнялась операция , завершившаяся неудачей . Создавайте содержательные сообщения об ошибках и передавайте их со своими исключениями . Включайте в них сведения о сбойной операции и типе сбоя . Если в приложенииведется журнал , передайте информацию , достаточную для регистрации ошибки из секции . Определяйте классы исключений в контексте потребностей вызывающей стороны Существует много способов классификации ошибок . Например , ошибки можно классифицировать по источнику , то есть по компоненту , в котором они произошли . Также возможна классификация по типу : сбои устройств , сетевые сбои , ошибки программирования и т . д . Однако при определении классов исключений в приложениях думать необходимо прежде всего о том , как они будут перехватываться . Рассмотрим пример неудачной классификации исключений . Далее приводится конструкция - - для сторонней библиотечной функции . Она учитывает все исключения , которые могут быть инициированы при вызовах : . . " " , . " " , . " " … Конструкция содержит множество повторений , и это неудивительно . В большинстве ситуаций при обработке исключений выполняются относительно стандартные действия , не зависящие от их реальной причины . Мы должны сохранить ошибку и убедиться в том , что работа программы может быть продолжена . В этом случае , поскольку выполняемая работа остается более или менее постоянной независимо от исключения , код можно существенно упростить — для этого мы создаем «обертку» для вызываемой функции и обеспечиваем возвращение стандартного типа исключения : . . . , … Класс представляет собой простую обертку , которая перехватывает и преобразует исключения , инициированные классом : . … Обертки — вроде той , которую мы определили для , — бывают очень полезными . Более того , инкапсуляция вызовов сторонних принадлежит к числу стандартных приемов . Создавая обертку для стороннего вызова , вы сокращаете до минимума зависимость от него в своем коде : в будущем вы можете переключиться на другую библиотеку без сколько - нибудь заметных проблем . Обертки также упрощают имитацию сторонних вызовов в ходе тестирования кода . Последнее преимущество оберток заключается в том , что вы не ограничиваетесь архитектурными решениями разработчика . Вы можете определить тот , который вам удобен . В предыдущем примере мы определили для всех сбоев порта один тип исключения , и код от этого стал намного чище . Часто в определенной области кода бывает достаточно одного класса исключения . Информация , передаваемая с исключением , позволяет различать разные виды ошибок . Используйте разные классы исключений только в том случае , если вы намерены перехватывать одни исключения , разрешая прохождение других типов . Определите нормальный путь выполнения Картинка : _ . Выполнение рекомендаций из предыдущих разделов обеспечивает хорошее разделение бизнес - логики и кода обработки ошибок . Основной код программы начинает выглядетькак простой алгоритм , не отягощенный посторонними вставками . Однако в результате код обнаружения ошибок смещается на периферию вашей программы . Вы создаете обертки для внешних , чтобы иметь возможность инициировать собственные исключения , и определяете обработчик , который находится над основным кодом и позволяет справиться с любым прерыванием вычислений . Обычно такое решение отлично работает , но в некоторых ситуациях прерывание нежелательно . Рассмотрим конкретный пример . В следующем , довольно неуклюжем фрагменте суммируются командировочные расходы на питание : . . _ . _ Если работник предъявил счет по затратам на питание , то сумма включается в общий итог . Если счет отсутствует , то работнику за этот день начисляется определенная сумма . Исключение загромождает логику программы . А если бы удалось обойтись без обработки особого случая ? Это позволило бы заметно упростить код : . . _ . Можно ли упростить код до такой формы ? Оказывается , можно . Мы можем изменить класс , чтобы он всегда возвращал объект . При отсутствии предъявленного счета возвращается объект , у которого в качестве затрат указана стандартная сумма , начисляемая за день : Вернуть стандартные ежедневные затраты на питание Такое решение представляет собой реализацию паттерна ОСОБЫЙ СЛУЧАЙ . Программист создает класс или настраивает объект так , чтобы он обрабатывал особый случай за него . Это позволяет избежать обработки исключительного поведения в клиентском коде . Все необходимое поведение инкапсулируется в объекте особого случая . Не возвращайте На мой взгляд , при любых обсуждениях обработки ошибок необходимо упомянуть о неправильных действиях программистов , провоцирующих ошибки . На первом месте в этом списке стоит возвращение . Я видел бесчисленное множество приложений , в которых едва ли не каждая строка начиналась с проверки . Характерный пример : ! . ! . . . . . Если ваша кодовая база содержит подобный код , возможно , вы не видите в нем ничего плохого , но это не так ! Возвращая , мы фактически создаем для себя лишнюю работу , а для вызывающей стороны — лишние проблемы . Стоит пропустить всего одну проверку , и приложение «уходит в штопор» . А вы заметили , что во второй строке вложенной команды проверка отсутствует ? Что произойдет во время выполнения , если значение окажется равным ? Произойдет исключение либо кто - то перехватит его на верхнем уровне , либо не перехватит . В обоих случаях все будет плохо . Как реагировать на исключение , возникшее где - то в глубинах вашего приложения ? Легко сказать , что проблемы в приведенном коде возникли из - за пропущенной проверки . В действительности причина в другом : этих проверокслишком много . Если у вас возникает желание вернуть из метода , рассмотрите возможность выдачи исключения или возвращения объекта «особого случая» . Если ваш код вызывает метод стороннего , способный вернуть , создайте для него обертку в виде метода , который инициирует исключение или возвращает объект особого случая . Довольно часто объекты особых случаев легко решают проблему . Допустим , у вас имеется код следующего вида : ! : . Сейчас метод может возвращать , но так ли это необходимо ? Если изменить так , чтобы метод возвращал пустой список , код станет чище : : . К счастью , в существует метод . , который возвращает заранее определенный неизменяемый список , и мы можем воспользоваться им для своих целей : . . . . . Такое решение сводит к минимуму вероятность появления , а код становится намного чище . Не передавайте Возвращать из методов плохо , но передавать при вызове еще хуже . По возможности избегайте передачи в своем коде исключение составляют разве что методы сторонних , при вызове которых без нее не обойтись . Следующий пример поясняет , почему не следует передавать . Возьмем простой метод для вычисления метрики по двум точкам : , . — . . … Что произойдет , если при вызове будет передан аргумент ? . , , Конечно , возникнет исключение . Как исправить его ? Можно создать новый тип исключения и инициировать его в методе : , | | " . " . — . . Стало лучше ? Пожалуй , лучше , чем , но вспомните : для приходится определять обработчик . Что должен делать этот обработчик ? Возьметесь предложить хорошую идею ? Существует другая альтернатива : можно воспользоваться набором проверочных директив : , ! : " " ! : " " . — . . Неплохо с точки зрения документирования , но проблема не решена . Если при вызове передать , произойдет ошибка времени выполнения . В большинстве языков программирования не существует хорошего способа справиться со случайной передачей с вызывающей стороны . А раз так , разумно запретить передачу по умолчанию . В этом случае вы будете знать , что присутствие в списке аргументов свидетельствует о возникшей проблеме это будет способствовать уменьшению количества ошибок , сделанных по неосторожности . Заключение Чистый код хорошо читается , но он также должен быть надежным . Эти цели не конфликтуют друг с другом . Чтобы написать надежный и чистый код , следует рассматривать обработку ошибок как отдельную задачу , решаемую независимо от основной логики программы . В зависимости от того , насколько нам это удастся , мы сможем прорабатывать ее реализацию независимо от основной логики программы , а это окажет существенное положительное влияние на удобство сопровождения нашего кода . Литература : : , , , . , , . Глава . Границы Джеймс Гренинг Картинка : _ . Редко когда весь программный код наших систем находится под нашим полным контролем . Иногда нам приходится покупать пакеты сторонних разработчиков или использовать открытый код . В других случаях мы зависим от других групп нашей компании , производящих компоненты или подсистемы для нашего проекта . И этот внешний код мы должны каким - то образом четко интегрировать со своим кодом . В этой главе рассматриваются приемы и методы «сохранения чистоты» границ нашего программного кода . Использование стороннего кода Между поставщиком и пользователем интерфейса существует естественная напряженность . Поставщики сторонних пакетов и инфраструктур стремятся к универсальности , чтобы их продукты работали в разных средах и были обращены к широкой аудитории . С другой стороны , пользователи желают получить интерфейс , специализирующийся на их конкретных потребностях . Эта напряженность приводит к появлению проблем на границах наших систем . Для примера возьмем класс . . . Как видно из рис . . , имеет очень широкий интерфейс с многочисленными возможностями . Конечно , мощь и гибкость контейнера полезны , но они также создают некоторые неудобства . Допустим , наше приложение строит объект и передает его другим сторонам . При этом мы не хотим , чтобы получатели удаляли данные из полученного контейнера . Но в самом начале списка стоит метод , и любой пользователь может стереть текущее содержимое контейнера . А может быть , наша архитектура подразумевает , что в контейнере должны храниться объекты только определенного типа , но не обладает надежными средствами ограничения типов сохраняемых объектов . Любой настойчивый пользователь сможет разместить в элементы любого типа . • – • – • – • – • – • – • ? – • – • – • – • – • – • , – • – • – • – • – • – • – • – • , – Рис . . . Методы Если в приложении требуется контейнер с элементами , его можно создать следующим образом : Когда другой части кода понадобится обратиться к элементу , мы видим код следующего вида : . Причем видим его не только в этом месте , но снова и снова по всему коду . Клиент кода несет ответственность за получение из и его приведение к правильному типу . Такое решение работает , но «чистым» его не назовешь . Кроме того , этот код не излагает свою историю , как ему положено . Удобочитаемость кода можно было бы заметно улучшить при помощи шаблонов параметризованных контейнеров : … . Но и такая реализация не решает проблемы : предоставляет намного больше возможностей , чем нам хотелось бы . Свободная передача по системе означает , что в случае изменения интерфейса исправления придется вносить во множестве мест . Казалось бы , такие изменения маловероятны , но вспомните , что интерфейс изменился при добавлении поддержки шаблонов в . В самом деле , мы видели системы , разработчики которых воздерживались от использования шаблонов из - за большого количества потенциальных изменений , связанных с частым использованием . Ниже представлен другой , более чистый вариант использования . С точки зрения пользователя совершенно не важно , используются шаблоны или нет . Это решение стало и всегда должно быть подробностью реализации . . … Граничный интерфейс скрыт от пользователя . Он может развиваться независимо , практически не оказывая никакого влияния на остальные части приложения . Применение шаблонов уже не создает проблем , потому что все преобразования типов выполняются в классе . Этот интерфейс также приспособлен и ограничен в соответствии с потребностями приложения . Код становится более понятным , а возможности злоупотреблений со стороныпользователя сокращаются . Класс может обеспечивать выполнение архитектурных требований и требований бизнес - логики . Поймите правильно : мы не предлагаем инкапсулировать каждое применение в этой форме . Скорее , мы рекомендуем ограничить передачу или любого другого граничногоинтерфейса по системе . Если вы используете граничный интерфейс вроде , держите его внутри класса или тесно связанного семейства классов , в которых он используется . Избегайте его возвращения или передачи в аргументах при вызовах методов общедоступных . Исследование и анализ границ Сторонний код помогает нам реализовать больше функциональности за меньшее время . С чего начинать , если мы хотим использовать сторонний пакет ? Тестирование чужогокода не входит в наши обязанности , но , возможно , написание тестов для стороннего кода , используемого в наших продуктах , в наших же интересах . Допустим , вам не ясно , как использовать стороннюю библиотеку . Можно потратить день - два или более на чтение документации и принятие решений о том , как работать с библиотекой . Затем вы пишете код , использующий стороннюю библиотеку , и смотрите , делает ли он то , что ожидалось . Далее вы , скорее всего , погрязнете в долгих сеансах отладки , пытаясь разобраться , в чьем коде возникают ошибки – в стороннем или в вашем собственном . Изучение чужого кода – непростая задача . Интеграция чужого кода тоже сложна . Одновременное решение обоих задач создает двойные сложности . А что , если пойти по другому пути ? Вместо того чтобы экспериментировать и опробовать новую библиотеку в коде продукта , можно написать тесты , проверяющие наше понимание стороннего кода . Джим Ньюкирк называет такие тесты «учебными тестами» , . – . В учебных тестах мы вызываем методы стороннего в том виде , в котором намереваемся использовать их в своем приложении . Фактически выполняется контролируемый эксперимент , проверяющий наше понимание стороннего . Основное внимание в тестах направлено на то , чего мы хотим добиться при помощи . Изучение Допустим , вместо того чтобы писать специализированный журнальный модуль , мы хотим использовать пакет . Мы загружаем пакет и открываем страницу вводной документации . Не особенно вчитываясь в нее , мы пишем свой первый тестовый сценарий , который , как предполагается , будет выводить на консоль строку « » . @ . " " . " " При запуске журнальный модуль выдает ошибку . В описании ошибки говорится , что нам понадобится нечто под названием . После непродолжительных поисков в документации обнаруживается класс . Соответственно , мы создаем объект и проверяем , удалось ли нам раскрыть секреты вывода журнала на консоль : @ . " " . . " " На этот раз выясняется , что у объекта нет выходного потока . Странно – логика подсказывает , что он должен быть . После небольшой помощи от опробуется следующее решение : @ . " " . . " % % % % " , . _ . " " Заработало на консоли выводится сообщение со словом « » ! На первый взгляд происходящее выглядит немного странно : мы должны указывать , что данные выводятся на консоль . Еще интереснее , что при удалении аргумента . сообщение « » все равно выводится . Но если убрать аргумент , снова начинаются жалобы на отсутствие выходного потока . Все это выглядит очень странно . После более внимательного чтения документации мы видим , что конструктор по умолчанию «не имеет конфигурации» – весьма неочевидное и бесполезное решение . Похоже , это ошибка или по крайней мере нелогичность в . После некоторых поисков , чтения документации и тестирования мы приходим к листингу . . Попутно мы получили много полезной информации о том , как работает , и закодировали ее в наборе простых модульных тестов . Листинг . . . @ . " " . . . @ . . " " @ . " % % % % " , . _ . “ ” @ . " % % % % " . " " Теперь мы знаем , как инициализировать простейший консольный вывод и можем воплотить эти знания в специализированном журнальном классе , чтобы изолировать остальной код приложения от граничного интерфейса . Учебные тесты : выгоднее , чем бесплатно Учебные тесты не стоят ничего . все равно приходится изучать , а написание тестов является простым способом получения необходимой информации , в изоляции от рабочего кода . Учебные тесты были точно поставленными экспериментами , которые помогли нам расширить границы своего понимания . Учебные тесты не просто бесплатны – они приносят дополнительную прибыль . При выходе новых версий сторонних пакетов вы сможете провести учебные тесты и выяснить , не изменилось ли поведение пакета . Учебные тесты позволяют убедиться в том , что сторонние пакеты , используемые в коде , работают именно так , как мы ожидаем . Нет никаких гарантий , что сторонний код , интегрированный в наши приложения , всегда будет сохранять совместимость . Например , авторы могут изменить код в соответствии с какими - то новыми потребностями . Изменения также могут происходить из - за исправления ошибок и добавления новых возможностей . Выход каждой новой версии сопряжен с новым риском . Если в стороннем пакете появятся изменения , несовместимые с нашими тестами , мы сразу узнаем об этом . Впрочем , независимо от того , нужна ли вам учебная информация , получаемая в ходе тестирования , в системе должна существовать четкая граница , которая поддерживаетсягруппой исходящих тестов , использующих интерфейс по аналогии с кодом продукта . Безграничных тестов , упрощающих процесс миграции , у нас появляются причины задержаться на старой версии дольше необходимого . Использование несуществующего кода Также существует еще одна разновидность границ , отделяющая известное от неизвестного . В коде часто встречаются места , в которых мы не располагаем полной информацией . Иногда то , что находится на другой стороне границы , остается неизвестным по крайней мере в данный момент . Иногда мы намеренно не желаем заглядывать дальше границы . Несколько лет назад я работал в группе , занимавшейся разработкой программного обеспечения для системы радиосвязи . В нашем продукте была подсистема «Передатчик» , о которой мы почти ничего не знали , а люди , ответственные за разработку этой подсистемы , еще не дошли до определения своего интерфейса . Мы не хотели простаивать и поэтому начали работать подальше от неизвестной части кода . Мы неплохо представляли себе , где заканчивалась наша зона ответственности и начиналась чужая территория . В ходе работы мы иногда наталкивались на границу . Хотя туманы и облака незнания скрывали пейзаж за границей , в ходе работы мы начали понимать , каким должен быть граничный интерфейс . Передатчику должны были отдаваться распоряжения следующего вида : Настроить передатчик на заданную частоту и отправить аналоговое представление данных , поступающих из следующего потока . Мы тогда понятия не имели , как это будет делаться , потому что еще не был спроектирован . Поэтому подробности было решено отложить на будущее . Чтобы не останавливать работу , мы определили собственный интерфейс с броским именем . Интерфейс содержал метод , которому при вызове передавались частота и поток данных . Это был тот интерфейс , который нам хотелось бы иметь . У этого интерфейса было одно важное достоинство : он находился под нашим контролем . В результате клиентский код лучше читался , а мы в своей работе могли сосредоточиться на том , чего стремились добиться . На рис . . мы видим , что классы отделены от передатчика который находился вне нашего контроля и оставался неопределенным . Использование конкретного интерфейса нашего приложения позволило сохранить чистоту и выразительность кода . После того как другая группа определила передатчика , мы написали класс для «наведения мостов» . АДАПТЕР инкапсулировал взаимодействие с и создавал единое место для внесения изменений в случае развития . Такая архитектура также создает в коде очень удобный «стык» для тестирования . Используя подходящий , мы можем тестировать классы . Кроме того , сразу же после появления можно создать граничные тесты для проверки правильности использования . Картинка : _ . Рис . . . Прогнозирование интерфейса передатчика Чистые границы На границах происходит много интересного . В частности , стоит уделить особое внимание изменениям . В хорошей программной архитектуре внесение изменений обходится без значительных затрат и усилий по переработке . Если в продукте используется код , находящийся вне нашего контроля , примите особые меры по защите капиталовложений и позаботьтесь о том , чтобы будущие изменения обходились не слишком дорого . Для граничного кода необходимо четкое разделение сторон и тесты , определяющие ожидания пользователя . Постарайтесь , чтобы ваш код поменьше знал о специфических подробностях реализации стороннего кода . Лучше зависеть от того , что находится под вашим контролем , чем от тех факторов , которые вы не контролируете а то , чего доброго , они начнут контролировать вас . Чтобы границы со сторонним кодом не создавали проблем в наших проектах , мы сводим к минимуму количество обращений к ним . Для этого можно воспользоваться обертками , как в примере с , или реализовать паттерн АДАПТЕР для согласования нашего идеального интерфейса с реальным , полученным от разработчиков . В обоих вариантах код становится более выразительным , обеспечивается внутренняя согласованность обращений через границы , а изменение стороннего кода требует меньших затрат на сопровождение . Литература : , , - , . : : , . , - , . : , - , . Глава . Модульные тесты Картинка : _ . За последние десять лет наша профессия прошла долгий путь . В году никто не слыхал о методологии , то есть «разработка через тестирование» . Для подавляющего большинства разработчиков модульные тесты представляли собой короткие фрагменты временного кода , при помощи которого мы убеждались в том , что наши программы «работают» . Мы тщательно выписывали свои классы и методы , а потом подмешивали специализированный код для их тестирования . Как правило , при этом использовалась какая - нибудь несложная управляющая программа , которая позволяла вручную взаимодействовать с тестируемым кодом . Помню , в середине - х я написал программу на для встроенной системы реального времени . Программа представляла собой простой таймер со следующей сигнатурой : : : , Идея была проста метод класса выполнялся в новом программном потоке с заданной задержкой в миллисекундах . Оставалось понять , как его тестировать . Я соорудил простую управляющую программу , которая прослушивала события клавиатуры . Каждый раз , когда на клавиатуре вводился символ , программа планировала выполнение команды , повторяющей этот же символ пять секунд спустя . Затем я настучал на клавиатуре ритмичную мелодию и подождал , пока эта мелодия «появится» на экране спустя пять секунд . «Мне… нужна такая девушка… как та… которую нашел мой старый добрый папа…» Я напевал эту мелодию , нажимая клавишу « . » , а потом пропел ее снова , когда точки начали появляться на экране . И это был весь тест ! Я убедился в том , что программа работает , показал ее своим коллегам и выкинул тестовый код . Как я уже говорил , наша профессия прошла долгий путь . Сейчас я бы написал комплексный тест , проверяющий , что все углы и закоулки моего кода работают именно так , как положено . Я бы изолировал свой код от операционной системы , не полагаясь на стандартное выполнение по таймеру . Я бы самостоятельно реализовал хронометраж , чтобы тестирование проходило под моим полным контролем . Запланированные команды устанавливали бы логические флаги , а потом тестовый код выполнял бы мою программу в пошаговом режиме , наблюдая за состоянием флагов и их переходами из ложного состояния в истинное по прохождении нужного времени . Когда у меня накопился бы пакет тестов , я бы позаботился о том , чтобы эти тесты были удобными для любого другого программиста , которому потребуется работать с моим кодом . Я бы проследил за тем , чтобы тесты и код поставлялись вместе , в одном исходном пакете . Да , мы прошли долгий путь но дорога еще не пройдена до конца . Движения гибких методологий и поощряют многих программистов писать автоматизированные модульные тесты , а их ряды ежедневно пополняются новыми сторонниками . Однако в лихорадочном стремлении интегрировать тестирование в свою работу многие программисты упускаютболее тонкие и важные аспекты написания хороших тестов . Три закона В наши дни каждому известно , что по требованиям методологии модульные тесты должны писаться заранее , еще до написания кода продукта . Но это правило — всего лишь верхушка айсберга . Рассмотрим следующие три закона : Первый закон . Не пишите код продукта , пока не напишете отказной модульный тест . Второй закон . Не пишите модульный тест в объеме большем , чем необходимо для отказа . Невозможность компиляции является отказом . Третий закон . Не пишите код продукта в объем большем , чем необходимо для прохождения текущего отказного теста . Эти три закона устанавливают рамки рабочего цикла , длительность которого составляет , вероятно , около секунд . Тесты и код продукта пишутся вместе , а тесты на несколько секунд опережают код продукта . При такой организации работы мы пишем десятки тестов ежедневно , сотни тестов ежемесячно , тысячи тестов ежегодно . При такой организации работы тесты охватывают практически все аспекты кода продукта . Громадный объем тестов , сравнимый с объемом самого кода продукта , может создать немало организационных проблем . О чистоте тестов Несколько лет назад мне предложили заняться обучением группы , которая решила , что тестовый код не должен соответствовать тем же стандартам качества , что и код продукта . Участники группы сознательно разрешили друг другу нарушать правила в модульных тестах . «На скорую руку» — вот каким девизом они руководствовались . Разумно выбирать имена переменных не обязательно , короткие и содержательные тестовые функции не обязательны . Качественно проектировать тестовый код , организовать его продуманное логическое деление не обязательно . Тестовый код работает , охватывает код продукта — и этого вполне достаточно . Пожалуй , некоторые читатели сочувственно отнесутся к этому решению . Возможно , кто - то в прошлом писал тесты наподобие тех , которые я написал для своего класса . Примитивные «временные» тесты отделены огромным расстоянием от пакетов автоматизированного модульного тестирования . Многие программисты как и та группа , в которой я преподавал полагают , что тесты «на скорую руку» — лучше , чем полное отсутствие тестов . Но на самом деле тесты «на скорую руку» равносильны полному отсутствию тестов , если не хуже . Дело в том , что тесты должны изменяться по мере развития кода продукта . Чем примитивнее тесты , тем труднее их изменять . Если тестовый код сильно запутан , то может оказаться , что написание нового кода продукта займет меньше времени , чем попытки втиснуть новые тесты в обновленный пакет . При изменении кода продукта старые тесты перестают проходить , а неразбериха в тестовом коде не позволяет быстро разобраться с возникшими проблемами . Таким образом , тесты начинают рассматриваться как постоянно растущий балласт . От версии к версии затраты на сопровождение тестового пакета непрерывно росли . В конечном итоге тесты стали главной причиной для жалоб разработчиков . Когда руководство спрашивало , почему работа занимает столько времени , разработчики винили во всем тесты . Кончилось все тем , что они полностью отказались от тестового пакета . Однако без тестов программисты лишились возможности убедиться в том , что изменения в кодовой базе работают так , как ожидалось . Без тестов они уже не могли удостовериться в том , что изменения в одной части системы не нарушают работу других частей . Количество ошибок стало возрастать . А с ростом количества непредвиденных дефектов программисты начали опасаться изменений . Они перестали чистить код продукта , потому что боялись : не будет ли от изменений больше вреда , чем пользы ? Код продукта стал загнивать . В итоге группа осталась без тестов , с запутанной и кишащей ошибками кодовой базой , с недовольными клиентами и с чувством , что все усилия по тестированию не принесли никакой пользы . И в определенном смысле они были правы . Их усилия по тестированиюдействительнооказались бесполезными . Но виной всему было их решение — небрежно написанные тесты привели к катастрофе . Если бы группа ответственно подошла к написанию тестов , то затраченное время не пропало бы даром . Я говорю об этом вполне уверенно , потому что работал и преподавал во многих группах , добившихся успеха с аккуратно написанными модульными тестами . Мораль проста : тестовый код не менее важен , чем код продукта . Не считайте его «кодом второго сорта» . К написанию тестового кода следует относиться вдумчиво , внимательно и ответственно . Тестовый код должен быть таким же чистым , как и код продукта . Тесты как средство обеспечения изменений Если не поддерживать чистоту своих тестов , то вы их лишитесь . А без тестов утрачивается все то , что обеспечивает гибкость кода продукта . Да , вы не ошиблись . Именно модульные тесты обеспечивают гибкость , удобство сопровождения и возможность повторного использования нашего кода . Это объясняется просто : если у вас есть тесты , вы не боитесь вносить изменения в код ! Без тестов любое изменение становится потенциальной ошибкой . Какой бы гибкой ни была ваша архитектура , каким бы качественным ни было логическое деление вашей архитектуры , без тестов вы будете сопротивляться изменениям из опасений , что они приведут к появлению скрытых ошибок . С тестами эти опасения практически полностью исчезают . Чем шире охват тестирования , тем меньше вам приходится опасаться . Вы можете практически свободно вносить изменения даже в имеющий далеко не идеальную архитектуру , запутанный и малопонятный код . Таким образом , вы можете спокойно улучшать архитектуру и строение кода ! Итак , наличие автоматизированного пакета модульных тестов , охватывающих код продукта , имеет важнейшее значение для чистоты и ясности архитектуры . А причина заключается в том , что тесты обеспечивают возможность внесения изменения . Таким образом , если ваши тесты недостаточно чисты и проработаны , ваши возможности по изменению кода сокращаются и вы лишаетесь возможности улучшения структуры кода . Некачественные тесты приводит к некачественному коду продукта . В конечном итоге тестирование вообще становятся невозможным , и код продукта начинает загнивать . Чистые тесты Какими отличительными признаками характеризуется чистый тест ? Тремя : удобочитаемостью , удобочитаемостью и удобочитаемостью . Вероятно , удобочитаемость в модульных тестах играет еще более важную роль , чем в коде продукта . Что делает тестовый код удобочитаемым ? То же , что делает удобочитаемым любой другой код : ясность , простота и выразительность . В тестовом коде необходимо передать максимум информации минимумом выразительных средств . В листинге . приведен фрагмент кода из проекта . Эти три теста трудны для понимания несомненно , их можно усовершенствовать . Прежде всего , повторные вызовы и содержат огромное количество повторяющегося кода . Что еще важнее , код просто забит второстепенными подробностями , снижающими выразительность теста . Листинг . . . . , . " " . , . " . " . , . " " . " " . " " , " " . , . " " , . " " , " " , " " , . , . " " . , . " . " . , . " " . . . . _ . " " , " " . . " " . " " , " " . , . " " , . " " , " " , " " , " " , . , . " " , " " . " " . " " , " " . , . " " , . " " , " " , Например , присмотритесь к вызовам , преобразующим строки в экземпляры , используемые обходчиками . Это преобразование абсолютно несущественно для целей тестирования и только затемняет намерения автора . Второстепенные подробности , окружающие создание ответчика , а также сбор и преобразование ответа тоже представляют собой обычный шум . Также обратите внимание на неуклюжий способ построения - адреса запроса из ресурса и аргумента . Я участвовал в написании этого кода , поэтому считаю , что вправе критиковать его . В общем , этот код не предназначался для чтения . На несчастного читателя обрушивается целый водопад мелочей , в которых необходимо разобраться , чтобы уловить в тестах хоть какой - то смысл . Теперь рассмотрим усовершенствованные тесты в листинге . . Они делают абсолютно то же самое , но код был переработан в более ясную и выразительную форму . Листинг . . . переработанная версия " " , " . " , " " " " , " : " " " , " " , " " " " " . " , " " , " " , " " " " , " : " " " , " " , " " " " " " , " " " " , " : " " " , " " В структуре тестов очевидно воплощен паттерн ПОСТРОЕНИЕ - ОПЕРАЦИИ - ПРОВЕРКА . Каждый тест четко делится на три части . Первая часть строит тестовые данные , вторая часть выполняет операции с тестовыми данными , а третья часть проверяет , что операция привела к ожидаемым результатам . Обратите внимание : большая часть раздражающих мелочей исчезла . Тесты не делают ничего лишнего , и в них используются только действительно необходимые типы данных и функции . Любой программист , читающий эти тесты , очень быстро разберется в том , что они делают , не сбиваясь с пути и не увязнув в лишних подробностях . Предметно - ориентированный язык тестирования Тесты в листинге . демонстрируют методику построения предметно - ориентированного языка для программирования тестов . Вместо вызова функций , используемых программистами для манипуляций с системой , мы строим набор функций и служебных программ , использующих это упрощает написание и чтение тестов . Наши функции и служебные программы образуют специализированный , то есть по сути — язык тестирования , который программисты используют для упрощения работы над тестами , а также чтобы помочь другим программистам , которые будут читать эти тесты позднее . Тестовый не проектируется заранее он развивается на базе многократной переработки тестового кода , перегруженного ненужными подробностями . По аналогии с тем , как я переработал листинг . в листинг . , дисциплинированные разработчики перерабатывают свой тестовый код в более лаконичные и выразительные формы . Двойной стандарт Группа , о которой я упоминал в начале этой главы , в определенном смысле была права . Код тестового подчиняется несколько иным техническим стандартам , чем код продукта . Он также должен быть простым , лаконичным и выразительным , но от него не требуется такая эффективность . В конце концов , тестовый код работает в тестовой среде , ане в среде реальной эксплуатации продукта , а эти среды весьма заметно различаются по своим потребностям . Рассмотрим тест из листинга . . Я написал его в ходе работы над прототипом системы контроля окружающей среды . Не вдаваясь в подробности , скажу , что тест этот проверяет , что при слишком низкой температуре включается механизм оповещения о низкой температуре , обогреватель и система подачи нагретого воздуха . Листинг . . . @ . _ _ . . . . Листинг . продолжение . . Конечно , этот листинг содержит множество ненужных подробностей . Например , что делает функция ? Я бы предпочел , чтобы читатель не задумывался об этом в ходе чтениятеста . Читатель должен думать о другом : соответствует ли конечное состояние системы его представлениям о «слишком низкой» температуре . Обратите внимание : в ходе чтения теста вам постоянно приходится переключаться между названием проверяемого состояния и условием проверки . Вы смотрите на состояние обогревателя , а затем ваш взгляд скользит налево к . Вы смотрите на состояние охладителя , а ваш взгляд отступает к . Все эти перемещения утомительны и ненадежны . Они усложняют чтение теста . В листинге . представлена новая форма теста , которая читается гораздо проще . Листинг . . . переработанная версия @ " " , . Конечно , я скрыл функцию , создав более понятную функцию . Но особого внимания заслуживает странная строка в вызове . Верхний регистр означает включенное состояние , нижний регистр — выключенное состояние , а буквы всегда следуют в определенном порядке : обогреватель , подача воздуха , охладитель , сигнал о высокой температуре , сигнал о низкой температуре . Хотя такая форма близка к нарушению правила о мысленных преобразованиях , в данном случае она выглядит уместной . Если вам известен смысл этих обозначений , ваш взгляд скользит по строке в одном направлении и вы можете быстро интерпретировать результаты . Чтение таких тестов почти что доставляет удовольствие . Взгляните на листинг . и убедитесь , как легко понять их смысл . Листинг . . . расширенный набор @ " " , . @ " " , . @ " " , . @ " " , . Функция приведена в листинге . . Обратите внимание : эффективность этого кода оставляет желать лучшего . Чтобы сделать его более эффективным , вероятно , мне стоило использовать класс . Листинг . . . " " ? " " : " " ? " " : " " ? " " : " " ? " " : " " ? " " : " " Класс некрасив и неудобен . Даже в коде продукта я стараюсь избегать его , если это не приводит к большим потерям конечно , в коде из листинга . потери невелики . Однако следует учитывать , что приложение пишется для встроенной системы реального времени , в которой вычислительные ресурсы и память сильно ограничены . С другойстороны , в среде тестирования такие ограничения отсутствуют . В этом проявляется природа двойного стандарта . Многое из того , что вы никогда не станете делать в среде эксплуатации продукта , абсолютно нормально выглядит в среде тестирования . Обычно речь идет о затратах памяти или эффективности работы процессора — ноникогдао проблемах чистоты кода . Одна проверка на тест Существует точка зрения , согласно которой каждая тестовая функция в тесте должна содержать одну — и только одну — директиву . Такое правило может показаться излишне жестким , но его преимущества наглядно видны в листинге . . Тесты приводят к одному выводу , который можно быстро и легко понять при чтении . Но что вы скажете о листинге . ? В нем объединена проверка двух условий : что выходные данные представлены в формате и они содержат некоторые подстроки . На первый взгляд такое решение выглядит сомнительно . Впрочем , тест можно разбить на два отдельных теста , каждый из которых имеет собственную директиву , как показано в листинге . . Листинг . . . одна директива " " , " . " , " " " " , " : " " " , " . " , " " " " , " : " " " , " " , " " Обратите внимание : я переименовал функции в соответствии со стандартной схемой - - . Это еще сильнее упрощает чтение тестов . К сожалению , такое разбиение приводит к появлению большого количества дублирующегося кода . Чтобы избежать дублирования , можно воспользоваться паттерном ШАБЛОННЫЙ МЕТОД , включить части в базовый класс , а части — в различные производные классы . А можно создать отдельный тестовый класс , поместить части и в функцию @ , а части — в каждую функцию @ . Но похоже , такой механизм слишком сложен для столь незначительной проблемы . В конечном итоге я предпочел решение с множественными директивами из листинга . . Я думаю , что правило «одного » является хорошей рекомендацией . Обычно я стараюсь создать предметно - ориентированный язык тестирования , который это правило поддерживает , как в листинге . . Но при этом я не боюсь включать в свои тесты более одной директивы . Вероятно , лучше всего сказать , что количество директив в тесте должно быть сведено к минимуму . Одна концепция на тест Пожалуй , более полезное правило гласит , что в каждой тестовой функции должна тестироваться одна концепция . Мы не хотим , чтобы длинные тестовые функции выполняли несколько разнородных проверок одну за другой . Листинг . содержит типичный пример такого рода . Этот тест следовало бы разбить на три независимых теста , потому что в нем выполняются три независимых проверки . Объединение их в одной функции заставляет читателя гадать , почему в функцию включается каждая секция , и какое условие проверяется в этой секции . Листинг . Тесты для метода . . , , . , , . , . , . . , , . , . , . . , . , , . , . , . Вероятно , три тестовые функции должны выглядеть так : • : последний день месяца , состоящего из дня например , май . : при добавлении одного месяца , последним днем которого является - е число например , июнь , датой должно быть - е число этого месяца , а не - е . : при добавлении двух месяцев , когда последним днем второго месяца является - е число , датой должно быть - е число . • : последний день месяца , состоящего из дней например , июнь . : при добавлении одного месяца , последним днем которого является - е число , датой должно быть - е число этого месяца , а не - е . В такой формулировке видно , что среди разнородных тестов скрывается одно общее правило . При увеличении месяца дата не может превысить последнее число нового месяца . Следовательно , в результате увеличение месяца для февраля должна быть получена дата марта . В текущей версии это условие не проверяется , хотя такой тест был бы полезен . Таким образом , проблема не в множественных директивах в разных секциях листинга . . Проблема в том , что тест проверяет более одной концепции . Так что , вероятно , лучше всего сформулировать это правило так : количество директив на концепцию должно быть минимальным , и в тестовой функции должна проверяться только одна концепция . . . . . . Чистые тесты должны обладать еще пятью характеристиками , названия которых образуют приведенное сокращение . Быстрота . Тесты должны выполняться быстро . Если тесты выполняются медленно , вам не захочется часто запускать их . Без частого запуска тестов проблемы не будут выявляться на достаточно ранней стадии , когда они особенно легко исправляются . В итоге вы уже не так спокойно относитесь к чистке своего кода , и со временем код начинает загнивать . Независимость . Тесты не должны зависеть друг от друга . Один тест не должен создавать условия для выполнения следующего теста . Все тесты должны выполняться независимо и в любом порядке на ваше усмотрение . Если тесты зависят друг от друга , то при первом отказе возникает целый каскад сбоев , который усложняет диагностику и скрывает дефекты в зависимых тестах . Повторяемость . Тесты должны давать повторяемые результаты в любой среде . Вы должны иметь возможность выполнить тесты в среде реальной эксплуатации , в среде тестирования или на вашем ноутбуке во время возвращения домой с работы . Если ваши тесты не будут давать однозначных результатов в любых условиях , вы всегда сможете найти отговорку для объяснения неудач . Также вы лишитесь возможности проводить тестирование , если нужная среда недоступна . Очевидность - . Результатом выполнения теста должен быть логический признак . Тест либо прошел , либо не прошел . Чтобы узнать результат , пользователь не должен читать журнальный файл . Не заставляйте его вручную сравнивать два разных текстовых файла . Если результат теста не очевиден , то отказы приобретают субъективный характер , а выполнение тестов может потребовать долгой ручной обработки данных . Своевременность . Тесты должны создаваться своевременно . Модульные тесты пишутсянепосредственно передкодом продукта , обеспечивающим их прохождение . Если вы пишете тесты после кода продукта , вы можете решить , что тестирование кода продукта создает слишком много трудностей , а все из - за того , что удобство тестирования не учитывалось при проектировании кода продукта . Заключение В этой главе мы едва затронули тему тестирования . Я думаю , что на темучистых тестовможно было бы написать целую книгу . Для «здоровья» проекта тесты не менее важны , чем код продукта . А может быть , они еще важнее , потому что тесты сохраняют и улучшают гибкость , удобство сопровождения и возможности повторного использования кода продукта . Постоянно следите за чистотой своих тестов . Постарайтесь сделать их выразительными и лаконичными . Изобретайте тестовые , которым отводится роль предметно - ориентированного языка тестирования , упрощающего написание тестов . Если вы будете пренебрежительно относиться к тестам , то и ваш код начнет загнивать . Поддерживайте чистоту в своих тестах . Литература : : , , , , . : : , . , - , . Глава . КлассыСовместно с Джеффом Лангром Картинка : _ . До настоящего момента наше внимание было сосредоточено исключительно на том , как качественно написать строки и блоки кода . Мы разобрались с правильной композицией функций и их взаимосвязями . Но какими бы выразительными ни были функции и содержащиеся в них команды , мы не добьемся чистоты кода до тех пор , пока не обратим внимание на более высокие уровни организации кода . В этой главе речь пойдет о чистоте классов . Строение класса По стандартным правилам класс должен начинаться со списка переменных . Сначала перечисляются открытые статические константы . Далее следуют приватные статические переменные , а за ними идут приватные переменные экземпляров . Открытых переменных обычно нет , трудно найти веские причины для их использования . За списком переменных обычно следуют открытые функции . Мы предпочитаем размещать приватные вспомогательные функции , вызываемые открытыми функциями , непосредственно за самой открытой функцией . Такое размещение соответствует правилу понижения , в результате чего программа читается как газетная статья . Инкапсуляция Мы предпочитаем объявлять переменные и вспомогательные функции приватными , но относимся к ним без фанатизма . Иногда переменную или вспомогательную функцию приходится объявлять защищенной , чтобы иметь возможность обратиться к ней из теста . С нашей точки зрения тесты исключительно важны . Если тест из того же пакета должен вызвать функцию или обратиться к переменной , мы используем защищенный или пакетный уровень доступа . Тем не менее начинать следует с поиска способа , сохраняющего приватность . Ослабление инкапсуляции всегда должно быть последней мерой . Классы должны быть компактными ! Первое правило : классы должны быть компактными . Второе правило : классы должны быть еще компактнее . Нет , мы не собираемся повторять текст из главы . Но как и в случаес функциями , компактность должна стать основным правилом проектирования классов . И для классов начинать следует с вопроса : «А насколько компактными ? » Размер функций определяется количеством физических строк . В классах используется другая метрика мы подсчитываемответственности . В листинге . представлен класс , предоставляющий около открытых методов . Большинство разработчиков согласится с тем , что это перебор . Листинг . . Слишком много ответственностей Листинг . продолжение , , , , , , ? , … и еще много других , не - открытых методов … А если бы класс содержал только методы , приведенные в листинге . ? Листинг . . Достаточно компактно ? Пять методов — не слишком много , не так ли ? В нашем случае слишком , потому что несмотря на малое количество методов , класс по - прежнему имеет слишком много ответственностей . Имя класса должно описывать его ответственности . В сущности , имя должно стать первым фактором , способствующим определению размера класса . Если для класса не удается подобрать четкое , короткое имя , вероятно , он слишком велик . Чем туманнее имя класса , тем больше вероятность , что он имеет слишком много ответственностей . В частности , присутствие в именах классов слов - проныр « » , « » и « » часто свидетельствует о нежелательном объединении ответственностей . Краткое описание класса должно укладываться примерно в слов , без выражений «если» , «и» , «или» и «но» . Как бы вы описали класс ? «Класс предоставляет доступк компоненту , который последним имел фокус ввода , и позволяет отслеживать номера версии и сборки» . Первое «и» указывает на то , что имеет слишком много ответственностей . Принцип единой ответственности Принцип единой ответственности утверждает , что класс или модуль должен иметь одну — и только одну — причину для изменения . Этот принцип дает нам как определение ответственности , так и критерий для оценки размера класса . Классы должны иметь одну ответственность , то есть одну причину для изменений . Небольшой , казалось бы , класс в листинге . имеет две причины для изменений . Во - первых , он отслеживает версию , которая , вероятно , будет изменяться при каждом обновлении продукта . Во - вторых , он управляет компонентами потомки класса , представляющего графическое окно верхнего уровня в . Несомненно , номер версии должен обновляться при любых изменениях кода , но обратное не всегда верно : номер версии также может изменяться вследствие изменений в другом коде системы . Попытки идентификации ответственностей причин для изменения часто помогают выявить и создать более качественные абстракции для нашего кода . Все три метода , относящиеся к версии , легко выделяются в отдельный класс с именем листинг . . Класс обладает хорошим потенциалом для повторного использования в других приложениях ! Листинг . . Класс с единой ответственностью Принцип единой ответственности — одна из самых важных концепций в объектно - ориентированном проектировании . Кроме того , его относительно несложно понять и соблюдать . Но как ни странно , принцип единой ответственности часто оказывается самым нарушаемым принципом проектирования классов . Мы постоянно встречаем классы , которыеделают слишком много всего . Почему ? Заставить программу работать и написать чистый код — совершенно разные вещи . Обычно мы думаем прежде всего о том , чтобы наш код заработал , а не о его структуре и чистоте . И это абсолютно законно . Разделение ответственности в работе программиста играет не менее важную роль , чем в наших программах . К сожалению , слишком многие из нас полагают , что после того , как программа заработает , их работа закончена . Мы не переключаемся на усовершенствование ее структуры и чистоты . Мы переходим к следующей задаче вместо того , чтобы сделать шаг назад и разделить разбухшие классы на отдельные блоки с единой ответственностью . В то же время многие разработчики опасаются , что множество небольших узкоспециализированных классов затруднит понимание общей картины . Их беспокоит то , что им придется переходить от класса к классу , чтобы разобраться в том , как решается более крупная задача . Однако система с множеством малых классов имеет не больше «подвижных частей» , чем система с несколькими большими классами . В последней тоже придется разбираться , и это будет ничуть не проще . Так что вопрос заключается в следующем : хотите ли вы , чтобы ваши инструменты были разложены по ящикам с множеством небольших отделений , содержащих четко определенные и подписанные компоненты ? Или вы предпочитаете несколько больших ящиков , в которые можно сваливать все подряд ? Каждая крупная система содержит большой объем рабочей логики и обладает высокой сложностью . Первоочередной целью управления этой сложностью являетсяформирование структуры , при которой разработчик знает , где искать то , что ему требуется , и в любой момент времени может досконально знать только ту часть системы , которая непосредственно относится к его работе . Напротив , в системе с большими , многоцелевыми классами нам неизбежно приходится разбираться с множеством аспектов , которые в данный момент нас не интересуют . Еще раз выделю основные моменты : система должна состоять из множества мелких классов , а не из небольшого числа больших . Каждый класс инкапсулирует одну ответственность , имеет одну причину для изменения и взаимодействует с другими классами для реализации желаемого поведения системы . Связность Классы должны иметь небольшое количество переменных экземпляров . Каждый метод класса должен оперировать с одной или несколькими из этих переменных . В общем случае , чем с большим количеством переменных работает метод , тем выше связность этого метода со своим классом . Класс , в котором каждая переменная используется каждым методом , обладает максимальной связностью . Как правило , создавать классы с максимальной связностью не рекомендуется… а скорее всего , это нереально . С другой стороны , связность класса должна быть высокой . Высокая связность означает , что методы и переменные класса взаимозависимы и существуют как единое целое . Рассмотрим реализацию стека из листинга . . Этот класс обладает очень высокой связностью . Из трех его методов только не использует обе переменные . Листинг . . . — класс с высокой связностью . Листинг . продолжение . - - . Стратегия компактных функций и коротких списков параметров иногда приводит к росту переменных экземпляров , используемых подмножеством методов . Это почти всегда свидетельствует о том , что по крайней мере один класс пытается выделиться из более крупного класса . Постарайтесь разделить переменные и методы на два и более класса , чтобы новые классы обладали более высокой связностью . Поддержание связности приводит к уменьшению классов Сам акт разбиения больших функций на меньшие приводит к росту количества классов . Допустим , имеется большая функция , в которой объявлено много переменных . Вы хотите выделить один небольшой фрагмент этой функции в отдельную функцию . Однако выделяемый код использует четыре переменные , объявленные в исходной функции . Может , передать все четыре переменные новой функции в виде аргументов ? Ни в коем случае ! Преобразовав эти четыре переменные в переменные экземпляров класса , мы сможем выделить код без передачи переменных . Таким образом , разбиение функции на меньшие фрагменты упрощается . К сожалению , это также означает , что наши классы теряют связность , потому что в них накапливается все больше переменных экземпляров , созданных исключительно для того , чтобы они могли совместно использоваться небольшим подмножеством функций . Но постойте ! Если группа функций должна работать с некоторыми переменными , не образуют ли они класс сами по себе ? Конечно , образуют . Если классы утрачивают связность , разбейте их ! Таким образом , разбиение большой функции на много мелких функций также часто открывает возможность для выделения нескольких меньших классов . В результате строение программы улучшается , а ее структура становится более прозрачной . Для демонстрации мы воспользуемся проверенным временем примером из замечательной книги Кнута « » . В листинге . представлена программа Кнута , переведенная на . Справедливости ради стоит отметить , что это не та программа , которую написал Кнут , а та , которую выводит его утилита . Я воспользуюсь ей , потому что она является отличной отправной точкой для разбиения большой функции на несколько меньших функций и классов . Листинг . . . - ! Листинг . продолжение . . " " " - - - " . . " " . . " % " , . . " " . . " \ " Записанная в виде одной функции , эта программа представляет собой полную неразбериху . Многоуровневая вложенность , множество странных переменных , структура с жесткой привязкой… По крайней мере , одну большую функцию следует разбить на несколько меньших функций . В листингах . – . показано , что получается после разбиения кода из листинга . на меньшие классы и функции , с выбором осмысленных имен для классов , функций и переменных . Листинг . . . переработанная версия _ _ . _ _ _ _ _ _ _ _ , _ _ , " " _ _ " " . Листинг . . . . . , , . . . . . . - , . - , , , . " \ " , , - , , . " " Листинг . продолжение , , . " % " , , . " - - - " . " " . Листинг . . . . . . . . . . , , , , . . , Прежде всего бросается в глаза , что программа стала значительно длиннее . От одной с небольшим страницы она разрослась почти до трех страниц . Это объясняется несколькими причинами . Во - первых , в переработанной программе используются более длинные , более содержательные имена переменных . Во - вторых , объявления функций и классов в переработанной версии используются для комментирования кода . В третьих , пробелы и дополнительное форматирование обеспечивают удобочитаемость программы . Обратите внимание на логическое разбиение программы в соответствии с тремя основными видами ответственности . Основной код программы содержится в классе он отвечает за управлении средой выполнения . Именно этот код изменится в случае смены механизма вызова . Например , если в будущем программа будет преобразована в службу , то изменения будут внесены в код . Класс специализируется на форматировании списка чисел в страницы с определенным количеством строк и столбцов . Если потребуется изменить формат вывода , то изменения затронут только этот класс . Класс специализируется на построении списка простых чисел . Создание экземпляров этого класса не предполагается . Класс всего лишь определяет удобную область видимости , в которой можно объявлять и скрывать переменные . Он изменится при изменении алгоритма вычисления простых чисел . При этом программа не была переписана ! Мы не начинали работу «с нуля» и не писали код заново . В самом деле , внимательно присмотревшись к двум программам , вы увидите , что они используют одинаковые алгоритмы и одинаковую механику для решения своих задач . Модификация началась с написания тестового пакета , досконально проверявшего поведение первой программы . Далее в код последовательно вносились многочисленные мелкие изменения . После каждого изменения проводились тесты , которые подтверждали , что поведение программы не изменилось . Так , шаг за шагом , первая программа очищалась и трансформировалась во вторую . Структурирование с учетом изменений Большинство систем находится в процессе непрерывных изменений . Каждое изменение создает риск того , что остальные части системы будут работать не так , как мы ожидаем . В чистой системе классы организованы таким образом , чтобы риск от изменений был сведен к минимуму . Класс в листинге . используется для построения правильно сформированных строк по соответствующим метаданным . Работа еще не завершена , поэтому класс не поддерживает многие функции например , команды . Когда придет время включения в класс поддержки , придется «открыть» этот класс для внесения изменений . Но как уже говорилось , открытие класса создает риск . Любые изменения в этом классе создают потенциальную возможность для нарушения работы остального кода класса , поэтому весь код приходится полностью тестировать заново . Листинг . . Класс , который необходимо открыть для внесения изменений , , , , Класс изменяется при добавлении нового типа команды . Кроме того , он будет изменяться при изменении подробностей реализации уже существующего типа команды — скажем , если нам понадобится изменить функциональность для поддержки подчиненной выборки . Две причины для изменения означают , что класс нарушает принцип единой ответственности . Нарушение принципа единой ответственности проявляется и в структуре кода . Из набора методов видно , что класс содержит приватные методы например , , относящиеся только к командам . Приватные методы , действие которых распространяется только на небольшое подмножество класса , — хороший признак для поиска потенциальных усовершенствований . Темне менее основные усилия следует направить на изменение самой системы . Если бы класс выглядел логически завершенным , то нам не пришлось бы беспокоиться о разделении ответственности . Если бы в обозримом будущем функциональность не понадобилась , можно было бы оставить в покое . Но как только выясняется , что класс необходимо открыть , нужно рассмотреть возможность усовершенствования его структуры . Почему бы не воспользоваться решением , представленным в листинге . ? Для каждого метода открытого интерфейса , определенного в предыдущей версии из листинга . , создается соответствующий класс , производный от . При этом приватные методы такие , как перемещаются непосредственно туда , где они понадобятся . Общее приватное поведение изолируется в паре вспомогательных классов , и . Листинг . . Набор закрытых классов , , @ , @ Листинг . продолжение , , @ , , , @ , , , @ , , , @ , @ Код каждого класса становится до смешного простым . Время , необходимое для понимания класса , падает почти до нуля . Вероятность того , что одна из функций нарушит работу другой , ничтожно мала . С точки зрения тестирования проверка всех фрагментов логики в этом решении упрощается , поскольку все классы изолированы друг от друга . Что не менее важно , когда придет время добавления , вам не придется изменять ни один из существующих классов ! Логика построения команды реализуется в новом субклассе с именем . Это изменение не нарушит работу другого кода в системе . Переработанная логика положительна во всех отношениях . Она поддерживает принцип единой ответственности . Она также поддерживает другой ключевой принцип проектирования классов в ООП , называемый принципом открытости закрытости : классы должны быть открыты для расширений , но закрыты для модификации . Наш переработанный класс открыт для добавления новой функциональности посредством создания производных классов , но при внесении этого изменения все остальные классы остаются закрытыми . Новый класс просто размещается в положенном месте . Структура системы должна быть такой , чтобы обновление системы с добавлением новых или изменением существующих аспектов создавало как можно меньше проблем . В идеале новая функциональность должна реализовываться расширением системы , а не внесением изменений в существующий код . Изоляция изменений Потребности меняются со временем следовательно , меняется и код . В начальном курсе объектно - ориентированного программирования мы узнали , что классы делятся на конкретные , содержащие подробности реализации код , и абстрактные , представляющие только концепции . Если клиентский класс зависит от конкретных подробностей , то изменение этих подробностей может нарушить его работоспособность . Чтобы изолировать воздействие этих подробностей на класс , в систему вводятся интерфейсы и абстрактные классы . Зависимости от конкретики создает проблемы при тестировании системы . Если мы строим класс , зависящий от внешнего для вычисления текущей стоимости портфеля ценных бумаг , наши тестовые сценарии начинают зависеть от ненадежного внешнего фактора . Трудно написать тест , если вы получаете разные ответы каждые пять минут ! Вместо того чтобы проектировать с прямой зависимостью от , мы создаем интерфейс , в котором объявляется один метод : Класс проектируется с расчетом на реализацию этого интерфейса . При ссылке на передается в аргументе конструктора : . … Теперь наш тест может создать пригодную для тестирования реализацию интерфейса , эмулирующую реальный . Тестовая реализация задает текущую стоимость каждого вида акций , используемых при тестировании . Если тест демонстрирует приобретение пяти акций , мы кодируем тестовую реализацию так , чтобы для всегда возвращалась стоимость $ за акцию . Тестовая реализация интерфейса сводится к простому поиску по таблице . После этого пишется тест , который долженвернуть общую стоимость портфеля в $ : @ . " " , @ . , " " . , . Если система обладает достаточной логической изоляцией для подобного тестирования , она также становится более гибкой и более подходящей для повторного использования . Отсутствие жестких привязок означает , что элементы системы лучше изолируются друг от друга и от изменений . Изоляция упрощает понимание каждого элемента системы . Сведение к минимуму логических привязок соответствует другому принципу проектирования классов , известному какпринцип обращения зависимостей , . По сути гласит , что классы системы должны зависеть от абстракций , а не от конкретных подробностей . Вместо того чтобы зависеть от подробностей реализации класса , наш класс теперь зависит от интерфейса . Интерфейс представляет абстрактную концепцию запроса текущей стоимости акций . Эта абстракция изолирует класс от конкретных подробностей получения такой цены — в том числе и от источника , из которого берется реальная информация . Литература : : , , , - . , - , . : : , , , . , , . : , . , , , . Глава . СистемыКевин Дин Уомплер Картинка : _ . Сложность убивает . Она вытягивает жизненные силы из разработчиков , затрудняя планирование , построение и тестирование продуктов . Рэй Оззи , технический директор Как бы вы строили город ? Смогли бы вы лично разработать план до последней мелочи ? Вероятно , нет . Даже управление существующим городом не под силу одному человеку . Да , города работают в основном . Они работают , потому что в городах есть группы людей , управляющие определенными аспектами городской жизни : водопроводом , электричеством , транспортом , соблюдением законности , правилами застройки и т . д . Одни отвечают за общую картину , другие занимаются мелочами . Города работают еще и потому , что в них развились правильные уровни абстракции и модульности , которые обеспечивают эффективную работу людей и «компонентов» , находящихся под их управлением , — даже без понимания полной картины . Группы разработки программного обеспечения тоже организуются по аналогичным принципам , но системы , над которыми они работают , часто не имеют аналогичного разделения обязанностей и уровней абстракции . Чистый код помогает достичь этой цели на нижних уровнях абстракции . В этой главе мы поговорим о том , как сохранить чистоту на более высоких уровнях , то есть на уровнесистемы . Отделение конструирования системы от ее использования Прежде всего необходимо понять , что конструирование и использование системы — два совершенно разных процесса . Когда я пишу эти строки , из моего окна в Чикаго виден новый строящийся отель . Сейчас это голая бетонная коробка со строительным краном и лифтом , закрепленным на наружной стене . Все рабочие носят каски и спецовки . Через год - другой строительство будет завершено . Кран и служебный лифт исчезнут . Здание очистится , заблестит стеклянными окнами и новой краской . Люди , работающие и останавливающиеся в нем , тоже будут выглядеть совершенно иначе . В программных системах фаза инициализации , в которой конструируются объекты приложения и «склеиваются» основные зависимости , тоже должна отделяться от логики времени выполнения , получающей управление после ее завершения . Фазаинициализацииприсутствует в каждом приложении . Это первая изобластей ответственности , которую мы рассмотрим в этой главе , а сама концепцияразделения ответственностиотносится к числу самых старых и важных приемов нашего ремесла . К сожалению , во многих приложениях такое разделение отсутствует . Код инициализации пишется бессистемно и смешивается с логикой времени выполнения . Типичный пример : … Инициализация по умолчанию , подходящая для большинства случаев ? Идиома ОТЛОЖЕННОЙ ИНИЦИАЛИЗАЦИИ обладает определенными достоинствами . Приложение не тратит времени на конструирование объекта до момента его фактического использования , а это может ускорить процесс инициализации . Кроме того , мы следим за тем , чтобы функция никогда не возвращала . Однако в программе появляется жестко закодированная зависимость от класса и всего , что необходимо для его конструктора который я не привел . Программа не компилируется без разрешения этих зависимостей , даже если объект этого типа ни разу не используется во время выполнения ! Проблемы могут возникнуть и при тестировании . Если представляет собой тяжеловесный объект , нам придется позаботиться о том , чтобы перед вызовом метода в ходе модульного тестирования в поле был сохранен соответствующий ТЕСТОВЫЙ ДУБЛЕР или ФИКТИВНЫЙ ОБЪЕКТ . А поскольку логика конструирования смешана с логикой нормальной обработки , мы должны протестировать все пути выполнения в частности , проверку и ее блок . Наличие обеих обязанностей означает , что метод выполняет более одной операции , а это указывает на некоторое нарушение принципа единой ответственности . Но хуже всего другое — мы не знаем , является ли правильным объектом во всех случаях . Я намекнул на это в комментарии . Почему класс с этим методом должен знать глобальный контекст ? Можем ли мы вообще определить , какой объект должен здесь использоваться ? И вообще , может ли один тип быть подходящим для всех возможных контекстов ? Конечно , одно вхождение ОТЛОЖЕННОЙ ИНИЦИАЛИЗАЦИИ не создает серьезных проблем . Однако в приложениях идиомы инициализации обычно встречаются во множество экземпляров . Таким образом , глобальная стратегия инициализации если она здесь вообще присутствует распределяется по всему приложению , с минимальной модульностью и значительным дублированием кода . Если вы действительно стремитесь к созданию хорошо структурированных , надежных систем , никогда не допускайте , чтобы удобные идиомы вели к нарушению модульности . Процесс конструирования объектов и установления связей не является исключением . Этот процесс должен быть отделен от нормальной логики времени выполнения , а вы должны позаботиться о выработке глобальной , последовательной стратегии разрешения основных зависимостей . Отделение Один из способов отделения конструирования от использования заключается в простом перемещении всех аспектов конструирования в или модули , вызываемые из . Далее весь остальной код системы пишется в предположении , что все объекты были успешно сконструированы и правильно связаны друг с другом рис . . . Картинка : _ . Рис . . . Изоляция конструирования в На рисунке хорошо видна последовательность передачи управления . Функция строит объекты , необходимые для системы , а затем передает их приложению , которое их просто использует . Обратите внимание на направление стрелок зависимостей , пересекающих границу между и приложением . Все стрелки указывают в одном направлении — от . Это означает , что приложение ничего не знает о или о процессе конструирования . Оно просто ожидает , что все объекты были построены правильно . Фабрики Конечно , в некоторых ситуациях момент создания объекта должен определяться приложением . Например , в системе обработки заказов приложение должно создать экземпляры товаров для включения их в объект заказа . В этом случае можно воспользоваться паттерном АБСТРАКТНАЯ ФАБРИКА , чтобы приложение могло само выбрать момент для создания , но при этом подробности конструирования были отделены от кода приложения рис . . . И снова обратите внимание на то , что все стрелки зависимостей ведут от к приложению . Это означает , что приложение изолировано от подробностей построения . Вся информация хранится в реализации , находящейся на стороне . Тем не менее приложение полностью управляет моментом создания экземпляров и даже может передать аргументы конструктора , специфические для конкретного приложения . Картинка : _ . Рис . . . Отделение конструирования с применением фабрики Внедрение зависимостей Внедрение зависимостей , — мощный механизм отделения конструирования от использования , практическое применение обращения контроля , в области управления зависимостями . Обращение контроля перемещает вторичные обязанности объекта в другие объекты , созданные специально для этой цели , тем самым способствуя соблюдению принципа единой ответственности . В контексте управления зависимостями объект не должен брать на себя ответственность за создание экземпляров зависимостей . Вместо этого он передает эту обязанность другому «уполномоченному» механизму . Так как инициализация является глобальной областью ответственности , этим уполномоченным механизмом обычно является либо функция , либо специализированныйконтейнер . Примером «частичной» реализации внедрения зависимостей является запрос , когда объект обращается к серверу каталоговой информации с запросом на предоставление «сервиса» с заданным именем : . " " Вызывающий объект не управляет тем , какой именно объект будет возвращен конечно , при условии , что этот объект реализует положенный интерфейс , но при этом происходит активное разрешение зависимости . Истинное внедрение зависимостей идет еще на один шаг вперед . Класс не предпринимает непосредственных действий по разрешению своих зависимостей он остается абсолютно пассивным . Вместо этого он предоставляет - методы и или аргументы конструктора , используемые для внедрения зависимостей . В процессе конструирования контейнер создает экземпляры необходимых объектов обычно по требованию и использует аргументы конструктора или - методы для скрепления зависимостей . Фактически используемые зависимые объекты задаются в конфигурационном файле или на программном уровне в специализированном конструирующем модуле . Самый известный - контейнер для присутствует в . Подключаемые объекты перечисляются в конфигурационном файле , после чего конкретный объект запрашивается по имени в коде . Пример будет рассмотрен ниже . Но как же преимущества ОТЛОЖЕННОЙ ИНИЦИАЛИЗАЦИИ ? Эта идиома иногда бывает полезной и при внедрении зависимостей . Во - первых , большинство - контейнеров не конструирует объекты до того момента , когда это станет необходимо . Во - вторых , многие из этих контейнеров предоставляют механизмы использования фабрик или конструирования посредников , которые могут использоваться для ОТЛОЖЕННОЙ ИНИЦИАЛИЗАЦИИ и других аналогичных оптимизаций . Масштабирование Города вырастают из городков , которые , в свою очередь , появляются на месте деревень . Дороги сначала узки и едва заметны , но со временем они расширяются и покрываются камнем . Мелкие строения и пустые места заполняются более крупными зданиями , часть из которых в конечном итоге будет заменена небоскребами . На первых порах в городе полностью отсутствует инфраструктура : водопровод , электричество , канализация и о ужас ! Интернет . Все эти возможности добавляются позднее , с ростом населения и плотности застройки . Рост не обходится без проблем . Сколько раз вам приходилось едва ползти в потоке машин вдоль проекта по «расширению дороги» , когда вы спрашивали себя : «Почему нельзя было сразу построить дорогу достаточной ширины ? ! » Но иначе и быть не могло . Кто сможет объяснить затраты на строительство шестиполосной магистрали в середине маленького городка , которому предрекают расширение ? Да и кто бы захотел иметь такую дорогу в своем городе ? Возможность построить «правильную систему с первого раза» — миф . Вместо этого мы сегодня реализуем текущие потребности , а завтра перерабатываем и расширяем систему для реализации новых потребностей . В этом заключается суть итеративной , пошаговой гибкой разработки . Разработка через тестирование , рефакторинг и полученный врезультате их применения чистый код обеспечивают работу этой схемы на уровне кода . А как же системный уровень ? Разве архитектура системы не требует предварительного планирования ? Не может же она последовательно расти от простого к сложному ? В этом проявляется важнейшее отличие программных систем от физических . Архитектура программных системможетразвиваться последовательно , если обеспечить правильное разделение ответственности . Как вы вскоре убедитесь , нематериальная природа программных систем делает это возможным . Но давайте начнем с контрпримера архитектуры , в которой нормальное разделение ответственности отсутствует . Исходные архитектуры и не обеспечивали должного разделения областей ответственности и поэтому создавали лишние барьеры для естественного роста . Возьмем хотя быкомпонент - сущность для постоянного класса . Компонентом - сущностью называется представление реляционных данных иначе говоря , записи таблицы в памяти . Для начала необходимо определить локальный внутрипроцессный или удаленный на отдельной интерфейс , который будет использоваться клиентами . Возможный локальный интерфейс представлен в листинге . . Листинг . . Локальный интерфейс для . . . . . . . . В интерфейс включены некоторые атрибуты адреса , а также коллекция счетов , принадлежащих банку данные каждого счета представляются отдельным . В листинге . приведен соответствующий класс реализации компонента . Листинг . . Соответствующая реализация компонента - сущности . . . . . . . . Бизнес - логика … . " " . . Логика контейнера … … Остальные методы должны быть реализованы , но обычно остаются пустыми : В листинге не приведен ни соответствующий интерфейс по сути — фабрика , используемая для создания объектов , ни один из возможных методов поиска , которые вы можете добавить . Наконец , вы должны написать один или несколько дескрипторов в формате , которые определяют подробности соответствия между объектом и реляционными данными , желаемое транзакционное поведение , ограничения безопасности и т . д . Бизнес - логика тесно привязана к «контейнеру» приложения . Вы должны субклассировать контейнерные типы , а также предоставить многие методы жизненного цикла , необходимые для контейнера . Привязка к тяжеловесному контейнеру затрудняет изолированное модульное тестирование . Приходится либо имитировать контейнер , что непросто , либо тратить много времени на развертывание и тестов на реальном сервере . Повторное использование за пределами архитектуры практически невозможно из - за жесткой привязки . Наконец , такое решение противоречит принципам объектно - ориентированного программирования . Один компонент не может наследовать от другого компонента . Обратите внимание на логику добавления новогосчета . В компоненты часто определяют «объекты передачи данных» , которые фактически представляют собой «структуры без поведения» . Обычно это приводит к появлению избыточных типов , содержащих по сути одинаковые данные , и необходимости использования стереотипного кода для копирования данных между объектами . Поперечные области ответственности В некоторых областях архитектура приближается к полноценному разделению ответственности . Например , желательное поведение в области транзакционности , безопасности и сохранения объектов объявляется в дескрипторах независимо от исходного кода . Такие области , как сохранение объектов , выходят за рамки естественных границ объектов предметной области . Например , все объекты обычно сохраняются по одной стратегии , с использованием определенной СУБД вместо неструктурированных файлов , с определенной схемой выбора имен таблиц и столбцов , единой транзакционной семантикой и т . д . Теоретически возможен модульный , инкапсулированный подход к определению стратегии сохранения объектов . Однако на практике вам приходится повторять по сути одинаковый код , реализующий стратегию сохранения , во многих объектах . Для подобных областей используется термин «поперечные области ответственности» . При этом инфраструктура сохранения может быть модульной , и логика предметной области , рассматриваемая в изоляции , тоже может быть модульной . Проблемы возникаютв точках пересечения этих областей . Можно сказать , что подход , использованный в архитектуре по отношению к сохранению объектов , безопасности и транзакциям , предвосхитиласпектно - ориентированное программирование АОП , которое представляет собой универсальный подход к восстановлению модульности для поперечных областей ответственности . В АОП специальные модульные конструкции , называемыеаспектами , определяют , в каких точках системы поведение должно меняться некоторым последовательным образом в соответствии с потребностями определенной области ответственности . Определение осуществляется на уровне декларативного или программного механизма . В примере с сохранением объектов вы объявляете , какие объекты , атрибуты и т . д . должны сохраняться , а затем делегируете задачи сохранения своей инфраструктуре сохранения . Изменения в поведении вносятся инфраструктурой АОП без вмешательства в целевой код . Рассмотрим три аспекта или «аспекто - подобных» механизма в . Посредники Посредники хорошо подходят для простых ситуаций — например , для создания «оберток» для вызова методов отдельных объектов или классов . Тем не менее динамические посредники , содержащиеся в , работают только с интерфейсами . Чтобы создать посредника для класса , приходится использовать библиотеки для выполнения манипуляций с байт - кодом — такие , как , или . В листинге . приведена заготовка посредника , обеспечивающего поддержку сохранения объектов в нашем приложении представлены только методы чтения записи списка счетов . Листинг . . Пример посредника . подавление имен пакетов … . . Абстрактное представление банка . . . . - объект " " , реализующий абстракцию . . : . . . . . . . . Реализация , необходимая для посредника . . Метод , определенный в , , . . " " . . . " " . . … Подробности : … … В другом месте … . . . , . , Мы определили интерфейс , который будет инкапсулироваться посредником , и - объект « » , то есть «обычный - объект» , реализующий бизнес - логику . Вскоре мы вернемся к теме - объектов . Для работы посредника необходим объект , который вызывается для реализации всех вызовов методов , обращенных к посреднику . Наша реализация использует механизм рефлексии для отображения вызовов обобщенных методов на соответствующие методы . Код получаетсявесьмаобъемистым и относительно сложным , даже в этом простом случае . Не меньше проблем создает и использование библиотек для манипуляций с байт - кодом . Объем и сложность кода — два основных недостатка посредников . Эти два фактора усложняют создание чистого кода ! Кроме того , у посредников не существует механизма определения «точек интереса» общесистемного уровня , необходимых для полноценногоАОП - решения . АОП - инфраструктуры на «чистом» К счастью , большая часть шаблонного кода посредников может автоматически обрабатываться вспомогательными средствами . Посредники используются во внутренней реализации нескольких инфраструктур — например , и — для реализации аспектов непосредственно на уровне . В бизнес - логика записывается в форме - объектов . Такие объекты полностью сосредоточены на своей предметной области . Они не имеют зависимостей во внешних инфраструктурах или любых других областях соответственно им присуща большая концептуальная простота и удобство тестирования . Благодаря относительной простоте вам будет проще обеспечить правильную реализацию соответствующих пожеланий пользователей , а также сопровождение и эволюцию кода при появлении новых пожеланий . Вся необходимая инфраструктура приложения , включая поперечные области ответственности сохранение объектов , транзакции , безопасность , кэширование , преодоление отказов и т . д . , определяется при помощи декларативных конфигурационных файлов или . Во многих случаях вы фактически определяете аспекты библиотек или , а инфраструктура берет на себя всю механику использования посредников или библиотек байт - кода в режиме , прозрачном для пользователя . Объявления управляют контейнером внедрения зависимостей , который создает экземпляры основных объектов и связывает их по мере необходимости . В листинге . приведен типичный фрагмент конфигурационного файла . . . Листинг . . Конфигурационный файл . … " " " . . . . " - " " : " . . . " : " : : : " : " " " " " . . . . " : - " " " " " . . . . " : - " " … Каждый компонент напоминает одну из частей русской «матрешки» : объект предметной области «упаковывается» в объект доступа к данным , который , в свою очередь , упаковывается в объект источника данных рис . . . Картинка : _ . Рис . . . «Матрешка» из декораторов Клиент полагает , что он вызывает метод объекта , но в действительности он взаимодействует с внешним объектом из набора вложенных ДЕКОРАТОРОВ , расширяющих базовое поведение - объекта . Мы могли бы добавить другие декораторы для транзакций , кэширования и т . д . Чтобы запросить у - контейнера объекты верхнего уровня , заданные в файле , достаточно включить в приложение несколько строк : " . " , . " " Так как объем кода , специфического для , минимален , приложение почти полностью изолировано от . Тем самым устраняются все проблемы жесткой привязки , характерные для таких систем , как . Хотя код занимает много места и плохо читается , определяемая в этих конфигурационных файлах «политика» все же проще сложной логики посредников и аспектов , скрытой от наших глаз и создаваемой автоматически . Архитектура выглядит настолько заманчиво , что инфраструктуры вроде привели к полной переработке стандарта для версии . в значительной мере следует характерной для модели декларативной поддержки поперечных областей ответственности с использованием конфигурационных файлов и или аннотаций . В листинге . приведен объект , переписанный для . Листинг . . Компонент для . . . . . . . . . @ @ " " . . @ @ . @ Объект " встраивается " в запись базы данных @ @ . , . , " " . . . . Этот вариант кода намного чище исходного кода . Некоторые подробности о сущностях все еще присутствуют в аннотациях . Тем не менее , поскольку эта информация не выходит за пределы аннотаций , код остается чистым , понятным , а следовательно , простым в тестировании , сопровождении и т . д . Часть информации о сохранении объектов , содержащейся в аннотациях , можно при желании переместить в дескрипторы , оставив действительно чистый - объект . Если детали сохранения объектов изменяются относительно редко , многие группы отдадут предпочтение аннотациям , но с гораздо меньшими отрицательными последствиями по сравнению с . Аспекты Наконец , самым полнофункциональным инструментом для разделения областей ответственности посредством использования аспектов является язык — расширение , предоставляющее «полноценную» поддержку аспектов как модульных конструкций . Чистых - решений на базе и достаточно для – % ситуаций , в которых применяются аспекты . Тем не менее предоставляет очень мощный и разносторонний инструментарий для реализации разделения ответственности . Недостатком является необходимость освоения нескольких новых инструментов , а также изучения новых языковых конструкций и идиом . Эти проблемы отчасти компенсируются появившейся недавно «аннотационной» формой , в которой аннотации используются для определения аспектов в «чистом» коде . Кроме того , также содержит ряд функций , существенно упрощающих внедрение аспектов на базе аннотаций в рабочих группах с ограниченным опытом применения . Полное описание выходит за рамки книги . За дополнительной информацией обращайтесь к , и . Испытание системной архитектуры Трудно переоценить потенциал разделения ответственности посредством аспектных решений . Если вы можете написать логику предметной области своего приложения в виде - объектов , отделенных от любых архитектурных областей ответственности на кодовом уровне , то перед вами открывается возможность проведения полноценных испытаний вашей архитектуры . Вы сможете развивать ее от простого к сложному , как потребует ситуация , подбирая новые технологии по мере надобности . Не обязательно создавать Большой Изначальный Проект , . Более того , это даже вредно , потому что снижает возможность адаптации к изменениям из - за нашего психологического нежелания расставаться с результатами уже затраченных усилий кроме того , изначально принятые решения влияют на наши последующие представления об архитектуре . Архитекторы , занимающиеся строительством зданий , вынуждены работать по принципу , потому что они не могут вносить радикальные архитектурные изменения в наполовину возведенное физическое строение . Программные продукты тоже обладают собственной физикой , но радикальные изменения в них могут оказаться экономически оправданными — при условии , что в программном проекте эффективно реализовано разделение ответственности . Это означает , что мы можем начать программный проект с «простой до наивности» , но лишенной жестких привязок архитектуры , быстро реализовать пожелания пользователей , а затем добавлять новую инфраструктуру по мере масштабирования . Некоторые из крупнейших мировых сайтов достигли высочайших показателей доступности и производительности , с применением сложного кэширования данных , безопасности , виртуализации и т . д . , и все это делается эффективно и гибко — и только потому , что на каждом уровне абстракции их архитектура оставалась простой и обладала минимальными привязками . Конечно , это не означает , что за проект нужно браться по принципу «как - нибудь по ходу разберемся» . Вы уже в определенной степени представляете себе общий масштаб , цели и график проекта , а также общую структуру итоговой системы . Однако при этом необходимо сохранить возможность «смены курса» в соответствии с изменяющимися обстоятельствами . Ранняя архитектура была всего лишь одним из многих , которые отличались излишней сложностью , нарушавшей принцип разделения ответственности . Впрочем , даже хорошо спроектированный может оказаться «перебором» в конкретной ситуации , если его применение не объясняется реальной необходимостью . Хороший должен исчезать из вида большую часть времени , чтобы большая часть творческих усилий группы расходовалась на реализацию пожеланий пользователей . В противном случае архитектурныеограничения помешают оптимальной реализации интересов клиента . Подведем итог . Оптимальная архитектура системы состоит из модульных областей ответственности , каждая из которых реализуется на базе - объектов . Области интегрируются между собой при помощи аспектов или аналогичных средств , минимальным образом вмешивающихся в их работу . Такая архитектура может строиться на базе методологии разработки через тестирование , как и программный код . Оптимизация принятия решений Модульность и разделение ответственности позволяют децентрализовать управление и принятие решений . В достаточно крупной системе , будь то город или программный проект , один человек не может принять все необходимые решения . Как известно , ответственные решения лучше всего поручить самому квалифицированному . Однако мы часто забываем , что принятие решений лучше всего откладывать до последнего момента . Дело не в лени или безответственности просто это позволяет принять информированное решение с максимумом возможной информации . Преждевременное решение принимается на базе неполной информации . Принимая решение слишком рано , мы лишаемся всего полезного , что происходит на более поздних стадиях : обратной связиот клиентов , возможности поразмышлять над текущим состоянием проекта и опыта применения решений из области реализации . Гибкость - системы с модульными областями ответственности позволяет принимать оптимальные , своевременные решения на базе новейшей информации . Кроме того , она способствует снижению сложности таких решений . Применяйте стандарты разумно , когда они приносяточевиднуюпользу Строительство кажется настоящим чудом из - за темпов , которым возводятся новые здания даже в разгар зимы , и из - за необычных архитектурных дизайнов , ставших возможными благодаря современным технологиям . Строительство стало развитой областью промышленности с высокой оптимизацией частей , методов и стандартов , сформированных под давлением времени . Многие группы использовали архитектуру только потому , что она считалась стандартом , даже если в их проектах хватило бы более легких и прямолинейных решений . Я видел группы , которые теряли голову отразрекламированныхстандартов и забывали о своей главной задаче : реализовывать интересы клиента . Стандарты упрощают повторное использование идей и компонентов , привлечение людей с необходимым опытом , воплощение удачных идей и связывание компонентов . Тем не менее , процесс создания стандарта иногда занимает слишком много времени а отрасль не стоит на месте , в результате чего стандарты теряют связь с реальными потребностями тех людей , которым они должны служить . Системам необходимы предметно - ориентированные языки В области строительства , как и в большинстве технических областей , сформировался богатый язык со своим словарем , идиомами и паттернами , позволяющими четко и лаконично передать важную информацию . В области разработки программного обеспечения в последнее время снова возобновился интерес к предметно - ориентированным языкам , - — отдельным маленьким сценарным языкам или стандартных языков , код которых читается как структурированная форма текста , написанного экспертом в данной предметной области . Хороший предметно - ориентированный язык сводит к минимуму «коммуникационный разрыв» между концепцией предметной области и кодом , реализующим эту концепцию — по аналогии с тем , как гибкие методологии оптимизируют обмен информацией между группой и ключевыми участниками проекта . Реализация логики предметной области на языке , используемом экспертом в этой области , снижает риск неверного представления предметной области в коде . Предметно - ориентированные языки , когда они используются эффективно , поднимают уровень абстракции над программными идиомами и паттернами проектирования . Они позволяют разработчику выразить свои намерения на соответствующем уровне абстракции . Предметно - ориентированные языки позволяют выразить в форме - объектов все уровни абстракции и все предметные области приложения , от высокоуровневых политик до низкоуровневых технических подробностей . Заключение Чистым должен быть не только код , но и архитектура системы . Агрессивная , «всепроникающая» архитектура скрывает логику предметной области и снижает гибкость . Первое приводит к снижению качества : ошибкам проще спрятаться в коде , а разработчику труднее реализовать пожелания пользователей . Второе оборачивается снижением производительности , а также потерей всех преимуществ . Намерения разработчика должны быть четко выражены на всех уровнях абстракции . Это произойдет только в том случае , если он создает - объекты , и использует аспекты или другие аналогичные механизмы для неагрессивного воплощения других сторон реализации . Независимо от того , проектируете ли вы целую систему или ее отдельные модули , помните : используйте самое простое решение из всех возможных . Литература : , , , , . : - , : . : , : . . : : . : , : . . : , , , , , , . , , , . : - , : . . - _ _ : , : . . : , : , : . . - . : , : . . . . . ~ : , : . : — , : . : . , , — , , , . – , . : , : . . : , , - , . : : , . , - , . Глава . Формирование архитектурыДжефф Лангр Картинка : _ . Четыре правила Разве не хотелось бы вам знать четыре простых правила , выполнение которых помогало бы повысить качество проектирования ? Четыре правила , помогающих составить представление о важнейших особенностях структуры и архитектуры кода , упрощающих применение таких принципов , как принцип единой ответственности и принцип обращения зависимостей ? Четыре правила , способствующих формированию хороших архитектур ? Многие полагают , что четыре правилапростой архитектуры Кента Бека оказывают значительную помощь в проектировании программных продуктов . Согласно Кенту , архитектура может считаться «простой» , если она : • обеспечивает прохождение всех тестов , • не содержит дублирующегося кода , • выражает намерения программиста , • использует минимальное количество классов и методов . Правила приведены в порядке их важности . Правило № : выполнение всех тестов Прежде всего система должна делать то , что задумано ее проектировщиком . Система может быть отлично спланирована «на бумаге» , но если не существует простого способа убедиться в том , что она действительно решает свои задачи , то результат выглядит сомнительно . Система , тщательно протестированная и прошедшая все тесты , контролируема . На первый взгляд утверждение кажется очевидным , но это весьма важно . Невозможно проверить работу системы , которая не является контролируемой , а непроверенные системы не должны запускаться в эксплуатацию . К счастью , стремление к контролируемости системы ведет к архитектуре с компактными узкоспециализированными классами . Все просто : классы , соответствующие принципу , проще тестировать . Чем больше тестов мы напишем , тем дальше продвинемся к простоте тестирования . Таким образом , обеспечение полной контролируемости системы помогает повысить качество проектирования . Жесткая привязка усложняет написание тестов . Таким образом , чем больше тестов мы пишем , тем интенсивнее используем такие принципы , как , и такие инструменты , как внедрение зависимостей , интерфейсы и абстракции , для минимизации привязок . Как ни удивительно , выполнение простого и очевидного правила , гласящего , что для системы необходимо написать тесты и постоянно выполнять их , влияет на соответствие системы важнейшим критериям объектно - ориентированного программирования : устранению жестких привязок и повышению связности . Написание тестов улучшает архитектуру системы . Правила № – : переработка кода Когда у вас появился полный набор тестов , можно заняться чисткой кода и классов . Для этого код подвергается последовательной переработке рефакторингу . Мы добавляем несколько строк кода , делаем паузу и анализируем новую архитектуру . Не ухудшилась ли она по сравнению с предыдущим вариантом ? Если ухудшилась , то мы чистим код итестируем его , чтобы убедиться , что в нем ничего не испорчено . Наличие тестов избавляет от опасений , что чистка кода нарушит его работу ! В фазе переработки применяется абсолютно все , что вы знаете о качественном проектировании программных продуктов . В ход идут любые приемы : повышение связности , устранение жестких привязок , разделение ответственности , изоляция системных областей ответственности , сокращение объема функций и классов , выбор более содержательных имен и т . д . Также применяются три критерия простой архитектуры : устранение дубликатов , обеспечение выразительности и минимизация количества классов и методов . Отсутствие дублирования Дублирование — главный враг хорошо спроектированной системы . Его последствия — лишняя работа , лишний риск и лишняя избыточная сложность . Дублирование проявляется во многих формах . Конечно , точное совпадение строк кода свидетельствует о дублировании . Похожие строки часто удается «причесать» так , чтобы сходство стало еще более очевидным это упростит рефакторинг . Кроме того , дублирование может существовать и в других формах — таких , как дублирование реализации . Например , класс коллекции может содержать следующие методы : Методы могут иметь разные реализации . Допустим , метод может использовать логический флаг , а — счетчик элементов . Однако мы можем устранить дублирование , связав с определением : Чтобы создать чистую систему , необходимо сознательно стремиться к устранению дубликатов , пусть даже всего в нескольких строках кода . Для примера рассмотрим следующий код : , . - . . . , , . . . , . . Чтобы обеспечить чистоту системы , следует устранить незначительное дублирование между методами и : , . - . . . , , . , . . В ходе выделения общности конструкций на этом микроскопическом уровне начинают проявляться нарушения принципа . Таким образом , только что сформированный метод можно переместить в другой класс . Это расширяет видимость метода . Другой участник группы может найти возможность дальнейшего абстрагирования нового метода и его использования в другом контексте . Таким образом , принцип «повторного использования даже в мелочах» может привести к значительному сокращению сложности системы . Понимание того , как обеспечить повторное использование в мелочах , абсолютно необходимо для его обеспечения в большом масштабе . Паттерн ШАБЛОННЫЙ МЕТОД относится к числу стандартных приемов устранения высокоуровневого дублирования . Пример : Код вычисления продолжительности отпуска по количеству отработанных часов … Код проверки минимальной продолжительности отпуска по стандартам США … Код внесения отпуска в платежную ведомость … Код вычисления продолжительности отпуска по количеству отработанных часов … Код проверки минимальной продолжительности отпуска по европейским стандартам … Код внесения отпуска в платежную ведомость … Код и в основном совпадает , если не считать проверки минимальной продолжительности . Этот фрагмент алгоритма изменяется в зависимости от типа работника . Для устранения этого очевидного дублирования можно воспользоваться паттерном ШАБЛОННЫЙ МЕТОД : … … @ Логика для США @ Логика для Европы Субклассы «заполняют пробел» в обобщенном алгоритме они предоставляют только ту информацию , которая различается в специализированных версиях алгоритма . Выразительность Большинству читателей доводилось работать с запутанным кодом . Многие из них создавали запутанный код сами . Легко написать код , понятный для нас самих , потому что вмомент его написания мы глубоко понимаем решаемую проблему . У других программистов , которые будут заниматься сопровождением этого кода , такого понимания не будет . Основные затраты программного проекта связаны с его долгосрочным сопровождением . Чтобы свести к минимуму риск появления дефектов в ходе внесения изменений , очень важно понимать , как работает система . С ростом сложности системы разработчику приходится разбираться все дольше и дольше , а вероятность того , что он поймет что - то неправильно , только возрастает . Следовательно , код должен четко выражать намерения своего автора . Чем понятнее будет код , тем меньше времени понадобится другим программистам , чтобы разобраться в нем . Это способствует уменьшению количества дефектов и снижению затрат на сопровождение . Хороший выбор имен помогает выразить ваши намерения . Имя класса или функции должно восприниматься «на слух» , а когда читатель разбирается в том , что делает класс , это не должно вызывать у него удивления . Относительно небольшой размер функций и классов также помогает выразить ваши намерения . Компактным классам и функциям проще присваивать имена они легко пишутся и в них легко разобраться . Стандартная номенклатура также способствует выражению намерений автора . В частности , передача информация и выразительность являются важнейшими целями для применения паттернов проектирования . Включение стандартных названий паттернов например , КОМАНДА или ПОСЕТИТЕЛЬ в имена классов , реализующих эти паттерны , помогает кратко описать вашу архитектуру для других разработчиков . Хорошо написанные модульные тесты тоже выразительны . Они могут рассматриваться как разновидность документации , построенная на конкретных примерах . Читая код тестов , разработчик должен составить хотя бы общее представление о том , что делает класс . И все же самое важное , что можно сделать для создания выразительного кода — этопостаратьсясделать его выразительным . Как только наш код заработает , мы обычно переходим к следующей задаче , не прикладывая особых усилий к тому , чтобы код легко читался другими людьми . Но помните : следующим человеком , которому придется разбираться в вашем коде , с большой вероятностью окажетесь вы сами . Так что уделите немного внимания качеству исполнения своего продукта . Немного поразмыслите над каждой функцией и классом . Попробуйте улучшить имена , разбейте большие функции на меньшие и вообще проявите заботу о том , что вы создали . Неравнодушие — воистину драгоценный ресурс . Минимум классов и методов Даже такие фундаментальные концепции , как устранение дубликатов , выразительность кода и принцип единой ответственности , могут зайти слишком далеко . Стремясь уменьшить объем кода наших классов и методов , мы можем наплодить слишком много крошечных классов и методов . Это правило рекомендует ограничиться небольшим количеством функций и классов . Многочисленность классов и методов иногда является результатом бессмысленного догматизма . В качестве примера можно привести стандарт кодирования , который требует создания интерфейса для каждого без исключения класса . Или разработчиков , настаивающих , что поля данных и поведение всегда должны быть разделены на классы данных и классы поведения . Избегайте подобных догм , а в своей работе руководствуйтесь более прагматичным подходом . Наша цель — сделать так , чтобы система была компактной , но при этом одновременно сохранить компактность функций и классов . Однако следует помнить , что из четырех правил простой архитектуры это правило обладает наименьшим приоритетом . Свести к минимуму количество функций и классов важно , однако прохождение тестов , устранение дубликатов и выразительность кода все же важнее . Заключение Может ли набор простых правил заменить практический опыт ? Нет , конечно . С другой стороны , правила , описанные в этой главе и в книге , представляют собой кристаллизованную форму многих десятилетий практического опыта авторов . Принципы простой архитектуры помогают разработчикам следовать по тому пути , который им пришлось бы самостоятельно прокладывать в течение многих лет . Литература : : , , - , . : : , . , - , . Глава . МногопоточностьБретт Л . Шухерт Картинка : _ . Объекты — абстракции для обработки данных . Программные потоки — абстракции для планирования . Джеймс О . Коплиен Написать чистую многопоточную программу трудно — очень трудно . Гораздо проще писать код , выполняемый в одном программном потоке . Многопоточный код часто выглядит нормально на первый взгляд , но содержит дефекты на более глубоком уровне . Такой код работает нормально до тех пор , пока система не заработает с повышенной нагрузкой . В этой главе мы поговорим о том , почему необходимо многопоточное программирование и какие трудности оно создает . Далее будут представлены рекомендации относительно того , как справиться с этими трудностями и как написать чистый многопоточный код . В завершение главы рассматриваются проблемы тестирования многопоточного кода . Чистый многопоточный код — сложная тема , по которой вполне можно было бы написать отдельную книгу . В этой главе приводится обзор , а более подробный учебный материал содержится в приложении «Многопоточность » на с . . Если вы хотите получить общее представление о многопоточности , этой главы будет достаточно . Чтобы разобраться в теме на более глубоком уровне , читайте вторую главу . Зачем нужна многопоточность ? Многопоточное программирование может рассматриваться как стратегия устранения привязок . Оно помогает отделить выполняемую операцию от момента ее выполнения . В однопоточных приложениях «что» и «когда» связаны так сильно , что просмотр содержимого стека часто позволяет определить состояние всего приложения . Программист , отлаживающий такую систему , устанавливает точку прерывания или серию точек прерывания и узнает состояние системы на момент остановки . Отделение «что» от «когда» способно кардинально улучшить как производительность , так и структуру приложения . Со структурной точки зрения многопоточное приложение выглядит как взаимодействие нескольких компьютеров , а не как один большой управляющий цикл . Такая архитектура упрощает понимание системы и предоставляет мощные средства для разделения ответственности . Для примера возьмем «сервлет» , одну из стандартных моделей веб - приложений . Такие системы работают под управлением веб - контейнера или контейнера , который частично управляет многопоточностью за разработчика . Сервлеты выполняются асинхронно при поступлении веб - запросов . Разработчику сервера не нужно управлять входящими запросами . В принципе каждый выполняемый экземпляр сервлета существует в своем замкнутом мире , отделенном от всех остальных экземпляров сервлетов . Конечно , если бы все было так просто , эта глава стала бы ненужной . Изоляция , обеспечиваемая веб - контейнерами , далеко не идеальна . Чтобы многопоточный код работал корректно , разработчики сервлетов должны действовать очень внимательно и осторожно . И все же структурные преимущества модели сервлетов весьма значительны . Но структура — не единственный аргумент для многопоточного программирования . В некоторых системах действуют ограничения по времени отклика и пропускной способности , требующие ручного кодирования многопоточных решений . Для примера возьмем однопоточный агрегатор , который получает информацию с многих сайтов и объединяет ее в ежедневную сводку . Так как система работает в однопоточном режиме , она последовательно обращается к каждому сайту , всегда завершая получение информации до перехода к следующему сайту . Ежедневный сбор информации должен занимать менее часов . Но по мере добавления новых сайтов время непрерывно растет , пока в какой - то момент на сбор всех данных не потребуется более часов . Однопоточной реализации приходится подолгу ожидать завершения операций ввода вывода в сокетах . Для повышения производительности такого приложения можно было бы воспользоваться многопоточным алгоритмом , параллельно работающим с несколькими сайтами . Или другой пример : допустим , система в любой момент времени работает только с одним пользователем , обслуживание которого у нее занимает всего одну секунду . При малом количестве пользователей система оперативно реагирует на все запросы , но с увеличением количества пользователей растет и время отклика . Никто не захочет стоятьв очереди после других пользователей ! Время отклика такой системы можно было бы улучшить за счет параллельного обслуживания многих пользователей . Или возьмем систему , которая анализирует большие объемы данных , но выдает окончательный результат только после их полной обработки . Наборы данных могут обрабатываться параллельно на разных компьютерах . Мифы и неверные представления Итак , существуют весьма веские причины для использования многопоточности . Но как говорилось ранее , написать многопоточную программу трудно . Необходимо действовать очень осторожно , иначе в программе могут возникнуть крайне неприятные ситуации . С многопоточностью связан целый ряд распространенных мифов и неверных представлений . • Многопоточность всегда повышает быстродействие . Действительно , многопоточность иногда повышает быстродействие , но только при относительно большом времени ожидания , которое могло бы эффективно использоваться другими потоками или процессорами . • Написание многопоточного кода не изменяет архитектуру программы . На самом деле архитектура многопоточного алгоритма может заметно отличаться от архитектуры однопоточной системы . Отделение «что» от «когда» обычно оказывает огромное влияние на структуру системы . • При работе с контейнером например , веб - контейнером или - контейнером разбираться в проблемах многопоточного программирования не обязательно . В действительности желательно знать , как работает контейнер и как защититься от проблем одновременного обновления и взаимных блокировок , описанных позднее в этой главе . Несколько более объективных утверждений , относящихся к написанию многопоточного кода : • Многопоточность сопряжена с определенными дополнительными затратами — в отношении как производительности , так и написания дополнительного кода . • Правильная реализация многопоточности сложна даже для простых задач . • Ошибки в многопоточном коде обычно не воспроизводятся , поэтому они часто игнорируются как случайные отклонения а не как систематические дефекты , которыми они на самом деле являются . • Многопоточность часто требует фундаментальных изменений в стратегии проектирования . Трудности Что же делает многопоточное программирование таким сложным ? Рассмотрим тривиальный класс : Допустим , мы создаем экземпляр , присваиваем полю значение , а затем используем созданный экземпляр в двух программных потоках . В обоих потоках вызывается метод возможны три исхода : • Первый поток получает значение , второй получает значение , в поле сохраняется . • Первый поток получает значение , второй получает значение , в поле сохраняется . • Первый поток получает значение , второй получает значение , поле содержит . Удивительный третий результат встречается тогда , когда два потока «перебивают» друг друга . Это происходит из - за того , что выполнение одной строки кода в двух потоках может пойти по разным путям , и некоторые из этих путей порождают неверные результаты . Сколько существует разных путей ? Чтобы ответить на этот вопрос , необходимо понимать , как - компилятор обрабатывает сгенерированный байт - код , и разбираться в том , какие операции рассматриваются моделью памяти как атомарные . В двух словах скажу , что в сгенерированном байт - коде приведенного фрагмента существует разных путей выполнения метода в двух программных потоках . Если изменить тип на , то количество возможных путей возрастет до . Конечно , на большинстве путей выполнения вычисляются правильные результаты . Проблема в том , что нанекоторыхпутях результаты будут неправильными . Защита от ошибок многопоточности Далее перечислены некоторые принципы и приемы , которые помогают защитить вашу систему от проблем многопоточности . Принцип единой ответственности Принцип единой ответственности гласит , что метод класс компонент должен иметь только одну причину для изменения . Многопоточные архитектуры достаточно сложны , чтобы их можно было рассматривать как причину изменения сами по себе , а следовательно , они должны отделяться от основного кода . К сожалению , подробности многопоточной реализации нередко встраиваются в другой код . Однако разработчик должен учитывать ряд факторов : • Код реализации многопоточности имеет собственный цикл разработки , модификации и настройки . • При написании кода реализации многопоточности возникают специфические сложности , принципиально отличающиеся от сложностей однопоточного кода и часто превосходящие их . • Количество потенциальных сбоев в неверно написанном многопоточном коде достаточно велико и без дополнительного бремени в виде окружающего кода приложения . Рекомендация : отделяйте код , относящийся к реализации многопоточности , от остального кода . Следствие : ограничивайте область видимости данных Как было показано ранее , два программных потока , изменяющих одно поле общего объекта , могут мешать друг другу , что приводит к непредвиденному поведению . Одно из возможных решений — защита критической секции кода , в которой происходят обращения к общему объекту , ключевым словом . Количество критических секций в коде должно быть сведено к минимуму . Чем больше в программе мест , в которых обновляются общие данные , тем с большей вероятностью : • вы забудете защитить одно или несколько из этих мест , что приведет к нарушению работы всего кода , изменяющего общие данные . • попытки уследить за тем , чтобы все было надежно защищено , приведут к дублированию усилий нарушение принципа . Вам будет труднее определить источник многопоточных сбоев , который и так достаточно сложно найти . Рекомендация : серьезно относитесь к инкапсуляции данных жестко ограничьте доступ ко всем общим данным . Следствие : используйте копии данных Как избежать нежелательных последствий одновременного доступа к данным ? Например , просто не использовать его . Существуют разные стратегии : например , в одних ситуациях можно скопировать общий объект и ограничить доступ к копии доступ только для чтения . В других ситуациях объекты копируются , результаты работы нескольких программных потоков накапливаются в копиях , а затем объединяются в одном потоке . Если существует простой способ избежать одновременного доступа к объектам , то вероятность возникновения проблем в полученном коде значительно снижается . Вас беспокоят затраты на создание лишних объектов ? Поэкспериментируйте и выясните , действительно ли она так высока . Как правило , если копирование объектов позволяет избежать синхронизации в коде , экономия на защитных блокировках быстро окупит дополнительные затраты на создание объектов и уборку мусора . Следствие : потоки должны быть как можно более независимы Постарайтесь писать многопоточный код так , чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные совместно с другими процессами . Каждый поток обрабатывает один клиентский запрос , все его данные берутся из отдельного источника и хранятся в локальных переменных . В этом случае каждый поток работает так , словно других потоков не существует , а следовательно , нет и требований к синхронизации . Например , классы , производные от , получают всю информацию в параметрах , передаваемых методам и . В результате каждый сервлет действует так , словно в его распоряжении находится отдельный компьютер . Если код сервлета ограничивается одними локальными переменными , он ни при каких условиях не вызовет проблем синхронизации . Конечно , большинство приложений , использующих сервлеты , рано или поздно сталкиваются с использованием общих ресурсов — например , подключений к базам данных . Рекомендация : постарайтесь разбить данные не независимые подмножества , с которыми могут работать независимые потоки возможно , на разных процессорах . Знайте свою библиотеку В возможности многопоточной разработки были значительно расширены по сравнению с предыдущими версиями . При написании многопоточного кода в следует руководствоваться следующими правилами : • Используйте потоково - безопасные коллекции . • Используйте механизм для выполнения несвязанных задач . • По возможности используйте неблокирующие решения . • Некоторые библиотечные классы не являются потоково - безопасными . Потоково - безопасные коллекции Когда язык был еще молод , Даг Ли написал основополагающую книгу « » . В ходе работы над книгой он разработал несколько потоково - безопасных коллекций , которые позднее были включены в в пакете . . . Коллекции этого пакета безопасны в условиях многопоточного выполнения , к тому же они достаточно эффективно работают . Более того , реализация почти всегда работает лучше . К тому же она поддерживает возможность выполнения параллельных операций чтенияи записи и содержит методы для выполнения стандартных составных операций , которые в общем случае не являются потоково - безопасными . Если ваша программа будет работать в среде , используйте в разработке . Также в были добавлены другие классы для поддержки расширенной многопоточности . Несколько примеров . Блокировка , которая может устанавливаться и освобождаться в разных методах Реализация классического семафора блокировка со счетчиком Блокировка , которая ожидает заданного количества событий до освобождения всех ожидающих потоков . Позволяет организовать более или менее одновременный запуск нескольких потоков Рекомендация : изучайте доступные классы . Если вы работаете на , уделите особое внимание пакетам . . , . . . и . . . . Знайте модели выполнения В многопоточных приложениях возможно несколько моделей логического разбиения поведения программы . Но чтобы понять их , необходимо сначала познакомиться с некоторыми базовыми определениями . Связанные ресурсыРесурсы с фиксированным размером или количеством , существующие в многопоточной среде , например подключения к базе данных или буферы чтения записиВзаимное исключение В любой момент времени с общими данными или с общим ресурсом может работать только один потокЗависаниеРабота одного или нескольких потоков приостанавливается на слишком долгое время или навсегда . Например , если высокоприоритетным потокам всегда предоставляетсявозможность отработать первыми , то низкоприоритетные потоки зависнут при условии , что в системе постоянно появляются новые высокоприоритетные потоки Взаимная блокировка Два и более потока бесконечно ожидают завершения друг друга . Каждый поток захватил ресурс , необходимый для продолжения работы другого потока , и ни один поток не может завершиться без получения захваченного другим потоком ресурсаОбратимая блокировка Потоки не могут «разойтись» — каждый из потоков пытается выполнять свою работу , но обнаруживает , что другой поток стоит у него на пути . Потоки постоянно пытаются продолжить выполнение , но им это не удается в течение слишком долгого времени или вообще не удается Вооружившись этими определениями , можно переходить к обсуждению различных моделей выполнения , встречающихся в многопоточном программировании . Модель «производители - потребители» Один или несколько потоков - производителей создаютзаданияи помещают их в буфер или очередь . Один или несколько потоков - потребителей извлекают задания из очереди и выполняют их . Очередь между производителями и потребителями является связанным ресурсом . Это означает , что производители перед записью должны дожидаться появления свободного места в очереди , а потребители должны дожидаться появления заданий в очереди для обработки . Координация производителей и потребителей основана на передаче сигналов . Производитель записывает задание и сигнализирует о том , что очередь не пуста . Потребитель читает задание и сигнализирует о том , что очередь не заполнена . Обе стороны должны быть готовы ожидать оповещения о возможности продолжения работы . Модель «читатели - писатели» Если в системе имеется общий ресурс , который в основном служит источником информации для потоков - «читателей» , но время от времени обновляется потоками - «писателями» , на первый план выходит проблема оперативности обновления . Если обновление будет происходить недостаточно часто , это может привести к зависанию и накоплению устаревших данных . С другой стороны , слишком частые обновления влияют на производительность . Координация работы читателей так , чтобы они не пытались читать данные , обновляемые писателями , и наоборот , — весьма непростая задача . Писатели обычно блокируют работу многих читателей в течение долгого периода времени , а это отражается на производительности . Проектировщик должен найти баланс между потребностями читателей и писателей , чтобы обеспечить правильный режим работы , нормальную производительность системы и избежать зависания . В одной из простых стратегий писатели дожидаются , пока в системе не будет ни одного читателя , и только после этого выполняют обновление . Однако при постоянном потоке читателей такая стратегия приведет к зависанию писателей . С другой стороны , при большом количестве высокоприоритетных писателей пострадает производительность . Поиск баланса и предотвращение ошибок многопоточного обновления — основные проблемы этой модели выполнения . Модель «обедающих философов» Представьте нескольких философов , сидящих за круглым столом . Слева у каждого философа лежит вилка , а в центре стола стоит большая тарелка спагетти . Философы проводят время в размышлениях , пока не проголодаются . Проголодавшись , философ берет вилки , лежащие по обе стороны , и приступает к еде . Для еды необходимы две вилки . Если сосед справа или слева уже использует одну из необходимых вилок , философу приходится ждать , пока сосед закончит есть и положит вилки на стол . Когда философ поест , он кладет свои вилки на стол и снова погружается в размышления . Заменив философов программными потоками , а вилки — ресурсами , мы получаем задачу , типичную для многих корпоративных систем , в которых приложения конкурируют за ресурсы из ограниченного набора . Если небрежно отнестись к проектированию такой системы , то конкуренция между потоками может привести к возникновению взаимных блокировок , обратимых блокировок , падению производительности и эффективности работы . Большинство проблем многопоточности , встречающихся на практике , обычно представляют собой те или иные разновидности этих трех моделей . Изучайте алгоритмы , самостоятельно создавайте их реализации , чтобы столкнувшись с этими проблемами , вы были готовы к их решению . Рекомендация : изучайте базовые алгоритмы , разбирайтесь в решениях . Остерегайтесь зависимостей между синхронизированными методами Зависимости между синхронизированными методами приводят к появлению коварных ошибок в многопоточном коде . В языке существует ключевое слово для защитыотдельных методов . Но если общий класс содержит более одного синхронизированного метода , возможно , ваша система спроектирована неверно . Рекомендация : избегайте использования нескольких методов одного совместно используемого объекта . Впрочем , иногда без использования разных методов одного общего объекта обойтись все же не удается . Для обеспечения правильности работы кода в подобных ситуациях существуют три стандартных решения : • Блокировка на стороне клиента— клиент устанавливает блокировку для сервера перед вызовом первого метода и следит за тем , чтобы блокировка распространялась на код , вызывающий последний метод . • Блокировка на стороне сервера— на стороне сервера создается метод , который блокирует сервер , вызывает все методы , после чего снимает блокировку . Этот новый метод вызывается клиентом . • Адаптирующий сервер— в системе создается посредник , который реализует блокировку . Ситуация может рассматриваться как пример блокировки на стороне сервера , в которой исходный сервер не может быть изменен . Синхронизированные секции должны иметь минимальный размер Ключевое слово устанавливает блокировку . Все секции кода , защищенные одной блокировкой , в любой момент времени гарантированно выполняются только в одном программном потоке . Блокировки обходятся дорого , так как они создают задержки и увеличивают затраты ресурсов . Следовательно , код не должен перегружаться лишними конструкциями . С другой стороны , все критические секции должны быть защищены . Следовательно , код должен содержать как можно меньше критических секций . Для достижения этой цели некоторые наивные программисты делают свои критические секции очень большими . Однако синхронизация за пределами минимальных критических секций увеличивает конкуренцию между потоками и снижает производительность . Рекомендация : синхронизированные секции в ваших программах должны иметь минимальные размеры . О трудности корректного завершения Написание системы , которая должна работать бесконечно , заметно отличается от написания системы , которая работает в течение некоторого времени , а затем корректно завершается . Реализовать корректное завершение порой бывает весьма непросто . Одна из типичных проблем — взаимная блокировка программных потоков , бесконечно долго ожидающих сигнала на продолжение работы . Представьте систему с родительским потоком , который порождает несколько дочерних потоков , а затем дожидается их завершения , чтобы освободить свои ресурсы и завершиться . Что произойдет , если один из дочерних потоков попадет во взаимную блокировку ? Родитель будет ожидать вечно , и система не сможет корректно завершиться . Или возьмем аналогичную систему , получившую сигнал о завершении . Родитель приказывает всем своим потомкам прервать свои операции и завершить работу . Но что если два потомка составляют пару «производитель потребитель» ? Допустим , производитель получает сигнал от родителя , и прерывает свою работу . Потребитель , в этот момент ожидавший сообщения от производителя , блокируется в состоянии , в котором он не может получить сигнал завершения . В результате он переходит в бесконечное ожидание — азначит , родитель тоже не сможет завершиться . Подобные ситуации вовсе не являются нетипичными . Если вы пишете многопоточный код , который должен корректно завершаться , не жалейте времени на обеспечение нормального завершения работы . Рекомендация : начинайте думать о корректном завершении на ранней стадии разработки . На это может уйти больше времени , чем вы предполагаете . Проанализируйте существующие алгоритмы , потому что эта задача сложнее , чем кажется . Тестирование многопоточного кода Тестирование не гарантирует правильности работы кода . Тем не менее качественное тестирование сводит риск к минимуму . Для однопоточных решений эти утверждения безусловно верны . Но как только в системе появляются два и более потока , использующие общий код и работающих с общими данными , ситуация значительно усложняется . Рекомендация : пишите тесты , направленные на выявление существующих проблем . Часто выполняйте их для разных вариантов программных системных конфигураций и уровней нагрузки . Если при выполнении теста происходит ошибка , обязательно найдите причину . Не игнорируйте ошибку только потому , что при следующем запуске тест был выполнен успешно . Несколько более конкретных рекомендаций : • Рассматривайте непериодические сбои как признаки возможных проблем многопоточности . • Начните с отладки основного кода , не связанного с многопоточностью . • Реализуйте логическую изоляцию конфигураций многопоточного кода . • Обеспечьте возможность настройки многопоточного кода . • Протестируйте программу с количеством потоков , превышающим количество процессоров . • Протестируйте программу на разных платформах . • Применяйте инструментовку кода для повышения вероятности сбоев . Рассматривайте непериодические сбои как признаки возможных проблем многопоточности В многопоточном коде сбои происходят даже там , где их вроде бы и быть не может . Многие разработчики в том числе и автор не обладают интуитивным представлением о том , как многопоточный код взаимодействует с другим кодом . Ошибки в многопоточном коде могут проявляться один раз за тысячу или даже миллион запусков . Воспроизвести такие ошибки в системе бывает очень трудно , поэтому разработчики часто склонны объяснять их «фазами Луны» , случайными сбоями оборудования или другими несистематическими причинами . Однако игнорируя существование этих «разовых» сбоев , вы строите свой код на потенциально ненадежном фундаменте . Рекомендация : не игнорируйте системные ошибки , считая их случайными , разовыми сбоями . Начните с отладки основного кода , не связанного с многопоточностью На первый взгляд совет выглядит тривиально , но еще раз подчеркнуть его значимость не лишне . Убедитесь в том , что сам код работает вне многопоточного контекста . В общем случае это означает создание - объектов , вызываемых из потоков . - объекты не обладают поддержкой многопоточности , а следовательно , могут тестироваться вне многопоточной среды . Чем больше системного кода можно разместить в таких - объектах , тем лучше . Рекомендация : не пытайтесь одновременно отлавливать ошибки в обычном и многопоточном коде . Убедитесь в том , что ваш код работает за пределами многопоточной среды выполнения . Реализуйте переключение конфигураций многопоточного кода Напишите вспомогательный код поддержки многопоточности , который может работать в разных конфигурациях . • Один поток несколько потоков количество потоков изменяется по ходу выполнения . • Многопоточный код взаимодействует с реальным кодом или тестовыми заменителями . • Код выполняется с тестовыми заменителями , которые работают быстро медленно с переменной скоростью . • Настройте тесты таким образом , чтобы они могли выполняться заданное количество раз . Рекомендация : реализуйте свой многопоточный код так , чтобы он мог выполняться в различных конфигурациях . Обеспечьте логическую изоляцию конфигураций многопоточного кода Правильный баланс программных потоков обычно определяется методом проб и ошибок . Прежде всего найдите средства измерения производительности системы в разных конфигурациях . Реализуйте систему так , чтобы количество программных потоков могло легко изменяться . Подумайте , нельзя ли разрешить его изменение во время работы системы . Рассмотрите возможность автоматической настройки в зависимости от текущей производительности и загрузки системы . Протестируйте программу с количеством потоков , превышающим количество процессоров При переключении контекста системы между задачами могут происходить всякие неожиданности . Чтобы форсировать переключение задач , выполняйте свой код с количеством потоков , превышающим количество физических процессоров или ядер . Чем чаще происходит переключение задач , тем больше вероятность выявления пропущенной критической секции или возникновения взаимной блокировки . Протестируйте программу на разных платформах В середине - го года мы разрабатывали учебный курс по многопоточному программированию . Разработка курса велась в . Материал курса излагался в системе , запущенной на виртуальной машине . Однако сбои в тестах , написанных для демонстрации ошибок , происходили в среде заметно реже , чем при запуске в . Тестируемый код всегда был заведомо некорректным . Эта история лишний раз доказывает , что в разных операционных системах используются разные политики многопоточности , влияющие на выполнение кода . Многопоточный код по - разному работает в разных средах . Протестируйте систему во всех средах , которые могут использоваться для ее развертывания . Рекомендация : многопоточный код необходимо тестировать на всех целевых платформах — часто и начиная с ранней стадии . Применяйте инструментовку кода для повышения вероятности сбоев Ошибки в многопоточном коде обычно хорошо скрыты от наших глаз . Простыми тестами они не выявляются . Такие ошибки могут проявляться с периодичностью в несколько часов , дней или недель ! Почему же многопоточные ошибки возникают так редко и непредсказуемо , почему их так трудно воспроизвести ? Потому что лишь несколько из тысяч возможных путей выполнения кода плохо написанной секции приводят к фактическому отказу . Таким образом , вероятность выбора сбойного пути ничтожно мала . Это обстоятельство серьезно усложняет выявление ошибок и отладку . Как повысить вероятность выявления таких редких ошибок ? Внесите в свой год соответствующие изменения и заставьте его выполняться по разным путям — включите в него вызовы таких методов , как . , . , . и . . Каждый из этих методов влияет на порядок выполнения программы , повышая шансы на выявление сбоя . Сбои в дефектном коде должны выявляться как можно раньше и как можно чаще . Существует два способа инструментовки кода : • Ручная . • Автоматическая . Ручная инструментовка Разработчик вставляет вызовы , , и в свой код вручную . Такой вариант отлично подходит для тестирования особенно коварных фрагментов кода . Пример : . . Вставлено для тестирования Добавленный вызов изменяет путь выполнения кода . В результате в программе может произойти сбой там , где раньше его не было . Если работа программы действительно нарушается , то это произошло не из - за того , что вы добавили вызов . Просто ваш код содержал скрытые ошибки , а в результате вызова они стали очевидными . Ручная инструментовка имеет много недостатков : • Разработчик должен каким - то образом найти подходящие места для вставки вызовов . • Как узнать , где и какой именно вызов следует вставить ? • Если вставленные вызовы останутся в окончательной версии кода , это приведет к замедлению его работы . • Вам приходится действовать «наобум» : вы либо находите скрытые дефекты , либо не находите их . Вообще говоря , шансы не в вашу пользу . Отладочные вызовы должны присутствовать только на стадии тестирования , но не в окончательной версии кода . Кроме того , вам понадобятся средства для простого переключения конфигураций между запусками , повышающего вероятность обнаружения ошибок в общей кодовой базе . Конечно , разделение системы на - объекты , ничего не знающие о многопоточности , и классы , управляющие многопоточностью , упрощает поиск подходящих мест для инструментовки кода . Кроме того , такое разделение позволит нам создать целый набор «испытательных пакетов» , активизирующих - объекты с разными режимами вызова , и т . д . Автоматизированная инструментовка Также возможна программная инструментовка кода с применением таких инструментов , как - , или . Допустим , в программу включается класс с единственным методом : Вызовы этого метода размещаются в разных позициях кода : . . . . Теперь в вашем распоряжении появился простой аспект , случайным образом выбирающий между обычным продолжением работы , приостановкой и передачей управления . Или представьте , что класс имеет две реализации . В первой реализации не делает ничего эта реализация используется в окончательной версии кода . Вторая реализация генерирует случайное число для выбора между приостановкой , передачей управления и обычным выполнением . Если теперь повторить тестирование тысячу разсо случайным выбором , возможно , вам удастся выявить некоторые дефекты . Даже если тестирование пройдет успешно , по крайней мере вы сможете сказать , что приложили должные усилия для выявления недостатков . Такой подход выглядит несколько упрощенно , но и он может оказаться разумной альтернативой для применения более сложных инструментов . Программа , разработанная фирмой , работает по аналогичному принципу , но предоставляет расширенные возможности . Впрочем , суть тестирования остается неизменной : вы ломаете предсказуемость пути выполнения , чтобы при разных запусках код проходил по разным путям . Комбинация хорошо написанных тестов и случайного выбора пути может радикально повысить вероятность поиска ошибок . Рекомендация : используйте стратегию случайного выбора пути выполнения для выявления ошибок . Заключение Правильно написать многопоточный код непросто . Даже очевидный , хорошо понятный код превращается в сущий кошмар , когда в игру вступают множественные потоки и одновременный доступ к данным . Если вы столкнулись с задачей из области многопоточного программирования , вам придется приложить все усилия к написанию чистого кода или столкнуться с коварными , непредсказуемыми сбоями . Прежде всего следуйте принципу единой ответственности . Разбейте систему на - объекты , отделяющие многопоточный код от кода , с потоками никак не связанного . Проследите за тем , чтобы при тестировании многопоточного кода тестировался только этот код , и ничего лишнего . Из этого следует , что многопоточный код должен быть компактным и сконцентрированным в одном месте . Знайте типичные источники многопоточных ошибок : работа с общими данными из нескольких программных потоков , использование пула общих ресурсов . Особенно непростыми оказываются пограничные случаи : корректное завершение работы , завершение итераций циклов и т . д . Изучайте свои библиотеки и знайте фундаментальные алгоритмы . Разберитесь в том , как некоторые функции библиотек используются для решения проблем , сходных с проблемами фундаментальных алгоритмов . Научитесь находить секции кода , которые должны защищаться блокировками , и защищайте их . Не устанавливайте блокировки для тех секций , которые защищать не нужно . Избегайте вызовов одной заблокированной секции из другой заблокированной секции — для них необходимо глубокое понимание того , какие ресурсы находятся в общем или монопольном доступе . Сведите к минимуму количество совместно используемых объектов и масштаб общего доступа . Измените архитектуру объектов с общими данными так , чтобы они поддерживали одновременные обращения со стороны клиентов , вместо того чтобы заставлять самих клиентов заниматься управлением состоянием общего доступа . В ходе программирования неизбежно возникнут проблемы . Те из них , которые не проявляются на самой ранней стадии , часто списываются на случайности . Эти так называемые «несистематические» ошибки часто встречаются только при высокой нагрузке или вообще в случайные на первый взгляд моменты . Следовательно , вы должны позаботиться о том , чтобы ваш многопоточный код мог многократно запускаться в разных конфигурациях на многих платформах . Тестируемость , естественным образом проистекающая из трех законов , подразумевает определенный уровень модульности , которая обеспечивает возможность выполнения кода в более широком диапазоне конфигураций . Потратив немного времени на инструментовку кода , вы значительно повысите шансы обнаружения некорректного кода . Инструментовка может производиться как вручную , так и с применением технологий автоматизации . Начинайте с ранних стадий работы над продуктом . Многопоточный код должен отработать в течение как можно большего времени , прежде чем он будет включен в окончательную версию продукта . Если вы будете стремиться к чистоте своего кода , вероятность того , что вам удастся правильно реализовать его , значительно возрастет . Литература : : , . . , , , . : : , , , . , , . : , , , - , . Глава . Последовательное очищениеДело о разборе аргументов командной строки Картинка : _ . В этой главе представлен вполне реальный сценарий последовательного очищения кода . Мы рассмотрим модуль , который внешне смотрелся вполне достойно , но плохо масштабировался . Вы увидите , как происходила переработка и очистка этого модуля . Многим из нас время от времени приходится заниматься разбором аргументов командной строки . Если под рукой не окажется удобного инструмента , мы просто перебираем элементы массива строк , переданного функции . Я знал немало хороших инструментов из разных источников , однако ни один из них не делал именно того , что мне было нужно . Разумеется , я решил написать собственную реализацию — назовем ее . Класс очень прост в использовании . Вы конструируете экземпляр класса с входными аргументами и форматной строкой , а затем обращаетесь к нему за значениями аргументов . Рассмотрим простой пример . Листинг . . Простое использование " , # , " , . ' ' . ' ' . ' ' , , . . " : % \ " , . Вы и сами видите , что все действительно просто . Мы создаем экземпляр класса с двумя параметрами . Первый параметр задает форматную строку : " , # , . " . Эта строка определяет три аргумента командной строки . Первый аргумент , – , относится к логическому булевскому типу . Второй аргумент , - , относится к целочисленному типу . Третий аргумент , - , является строковым . Во втором параметре конструктора содержится массив аргументов командной строки , полученный . Если конструктор возвращает управление без выдачи исключения , значит , разбор входной командной строки прошел успешно , и экземпляр готов к приему запросов . Методы , , и т . д . используются для получения значений аргументов по именам . При возникновении проблем в форматной строке или в самих аргументах командной строки инициируется исключение . Для получения текстового описания проблемы следует вызвать метод объекта исключения . Реализация Реализация класса приведена в листинге . . Пожалуйста , очень внимательно прочитайте ее . Я основательно потрудился над стилем и структурой кода и надеюсь , что высочтете его достойным образцом для подражания . Листинг . . . . . . . . . . . . . . , , , . : . " , " . . . . . . , . " " . , . " # " . , . " # # " . , . " " . , _ _ , , ! . _ _ , , . . . . " - " . . Листинг . продолжение . . . _ , , . . . . . . . . . . . . . . . Обратите внимание : код читается сверху вниз , и вам не приходится постоянно переходить туда - сюда или заглядывать вперед . Единственное место , где все же необходимо заглянуть вперед , — это определение , но и это было сделано намеренно . Внимательно прочитав этот код , вы поймете , что собой представляет интерфейс и что делают производные классы . Примеры таких классов приведены в листингах . – . . Листинг . . . Листинг . . . ! . Листинг . . . . . . . . . " " . _ ! Листинг . . продолжение . " " Листинг . . . . . . . . . . . _ _ , ! . Другие классы , производные от , строятся по тому же шаблону , что и классы для массивов и . Здесь они не приводятся для экономии места . Оставляю их вамдля самостоятельной работы . Возможно , вы заметили еще одно обстоятельство : где определяются константы для кодов ошибок ? Они находятся в классе листинг . . Листинг . . . . . . . . . ' \ ' . , . . , , . . . . . . : " : . " _ : . " - % . " , _ : . " - % . " , _ : . " - % ' % ' . " , , Листинг . продолжение _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , _ _ : . " ' % ' . " , _ _ : . " ' % ' . " , " " , _ _ , _ , _ _ , _ , _ , _ , _ , _ Удивительно , какой объем кода понадобился для воплощения всех подробностей этой простой концепции . Одна из причин заключается в том , что мы используем весьма «многословный» язык . Поскольку относится к числу языков со статической типизацией , для удовлетворения требований системы типов в нем используется немалый объем кода . На таких языках , как , или , программа получится гораздо короче . Пожалуйста , перечитайте код еще раз . Обратите особое внимание на выбор имен , размеры функций и форматирование кода . Возможно , опытные программисты найдут отдельные недочеты в стиле или структуре кода . Но я надеюсь , что в целом вы согласитесь с тем , что код хорошо написан , а его структура чиста и логична . Скажем , после чтения кода вам должно быть очевидно , как добавить поддержку нового типа аргументов например , дат или комплексных чисел , и это потребует относительно небольших усилий с вашей стороны . Для этого достаточно создать новый класс , производный от , новую функцию и включить новое условие в функцию . Вероятно , также потребуется новое значение . и новое сообщение об ошибке . Как я это сделал ? Позвольте вас успокоить : я не написал эту программу от начала до конца в ее текущем виде . Более того , я не ожидаю , что вы сможете писать чистые и элегантные программы за один проход . Если мы чему - то и научились за последнюю пару десятилетий , так это тому , что программирование ближе к ремеслу , чем к науке . Чтобы написать чистый код , мы сначала пишем грязный код , а затем очищаем его . Вряд ли вас это удивит . Мы усвоили эту истину еще в начальной школе , когда учителя заставляли нас обычно безуспешно писать планы сочинений . Предполагалось , что мы должны сначала написать первый вариант плана , затем второй , потом еще несколько версий , пока не придем к окончательной версии . Они пытались объяснить нам , что четкое и ясное сочинение появляется в результате последовательного усовершенствования . Многие начинающие программисты впрочем , как и большинство школьников , пишущих сочинения не слишком усердно следуют этому совету . Они считают , что их главная цель— заставить программу работать . Когда программа «заработает» , они переходят к следующей задаче , оставляя «работающую» программу в том состоянии , в котором она «заработала» . Опытные программисты знают , что с профессиональной точки зрения такой подход равносилен самоубийству . : черновик В листинге . приведена более ранняя версия класса . Она «работает» . И при этом выглядит крайне неряшливо . Листинг . . . первая версия . . . . , , , , , , ' \ ' " " . , _ , _ , _ , _ Листинг . продолжение , . . . . : . " , " . . . . . " : % : % . " , , , ! . " : " " : " , . , . , . , " " . " " . . " # " . . " - " . . . . . _ Листинг . продолжение , . . , . _ . _ . , . _ . , . , . . . " - " " " " " : " : . " _ : _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , " " " - " : . . " . " . ! Листинг . продолжение ? : ? " " : . . . . Надеюсь , при виде этой глыбы кода вам захотелось сказать : «Как хорошо , что она не осталась в таком виде ! » Если вы почувствовали нечто подобное , вспомните , что другиелюди чувствуют то же самое при виде вашего кода , оставшегося на стадии «черновика» . Вообще говоря , «черновик» — самое мягкое , что можно сказать об этом коде . Очевидно , что перед нами незавершенная работа . От одного количества переменных экземпляров можно прийти в ужас . Загадочные строки вроде " ” , контейнеры и , конструкции - - только увеличивают масштабы этого беспорядочного месива . Я вовсе не собирался писать беспорядочное месиво . В самом деле , я постарался сохранить более или менее разумную организацию кода . Об этом свидетельствует хотя бы выбор имен функций и переменных , а также наличие у программы примитивной структуры . Но совершенно очевидно , что проблемы вышли из - под моего контроля . Неразбериха накапливалась постепенно . Ранние версии выглядели вовсе не так отвратительно . Для примера в листинге . приведена начальная версия , поддерживающая только логические аргументы . Листинг . . . только . . . . . , , , . . . . . : . " , " . Листинг . продолжение . . . , : . " - " . . , . , . , . . " - " " " " " . " " " - " : . . " . " . . В этом коде можно найти множество недостатков , однако в целом он не так уж плох . Код компактен и прост , в нем легко разобраться . Тем не менее в этом коде легко прослеживаются зачатки будущего беспорядочного месива . Нетрудно понять , как из него выросла вся последующая неразбериха . Обратите внимание : в последующей неразберихе добавились всего два новых типа аргументов , и . Добавление всего двух типов аргументов имело огромные отрицательные последствия для кода . Более или менее понятный код превратился в запутанный клубок , наверняка кишащий множеством ошибок и недочетов . Два новых типа аргументов добавлялись последовательно . Сначала я добавил поддержку , что привело к следующему результату . Листинг . . . и . . . . . . . , , , Листинг . продолжение , ' \ ' , _ . , . . . . : . " , " . . . . ! . " : " " : " , . , " " . " " . . , . . " - " . . . . , , " " Листинг . продолжение , . , . _ . , . , . . . " - " " " " " . _ : . " - % . " , : " : . " " " " - " : . . " . " . . ? : . ? " " : . Ситуация явно выходит из - под контроля . Код все еще не ужасен , но путаница очевидно растет . Это уже клубок , хотя и не беспорядочное месиво . А чтобы месиво забродило и стало подниматься , хватило простого добавления целочисленных аргументов . На этом я остановился Мне предстояло добавить еще два типа аргументов . Было совершенно очевидно , что с ними все станет намного хуже . Если бы я с упорством бульдозера пошел вперед , скореевсего , мне удалось бы заставить программу работать , но разобраться в получившемся коде не удалось бы уже никому . Если я хотел , чтобы с моим кодом можно было работать , спасать положение нужно было именно сейчас . Итак , я прекратил добавлять в программу новые возможности и взялся за переработку . После добавления типов и я знал , что для каждого типа аргументов новый код должен добавляться в трех основных местах . Во - первых , для каждого типа аргументов необходимо было обеспечить разбор соответствующего элемента форматной строки , чтобы выбрать объект для этого типа . Затем аргумент соответствующего типа необходимо было разобрать в командной строке и преобразовать к истинному типу . Наконец , для каждого типа аргументов требовался метод , возвращающий значение аргумента с его истинным типом . Много разных типов , обладающих сходными методами… Наводит на мысли о классе . Так родилась концепция . О постепенном усовершенствовании Один из верных способов убить программу — вносить глобальные изменения в ее структуру с целью улучшения . Некоторые программы уже никогда не приходят в себя после таких «усовершенствований» . Проблема в том , что код очень трудно заставить работать так же , как он работал до «усовершенствования» . Чтобы этого не произошло , я воспользовался методологией разработки через тестирование . Одна из центральных доктрин этой методологии гласит , что система должна работать в любой момент в процессе внесения изменений . Иначе говоря , при использовании запрещено вносить в систему изменения , нарушающие работоспособность этой системы . С каждым вносимым изменением система должна работать так же , как она работала прежде . Для этого был необходим пакет автоматизированных тестов . Запуская их в любой момент времени , я мог бы убедиться в том , что поведение системы осталось неизменным . Я уже создал пакет модульных и приемочных тестов для класса , пока работал над начальной версией она же «беспорядочное месиво» . Модульные тесты были написаны на и находились под управлением . Приемочные тесты были оформлены в виде вики - страниц в . Я мог запустить эти тесты в любой момент по своему усмотрению , и если они проходили — можно было не сомневаться в том , что система работает именно так , как положено . И тогда я занялся внесением множества очень маленьких изменений . Каждое изменение продвигало структуру системы к концепции , но после каждого изменения система продолжала нормально работать . На первом этапе я добавил заготовку в конец месива листинг . . Листинг . . Класс , присоединенный к . Понятно , что добавление класса ничего не нарушит . Поэтому я внес самое простейшее из всех возможных изменений — изменил контейнер для логических аргументов так , чтобы при конструировании передавался тип : , , Это нарушило работу нескольких команд , которые я быстро исправил . … . , . . , . . … . . Изменения вносятся в тех местах , о которых я упоминал ранее : методы , и для типа аргумента . К сожалению , при всей незначительности изменений некоторые тесты стали завершаться неудачей . Внимательно присмотревшись к , вы увидите , что если при вызове метода с ' ' аргумента не существует , вызов . ‘ ’ вернет , афункция выдаст исключение . Функция защищала от подобных ситуаций , но в результате внесенных изменений она перестала работать . Стратегия постепенных изменений требовала , чтобы я немедленно наладил работу программы , прежде чем вносить какие - либо дополнительные изменения . Действительно , проблема решалась просто : нужно было добавить проверку . Но на этот раз проверять нужно было не логическое значение , а . Сначала я убрал вызов из . Функция стала бесполезной , поэтому я убрал и саму функцию . Тесты все равно не проходили , поэтому я был уверен , что новых ошибок от этого уже не прибавится . . . Затем я разбил функцию надвое и разместил в собственной переменной с именем . Длинное имя мне не понравилось во - первых , оно было избыточным , а во - вторых , загромождало функцию . Соответственно я сократил его до . . . . Наконец , я добавил логику проверки : . . ! . Аргументы Добавление поддержки было очень похоже на добавление поддержки . Мне предстояло изменить и заставить работать функции , и . Полагаю , следующий код понятен без пояснений — если не считать того , что я разместил всю реализацию компоновки аргументов в базовом клссе , вместо того чтобы распределять ее по производным классам . , , … . , … . . . _ … . . ? " " : . … ? " " : И снова изменения вносились последовательно и только так , чтобы тесты по крайней мере хотя бы запускались даже если и не проходили . Если работоспособность теста была нарушена , я сначала добивался того , чтобы он работал , и только потом переходил к следующему изменению . Вероятно , вы уже поняли , что я собираюсь сделать . Собрав все текущее поведение компоновки аргументов в базовом классе , я намерен перемещать его вниз в производные классы . Это позволит мне сохранить работоспособность программы в ходе постепенного изменения ее структуры . Очевидным следующим шагом стало перемещение функциональности аргумента в . И снова все обошлось без сюрпризов : , , … . , … . . . . _ . _ … . . ? : . … ? " " : Переместив всю логику компоновки аргументов в , я занялся перемещением функциональности в производные классы . На первом этапе я должен был переместить функцию в и позаботиться о том , чтобы она правильно вызывалась . Для этого был создан абстрактный метод . ? " " : Затем метод был реализован в . Наконец , вызов был заменен вызовом . , . . " " Все тесты прошли успешно . Так как изменения привели к перемещению в , я удалил метод из базового класса . Обратите внимание : абстрактная функция получает аргумент , но реализация в классе его не использует . Я добавил этот аргумент , потому что знал , что онбудетиспользоваться классами и . На следующем шаге я решил разместить метод в . Подобные размещения всегда выглядят уродливо , потому что фактически возвращается тип , который в данном случае приходится преобразовывать в . . . ! . Просто для того , чтобы программа компилировалась , я добавил в функцию . … Программа компилировалась , а тесты , разумеется , не проходили . Чтобы тесты снова заработали , достаточно объявить метод абстрактным и реализовать его в . … Итак , тесты снова проходят успешно . Теперь оба метода и размещаются в ! Это позволило мне удалить старую функцию из , переместить защищенную переменную в и объявить ее приватной . Аналогичные изменения были внесены для типа . Я реализовал методы и , удалил ненужные функции и переместил переменные . . . . _ … . . ? " " : . … " " Осталось лишь повторить этот процесс для . На этот раз задача немного усложняется : целые числа необходимо разбирать , а в ходе разбора возможны исключения . Но внешний вид кода улучшается тем , что вся концепция скрыта в классе . . . . . _ . _ … . . " " … . . ? : . … … . Конечно , тесты по - прежнему проходили . Далее я избавился от трех разновидностей в начале алгоритма , отчего система стала намного более универсальной . Впрочем , я не мог их просто удалить , поскольку это нарушило бы работу системы . Вместо этого я добавил новый объект для , а затем последовательно изменял методы , чтобыони использовали этот объект вместо трех исходных . … , , , , , , , , … . , . , . , . , . , . , Разумеется , тесты проходили успешно . Далее я привел метод : . к следующему виду : . Тесты по - прежнему проходят . Я внес аналогичные изменения в и . . . Тесты проходят . Я удалил все повторяющиеся вызовы . : . Причин для существования трех методов не осталось . Я оформил их в виде встроенного кода : . На следующем шаге я перешел на использование ассоциативного массива в функциях , отказываясь от использования трех старых контейнеров . Преобразование началось с : . … . “ ” было : . . « » Тесты проходили успешно , и я сделал то же самое для типов и . Это позволило мне интегрировать часть некрасивого кода обработки исключений в функцию . . . . _ . _ . . _ Я вплотную подошел к удалению трех старых объектов . Прежде всего было необходимо привести функцию : . . ! . к следующему виду : . . ! . Возможно , последнее изменение вас удивило . Почему я вдруг решил обрабатывать ? Дело в том , что наряду с набором модульных тестов у меня был отдельный набор приемочных тестов , написанных для . Оказалось , что тесты проверяли , что при вызове для аргумента с типом , отличным от , возвращается . Модульные тесты этого не делали . До этого момента я запускал только модульные тесты . Последнее изменение позволило исключить еще одну точку использования объекта для типа : . , . , Теперь объект для типа можно было удалить : … , , , , , , , , … Далее я проделал аналогичную процедуру для аргументов и и немного подчистил код : . , . , . , … . . ? " " : . " " … … , , , , , , … Затем я подставил в код трех методов , сократившихся до одной команды : . . . , . , . , . " : % : % . " , , , Давайте взглянем на общую картину . В листинге . представлена текущая форма класса . Листинг . . . после первой переработки . . . . . . . , , ' \ ' " " . , _ , _ , _ , _ , . . . . : . " , " . . . . . , . , . , . " : % : % . " , , , ! . " : " " : " , . " " . . " # " Листинг . продолжение . . " - " . . . . . _ . . . _ . _ . . _ . " " . . " - " " " " " : " : . " _ : _ : . " - % . " , _ : . " - % ' % ' . " , , Листинг . продолжение _ : . " - % . " , " " " - " : . . " . " . . . ! . . . ? " " : . " " . . ? : . . " " . Вроде бы проделана большая работа , а результат не впечатляет . Структура кода немного улучшилась , но в начале листинга по - прежнему объявляются многочисленные переменные в осталась кошмарная конструкция проверки типа функции выглядят просто ужасно . Я уже не говорю об обработке ошибок… Нам еще предстоит большая работа . Прежде всего хотелось бы избавиться от конструкции выбора в . В идеале она должна быть заменена единственным вызовом . . Это означает , что код , и должен быть перемещен в соответствующие классы , производные от . Однако при этом возникает одна проблема . Внимательно присмотревшись к функции , можно заметить , что в ней используются две переменные экземпляров : и . Чтобы переместить в , мне придется передать и в аргументах при вызове . Решение получается «грязным» . Я бы предпочел передать один аргумент вместо двух . К счастью , у проблемы существует простое решение : мы можем преобразовать массив в и передать функциям . Следующее преобразование было проведено за десять шагов , с обязательнымвыполнением всех тестов после каждого шага . Здесь я приведу только конечный результат , но вы легко сможете опознать большинство промежуточных шагов по этому листингу . , , ' \ ' " " . , _ , _ , _ , _ , . . . . - - - . . . - - - . . . _ . _ . . . _ Все изменения были простыми и не нарушали работы тестов . Теперь можно заняться перемещением функций в соответствующие производные классы . Начнем с внесения изменений в : . Это изменение важно , потому что мы хотим полностью устранить цепочку - . Для этого из нее необходимо вывести состояние ошибки . Теперь можно переходить к перемещению функций . Функция тривиальна , поэтому начнем с нее . Наша задача — изменить функцию так , чтобы она просто передавала управление . . , - - - , . " " Но ведь мы только что перенесли обработку исключения в функцию ? Ситуация с включением того , что вы намереваетесь вскоре исключить , весьма часто встречается при переработке кода . Малый размер шагов и необходимость прохождения тестов означает , что вам придется часто перемещать туда - сюда фрагменты кода . Переработка кода напоминает кубик Рубика : чтобы добиться большой цели , необходимо выполнить множество мелких операций . Каждая операция делает возможной следующую . Зачем передавать итератор , если он не нужен ? Потому что он нужен и ! И если я хочу организовать доступ ко всем трем функциям через абстрактный метод в , мне не обойтись без его передачи . Итак , функция стала бесполезной . Если бы в присутствовала функция , то мы могли бы вызвать ее напрямую . Значит , нужно создать такую функцию ! Первым шагом станет включение нового абстрактного метода в . Конечно , это нарушает работу всех производных классов , поэтому мы добавим реализацию нового метода в каждый из них . " " . А теперь можно удалить ! . . Все тесты проходят , а функция размещается в ! Теперь можно сделать то же самое для . . . . . - - - " " . . _ . . _ . _ . А теперь завершающий штрих : убираем цепочку - ! . . Избавляемся от лишних функций в и слегка чистим код : . . . _ . _ преобразуется в интерфейс : А теперь посмотрите , как легко добавлять новые типы аргументов в эту структуру . Количество изменений минимально , а все изменения логически изолированы . Начнем с добавления нового тестового сценария , проверяющего правильность работы аргументов : " # # " , " - " , " . " . , . . ' ' . , . ' ' , . Чистим код разбора форматной строки и добавляем обнаружение # # для аргументов типа . . . . . , . " " . , . " # " . , . " # # " . , . " : % : % . " , , , Затем пишется класс . . . . _ . _ Для нового типа добавляются новые коды ошибок : , _ , _ , _ , _ , _ , _ А еще понадобится функция : . . ? : . . И все тесты успешно проходят ! Добавление нового типа прошло в целом безболезненно . Теперь давайте убедимся в том , что обработка ошибок работает правильно . Следующий тестовый сценарий проверяет , что при передаче неразбираемой строки с аргументом # # выдается соответствующая ошибка : " # # " , " - " , " " . , . . ' ' , . ' ' " - ' ' . " , . - - - : " : . " _ : _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , " " Тесты успешно проходят . Следующий тест проверяет , что ошибка с отсутствующим аргументом будет успешно обнаружена : " # # " , " - " . , . . ' ' . , . ' ' , . " - . " , . Как и ожидалось , все проходит успешно . Этот тест был написан просто для полноты картины . Код исключения некрасив , и в классе ему не место . Также в коде инициируется исключение , которое на самом деле нам не принадлежит . Давайте объединим все исключения в один класс и переместим его в отдельный модуль . ' \ ' " " . , _ , _ , _ , _ , _ , _ - - - … ' \ ' " " . . . , . . . . … … . " : % : % . " , , ! . " : " " : " … . . . . _ … " " . . . _ . . . . _ . . _ . . . . _ . . _ Хорошо — теперь выдает единственное исключение . Выделение в отдельный модуль приведет к тому , что большой объем вспомогательного кода обработки ошибок переместится из модуля в этот модуль . Это наиболее естественное и очевидное место для размещения этого кода , вдобавок перемещение поможет очистить перерабатываемый модуль . Итак , нам удалось полностью отделить код исключений и ошибок от модуля листинги . – . . Для решения этой задачи понадобилось примерно промежуточных шагов , ипосле каждого шага проверялось прохождение всех тестов . Листинг . . . . . . . . " " , , . " " , " - " . . _ , . ' ' , . " " , " - " , " - " . . _ , . ' ' , . " " , " " . . _ _ , . ' ' , . " ~ " , " " . . _ , . ' ' , . " " , " - " , . , . ' ' " " , " - " , " " , . . ' ' " " , . ' ' " " , " - " . . _ , . ' ' , . " , " , " - " , . . ' ' . ' ' " # " , " - " , " " , . . ' ' , . ' ' " # " , " - " , " " . . _ , . ' ' , . " " , . Листинг . продолжение " # " , " - " . . _ , . ' ' , . " # # " , " - " , " . " , . . ' ' . , . ' ' , . " # # " , " - " , " " . . _ , . ' ' , . " " , . " # # " , " - " . . _ , . ' ' , . Листинг . . . . . _ , ' ' , " - . " , . . . _ , ' ' , " - . " , . . . _ , ' ' , " " " - ' ' . " , . . . _ , ' ' , " - . " , . . . _ , ' ' , " " " - ' ' . " , . . . _ , ' ' , " - . " , . Листинг . . . ' \ ' " " . . , . . , , Листинг . продолжение . . . . . . : " : . " _ : . " - % . " , _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , _ : . " - % ' % ' . " , , _ : . " - % . " , " " , _ , _ , _ _ , _ , _ , _ , _ , _ Листинг . . . , , , . . : . " , " . . . . . . , . " " . , . " # " . , . " # # " Листинг . продолжение . , . . _ , , ! . . . _ _ , , . . . . " - " . . . . . _ , , . . . . . " - " " " " " . ! . . ? " " : . " " . ? : . . ? : . . . Основные изменения в классе свелись к удалениям . Большая часть кода ушла из в . Хорошо . Мы также переместили все разновидности в отдельные файлы . Еще лучше ! Одним из важнейших аспектов хорошей программной архитектуры является логическое разбиение кода — создание подходящих мест для размещения разных кодовых блоков . Разделение ответственности заметно упрощает понимание и сопровождение кода . Обратите внимание на метод класса . Очевидно , размещение форматирования сообщения об ошибках нарушает принцип единой ответственности . Класс должен заниматься обработкой аргументов , а не форматом сообщений об ошибках . Но насколько логично размещать код форматирования сообщений в ? Откровенно говоря , это компромиссное решение . Пользователям , которым не нравится , что сообщения об ошибках поставляет класс , придется написать собственную реализацию . К этому моменту мы уже вплотную подошли к окончательному решению , приведенному в начале этой главы . Завершающие преобразования остаются читателю для самостоятельных упражнений . Заключение Заставить код работать недостаточно . Работоспособный код часто несовершенен . Программисты , которые заставляют свой код работать и на этом считают свою задачу выполненной , ведут себя непрофессионально . Возможно , они опасаются , что у них не хватит времени для совершенствования структуры и архитектуры кода , но я не могу с этим согласиться . Ничто не оказывает настолько всестороннего и длительного отрицательного влияния на судьбу программного проекта , как плохой код . Плохой график можно переделать , плохие требования можно переопределить . Плохую динамику рабочей группы еще можно исправить . Плохой код загнивает и разбухает , превращаясь в беспощадныйгруз , который тянет группу ко дну . Сколько раз я видел , как работа заходит в тупик по одной причине : в спешке вместо добротного кода создавалась какая - то безобразная мешанина , которая после этого обрекала группу на бесконечные мучения . Конечно , плохой код можно вычистить . Но это обходится очень дорого . В процессе загнивания кода модули постепенно проникают друг в друга , образуется множество скрытых и запутанных зависимостей . Поиск и разрыв старых зависимостей — длительная , тяжелая работа . С другой стороны , поддерживать чистоту в коде относительно несложно . Если утром вы устроили беспорядок в модуле , то его будет легко вычистить днем . Или еще лучше , если вы устроили беспорядок пять минут назад , то его будет очень легковычистить прямо сейчас . Итак , постоянно следите за тем , чтобы ваш код оставался как можно более простым и чистым . Не допускайте , чтобы он начал загнивать . Глава . Внутреннее строение Картинка : _ . — одна из самых известных инфраструктур для языка . Как и положено нормальной инфраструктуре , она концептуально проста , точна в определениях и элегантна в реализации . Но как выглядит ее код ? В этой главе мы покритикуем пример , взятый из инфраструктуры . Инфраструктура У много авторов , но все началось с совместного перелета Кента Бека и Эрика Гамма в Атланту . Кент хотел освоить , а Эрик собирался заняться изучением тестовой инфраструктуры Кента для языка . «А что может быть более естественным для двух „технарей“ , запертых в тесном пространстве , чем достать портативные компьютеры и взяться за программирование ? » За три часа «высотной работы» были написаны основы . Модуль , который мы рассмотрим в этой главе , предназначен для выявления ошибок сравнения строк . Он называется . Получив две различающиеся строки например , и , он выдает сводку различий между ними , генерируя строку вида … … . Я мог бы объяснить и подробнее , но тестовые сценарии сделают это лучше . Просмотрите листинг . и вы отлично поймете требования этого модуля . А заодно критически проанализируйте структуру тестов . Нельзя ли упростить их , сделать более наглядными ? Листинг . . . . . . . . . , " " , " " . " " " : : " . , " " , " " . « : : » , , " " , " " . " : : " , , " " , " " . " : : " , , " " , " " . " : … … : … … " , , " " , " " . " : : " , , " " , " " . " : … … : … … " , , " " , " " . " : : " , , " " , " " . " : … : … " , , " " , " " . " : : " , , " " , " " . " : … … : … … " , , " " , " " . " : : " , , " " , " " . " : … … : … … " , , " " , " " . " : … : … " , Листинг . продолжение , " " , . " : : " , , " " , . " : : " , , , " " . " : : " , , , " " . " : : " , , " " , " " . " : : " , Я провел для анализ покрытия кода на основе этих тестов . В ходе тестирования обеспечивалось % - ное покрытие : была выполнена каждая строка кода , каждая команда и цикл . Я удостоверился в том , что код работает правильно , а также преисполнился уважения к мастерству его авторов . Код приведен в листинге . . Не жалейте времени и как следует разберитесь в нем . Вероятно , вы согласитесь с тем , что код достаточно выразителен , обладает логичным разбиением и простой структурой . А когда вы закончите , мы вместе начнем придираться к мелочам . Листинг . . . исходный код . " … " _ " " _ " " , , | | | | . , , . , , _ . , . - _ . . , . . ! . . - . - - - , - - . ! . . - Листинг . продолжение ? : " " . . , - , . . - , . . . - , . - . - ? : " " . Вероятно , вы найдете в этом модуле некоторые недочеты . В нем встречаются длинные выражения , какие - то малопонятные и т . д . Но в целом модуль весьма хорош . В конце концов , он мог бы выглядеть и так , как показано в листинге . . Листинг . . . переработанная версия . , , . . . | | | | . . , , . . , . . ! . . - . - - - , - - . ! . . - . , , " " . , . - " " ? " … " : " " . . , - , . . - , . . . - , . - . - ? " … " : " " Авторы оставили эту модуль в очень хорошей форме . И все же «правило бойскаута » гласит : все нужно оставлять чище , чем было до вашего прихода . Итак , как же улучшить исходный код в листинге . ? Первое , что мне решительно не понравилось , — префикс у имен переменных классов . В современных средах разработки подобное кодирование области видимости излишне . Давайте уберем все префиксы : Также бросается в глаза неинкапсулированная условная команда в начале функции . | | | | . , , . . . , , Инкапсуляция поможет лучше выразить намерения разработчика . Поэтому я создал метод с именем , поясняющим его смысл : . , , . . . , , | | | | Запись . и . в функции тоже оставляет желать лучшего . Это произошло , когда мы переименовали в . Зачем в функции используются переменные с именами , совпадающими с именами переменных класса ? Ведь они имеют разный смысл ? Неоднозначность в именах следует исключить . Отрицательные условия чуть сложнее для понимания , чем положительные . Чтобы проверяемое условие стало более понятным , мы инвертируем его : . , , . , , ! ! ! Имя функции выглядит немного странно . Хотя она выполняет сжатие строк , этого не произойдет , если вернет . Таким образом , выбор имени скрывает побочный эффект проверки . Также обратите внимание на то , что функция возвращает отформатированное сообщение , а не просто сжатые строки . Следовательно , функцию былобы правильнее назвать . В этом случае она гораздо лучше читается вместе с аргументом : Тело команды — то место , где выполняется фактическое сжатие строк и . Мы извлечем этот код в метод . Тем не менее все форматирование должно происходить в функции . Функция … не должна делать ничего , кроме сжатия . Разобьем ее следующим образом : … … . , , . , , Обратите внимание : это преобразование заставило нас повысить и до переменных класса . Еще мне не нравится то , что в двух последних строках новой функции возвращаются переменные , а в первых двух — нет . Это противоречит рекомендациям по использованию единых конвенций . Значит , функции и следует изменить так , чтобы они возвращали значения префикса и суффикса . . . , . . ! . . - . - - - , - - . ! . . - Также следует изменить имена переменных класса так , чтобы они стали чуть более точными в конце концов , обе переменные представляют собой индексы . Тщательное изучение выявляет скрытую временную привязку работа функции зависит от того , что значение вычисляется функцией . Если вызвать эти две функции в неверном порядке , вам предстоит непростой сеанс отладки . Чтобы эта временная привязка стала очевидной , значение будет передаваться при вызове в аргументе . . - . - - - , - - . ! . . - Но и такое решение оставляет желать лучшего . Передача аргумента выглядит нелогично . Она устанавливает порядок вызова , но никоим образом не объясняет необходимость именно такого порядка . Другой программист может отменить внесенное изменение , так как ничто не указывает на то , что этот параметр действительно необходим . . - . - - - , - - . ! . . - . . , . . ! . Функции и возвращаются к прежнему виду , функция переименовывается в , и в нее включается вызов до выполнения каких - либо других действий . Тем самым временная связь двух функций устанавливается гораздо более радикально , чем в предыдущем решении . Кроме того , новое решение со всей очевидностью демонстрирует , насколько уродлива функция . Давайте немного почистим ее . ! , ! , , . . - . - | | . - Так гораздо лучше . Новая версия кода очевидно показывает , что в действительности определяетдлинусуффикса , а прежнее имя было выбрано неудачно . Это относится и к , хотя в данном случае «индекс» и «длина» являются синонимами . Несмотря на это , использование термина «длина» выглядит более последовательно . Проблема в том , что значение переменной отсчитывается не от , а от , так что называть его «длиной» не совсем корректно кстати , этим же обстоятельством объясняются загадочные прибавления в . Давайте исправим этот недостаток . Результат показан в листинге . . Листинг . . . промежуточная версия … … ! , ! , , . . - - . - | | . - … _ . , . - _ … . . - , . . . - , . - . - ? : " " Все в были заменены на - в , где это смотрится абсолютно логично также были изменены два оператора в , где это тоже абсолютно логично . Это позволило переименовать в , с заметным улучшением удобочитаемости кода . Однако здесь возникла одна проблема . В ходе устранения я заметил в следующую строку : Найдите ее в листинге . . Так как стало на меньше , чем было прежде , мне следовало бы заменить оператор оператором , но это выглядит нелогично . При более внимательном анализе мы видим , что команда предотвращает присоединение суффикса с нулевой длиной . Но до внесения изменений команда была бесполезной , потому что значение не могло быть меньше ! Это ставит под сомнение полезность обеих команд в ! Похоже , обе команды можно исключить . Закомментируем их и проведем тестирование . Тесты прошли ! Давайте изменим структуру , чтобы удалить лишние команды и значительно упростить самую функцию . _ . , . - _ Стало гораздо лучше ! Теперь мы видим , что функция просто соединяет фрагменты строки . Вероятно , этот факт можно сделать еще более очевидным . Осталось еще много мелких улучшений , которые можно было бы внести в код . Но я не стану мучить вас подробными описаниями остальных изменений и просто приведу окончательный результат в листинге . . Листинг . . . окончательная версия . " … " _ " " _ " " Листинг . продолжение , , . . . . , , ! | | | | . ! , ! , , . . - - . - | | . - . . , . . ! . . . . _ . . _ . . . ? : " " . , - . , . - . , . - . , . . , ? : " " Результат выглядит вполне симпатично . Модуль делится на группы : первую группу составляют функции анализа , а вторую — функции синтеза . Функции топологически отсортированы таким образом , что определение каждой функции размещается перед ее первым использованием . Сначала определяются все функции анализа , а за ними следуют функции синтеза . Внимательно присмотревшись , можно заметить , что я отменил некоторые решения , принятые ранее в этой главе . Например , некоторые извлеченные методы были снова встроены в , а смысл выражения снова изменился . Это типичная ситуация . Одна переработка часто приводит к другой , отменяющей первую . Переработка представляет собой итеративный процесс , полный проб и ошибок , но этот процесс неизбежно приводит к формированию кода , достойного настоящего профессионала . Заключение Итак , «правило бойскаута» выполнено : модуль стал чище , чем был до нашего прихода . И дело не в том , что он был недостаточно чист , — авторы отлично потрудились над ним . Однако не существует модуля , который нельзя было бы улучшить , и каждый из нас обязан оставить чужой код хотя бы немного лучше , чем он был . Глава . Переработка Картинка : _ . Посетив страницу : . . . , вы найдете на ней описание библиотеки . Глубоко в недрах этой библиотеки скрыт пакет . . . Пакет содержит класс с именем . В этой главе мы займемся анализом этого класса . Класс написан Дэвидом Гилбертом . Несомненно , Дэвид является опытным и компетентным программистом . Как вы сами убедитесь , в этом коде он проявил значительную степень профессионализма и дисциплины . Во всех отношениях это «хороший код» . А сейчас я намерен разнести его в пух и прах . Дело вовсе не в злом умысле . И я вовсе не считаю , что я намного лучше Дэвида и поэтому имею право критиковать его код . Действительно , если заглянуть в мой код , я уверен , что вы найдете в нем немало поводов для критики . Нет , дело не в моем скверном характере или надменности . Я всего лишь намерен проанализировать код с профессиональной точки зрения , не более и не менее . Это то , что все мы должны делать спокойно и без угрызений совести . И все мы должны только приветствовать , когда такой анализ кто - то проводит за нас . Только после подобной критикимы узнаем нечто новое . Это делают врачи . Это делают пилоты . Это делают адвокаты . И мы , программисты , тоже должны этому научиться . И еще одно замечание по поводу Дэвида Гилберта : Дэвид — не просто хороший программист . У него хватило смелости и доброй воли на то , чтобы бесплатно предоставить свой код сообществу . Дэвид разместил свой код в открытом доступе и предложил всем желающим использовать и обсуждать его . Отличная работа ! Класс листинг Б . , с . представляет даты в языке . Зачем нужен класс для представления дат , если в уже имеются готовые классы . . , . . и т . д . ? Автор написал свой класс из - за проблемы , с которой часто сталкивался сам . Ее суть хорошо разъясняется в открывающем комментарии строка . Возможно , кому - то такое решение покажется радикальным , но мне и самому приходилось сталкиваться с этой проблемой , и я приветствую класс , ориентированный на работу с датой вместо времени . Прежде всего — заставить работать В классе содержится набор модульных тестов листинг Б . , с . . Все тесты проходят . К сожалению , беглое изучение тестов показывает , что тестирование не покрывает часть кода . Например , поиск показывает , что метод строка не используется . Соответственно он не включается в модульные тесты . Итак , я запустил , чтобы узнать , какая часть кода реально покрывается модульными тестами . сообщает , что модульные тесты выполняют только из исполняемых команд около % . Карта покрытия напоминала лоскутное одеяло , а по всему классы были разбросаны большие пятна невыполняемого кода . Моей целью было полное понимание и переработка кода этого класса . Я не мог добиться этого без значительного улучшения тестового покрытия , поэтому мне пришлось написать собственный набор абсолютно независимых модульных тестов листинг Б . , с . . Просматривая код тестов , можно заметить , что многие из них закомментированы . Эти тесты не проходили в исходном варианте . Однако они представляют поведение , которым , на мой взгляд , должен обладать класс . Соответственно , в ходе переработки я буду работать над тем , чтобы эти тесты тоже проходили . Даже с несколькими закомментированными тестами сообщает , что новые модульные тесты покрывают % из исполняемых команд . Неплохо , хотя я думаю , что и этот показатель можно улучшить . Возможно , в нескольких первых закомментированных тестах строки – я слегка хватил через край . Их прохождение не было формально заложено при проектировании программы , но данное поведение казалось мне абсолютно очевидным . Я не знаю , зачем создавался метод , но раз уж он был написан , казалось очевидным , что в работе метода не должен учитываться регистр символов . Написать соответствующий тест было элементарно . Заставить его работать было еще проще я просто изменил строки и , чтобы в них использовалась функция . Тесты в строках и остались закомментированными , так как мне было неясно , нужно ли поддерживать сокращения вида « » и « » . Тесты в строках и не проходят . Хотя , естественно , должны проходить . Проблема а заодно и тесты в строках – легко исправляется внесением следующих изменений в функцию . | | - . . . Закомментированный тест в строке выявляет ошибку в методе строка . декабря года было субботой . Следующей субботой было января года . Тем неменее при запуске теста утверждает , что первой субботой , предшествующей декабря , было декабря . Разумеется , это неверно , . Проблема — типичная ошибка граничного условия — кроется в строке . Строка должна читаться следующим образом : Интересно , что проблемы с этой функцией возникали и раньше . Из истории изменений строка видно , что в функциях , и «исправлялись ошибки» . Модульный тест строка , проверяющий работу метода строка , изначально был не таким длинным и исчерпывающим , как в окончательной версии . Я включил в него много дополнительных тестовых сценариев , потому что не все исходные тесты проходили успешно . Посмотрите , какие тестовые сценарии были закомментированы — закономерность проявляется достаточно очевидно . Сбой в алгоритме происходит в том случае , если ближайший день находится в будущем . Очевидно , и здесьпроисходит какая - то ошибка граничного условия . Результаты тестового покрытия кода , полученные от , тоже весьма интересны . Строка никогда не выполняется ! Следовательно , условие в строке всегда ложно . С первого взгляда на код понятно , что это действительно так . Переменная всегда отрицательна , она не может быть больше либо равна . Значит , алгоритм попросту неверен . Правильный алгоритм выглядит так : - . % - . , Наконец , для прохождения тестов в строках и достаточно инициировать исключение вместо возвращения строки ошибки в функциях и . После таких изменений все модульные тесты проходят . Вероятно , класс теперь действительно работает . Теперь пришло время «довести его до ума» . …Потом очистить код Мы проанализируем код от начала до конца , усовершенствуя его в ходе просмотра . Хотя ниже об этом не упоминается , после каждого вносимого изменения выполнялись все модульные тесты , включая мой доработанный модульный тест . Итак , вы можете быть уверены в том , что вносимые изменения не нарушают работы . Начнем со строки . В ней приводятся многословные комментарии с информацией о лицензии , авторских правах , авторах и истории изменений . Бесспорно , существуют некоторые юридические формальности , которые необходимо соблюдать , поэтому авторские права и лицензии должны остаться . С другой стороны , история изменений является пережитком из - х годов . Сегодня у нас имеются системы управления исходным кодом , которые все это делают за нас . Историю следует удалить . Список импорта , начинающийся в строке , следует сократить при помощи конструкций . . и . . . К форматированию в строка я отношусь без восторга . Меня беспокоят исходные файлы , написанные более чем на одном языке . В этом комментарии встречаются четыре языка : , английский , и . При таком количестве языков трудно поддерживать порядок в коде . Например , аккуратное размещение строк и теряется при генерировании кода , да и кому захочется видеть теги и в исходном коде ? Правильнее было бы просто заключить весь комментарий в теги , чтобы форматирование в исходном коде сохранилось в . Строка содержит объявление класса . Почему этот класс называется ? Почему в нем присутствует слово « » — только потому , что класс объявлен производным от ? Это выглядит маловероятно . Не буду держать вас в неведении . Я знаю или по крайней мере полагаю , что знаю , почему было использовано слово « » . На это указывают константы _ _ и _ _ в строках и . Еще более очевидная подсказка содержится в комментарии , начинающемся в строке . Класс назван , потому что его реализация построена на использовании «порядкового номера» , то есть количества дней с декабря года . На мой взгляд , у такого решения два недостатка . Во - первых , термин «порядковый номер» некорректен . Кому - то это покажется пустяком , но выбранное представление представляет собой относительное смещение , а не порядковый номер . Термин «порядковый номер» скорее относится к маркировке промышленных изделий , а не к датам . Так что , на мой взгляд , название получилось не слишком содержательным . Второй недостаток более важен . Имя подразумевает определенную реализацию . Однако класс является абстрактным и для него реализацию скорее нужно скрывать ! Я считаю , что выбранное имя находится на неверном уровне абстракции . По моему мнению , класс было бы лучше назвать . К сожалению , в библиотеку входит слишком много классов с именем вероятно , это не лучший вариант . Поскольку класс скорее ориентирован на работу с сутками , я подумывал о том , чтобы назвать его , но и это имя часто используется в других местах . В конечном итоге я решил , что лучшим компромиссом будет имя . В дальнейшем обсуждении будет использоваться имя . Не забывайте , что в листингах , на которые вы будете смотреть , класс по - прежнему называется . Я понимаю , почему наследует от и . Но почему он наследует от ? Класс листинг Б . , с . представляет собой простой набор статических констант , определяющих месяцы . Наследование от классов с константами — старый трюк , который использовался - программистами , чтобы избежать выражений вида . , но это неудачная мысль . следовало бы оформить в виде перечисления . , , , , , , , , , , , , . : . . " " Преобразование в инициирует ряд изменений в классе и всех его пользователях . На внесение всех изменений мне потребовалось около часа . Однако теперь любая функция , прежде получавшая вместо месяца , теперь получает значение из перечисления . Это означает , что мы можем удалить метод строка , а также все проверки ошибок кодов месяцев — например , строка . Далее возьмем строку , . Переменная используется для управления сериализацией данных . Если изменить ее , то данные , записанные старой версией программы , перестанут читаться , а попытки приведут к исключению . Если вы не объявите переменную , компилятор автоматически сгенерирует ее за вас , причем значение переменной будет различаться при каждом внесении изменений в модуль . Я знаю , что во всей документации рекомендуется управлять этой переменной вручную , но мне кажется , что автоматическое управление сериализацией надежнее . В конце концов , я предпочитаю отлаживать исключение , чем необъяснимое поведение программы в результате того , что я забыл изменить . Итак , я собираюсь удалить эту переменную — по крайней мере пока . Комментарий в строке выглядит избыточным . Избыточные комментарии только распространяют лживую и недостоверную информацию . Соответственно , я удаляю его вместе со всеми аналогами . В комментариях в строках и упоминаются порядковые номера , о которых говорилось ранее . Комментарии описывают самую раннюю и самую позднюю дату , представляемую классом . Их можно сделать более понятными . _ _ _ _ Мне неясно , почему значение _ _ равно , а не . Комментарий в строке подсказывает , что это как - то связано с представлением дат в . Более подробное объяснение содержится в производном от классе с именем листинг Б . , с . . Комментарий в строке хорошо объясняет суть дела . Проблема в том , что такой выбор относится к реализации и не имеет ничего общего с . Из этого я заключаю , что _ _ и _ _ реально не относятся к и их следует переместить в . Поиск по коду показывает , что эти переменные используются только в . Они не используются ни в , ни в других классах . Соответственно , я перемещаю их в . Со следующими переменными , _ _ и _ _ строки и , возникает дилемма . Вроде бы понятно , что если является абстрактным классом , то он не должен содержать информации о минимальном или максимальном годе . У меня снова возникло искушение переместить эти переменные в . Тем не менее поиск показал , что эти переменные используются еще в одном классе : листинг Б . , с . . В строках и функция проверяет , что в ее аргументе передается действительный год . Дилемма состоит в том , что пользователю абстрактного класса необходима информация о его реализации . Наша задача — предоставить эту информацию , не загрязняя самого класса . В общем случае мы могли бы получить данные реализации из экземпляра производного класса , однако функция не получает экземпляр . С другой стороны , она возвращает такой экземпляр , а это означает , что она его где - то создает . Из строк – можно заключить , что экземпляр создается при вызове одной из трех функций : , или . Обратившись к листингу , мы видим , что все эти функции строки – возвращают дату , созданную функцией строка , которая вызывает строка , которая создает ! . В общем случае базовые классы не должны располагать информацией о своих производных классах . Проблема решается применением паттерна АБСТРАКТНАЯ ФАБРИКА и созданием класса . Фабрика создает экземпляры , а также предоставляет информацию по поводу реализации — в частности , минимальное и максимальное значение даты . . _ _ , . , _ , , _ . . _ _ . _ , . , . _ , , , , . _ , , . . . _ . _ . _ Фабрика заменяет методы методами , в результате чего имена выглядят гораздо лучше . По умолчанию используется , но этот класс можно в любой момент заменить другой фабрикой . Статические методы , делегирующие выполнение операций абстрактным методам , используют комбинацию паттернов СИНГЛЕТ , ДЕКОРАТОР и АБСТРАКТНАЯ ФАБРИКА . Класс выглядит так : _ _ , . , , , _ , , , , _ . . . , . . . . , . . _ . _ _ _ . _ _ Как видите , я уже переместил переменные _ _ и _ _ в класс , в котором им положено находиться . Следующая проблема — константы дней , начинающиеся со строки . Их следует оформить в виде другого перечисления . Мы уже видели , как это делается , поэтому я не буду повторяться . При желании посмотрите в итоговом листинге . Далее мы видим серию таблиц , начинающуюся с _ _ _ в строке . Моя первая претензия к этим таблицам состоит в том , что описывающие их комментарии избыточны . Одних имен вполне достаточно , поэтому я собираюсь удалить комментарии . Также неясно , почему эта таблица не объявлена приватной , потому что в классе имеется статическая функция , предоставляющая те же данные . Следующая таблица , _ _ _ _ _ , выглядит загадочно — она ни разу не используется в . Я удалил ее . То же произошло с _ _ _ _ _ _ _ . Следующая таблица , _ _ _ _ _ _ , используется только в строки и . Так почему бы не переместить ее в ? Против перемещения говорит тот факт , что таблица не привязана ни к какой конкретной реализации . С другой стороны , никаких реализаций , кроме , фактически не существует , поэтому таблицу следует переместить ближе к месту ее использования . Для меня решающим обстоятельством является то , что для обеспечения логической согласованности таблицу следует объявить приватной и предоставить доступ к ней через функцию вида . Но похоже , такая функция никому не нужна . Более того , если этого потребует новая реализация , таблицу можно будет легко вернутьна место . Поэтому я ее переместил . Далее следуют три группы констант , которые можно преобразовать в перечисления строки – . Первая из трех групп предназначена для выбора недели в месяце . Я преобразовал ее в перечисление с именем . , , , , . Со второй группой констант строки – дело обстоит сложнее . Константы _ , _ , _ и _ определяют , должны ли включаться в диапазон конечные даты . В математике в подобных случаях используются термины «открытый интервал» , «полуоткрытый интервал» и «замкнутый интервал» . Мне кажется , что математические названия выглядят более понятно , поэтому я преобразовал группу в перечисление с элементами , _ , _ и . Третья группа констант строки – определяет , должно ли в результате поиска конкретного дня недели возвращаться последнее , предыдущее или ближайшее вхождение . Выбрать подходящее имя для такого перечисления непросто . В итоге я остановился на имени с элементами , и . Возможно , вы не согласитесь с выбранными мной именами . Мне они кажутся логичными , но у вас может быть свое мнение . Однако сейчас константы приведены к форме , которая позволяет легко изменить их в случае необходимости . Они передаются не в виде целых чисел , а в виде символических имен . Я могу воспользоваться функцией переименования своей рабочей среды для изменения имен или типов , не беспокоясь о том , что я пропустил где - то в коде - или или объявление аргумента осталось плохо описанным . Поле в строке нигде не используется . Я удалил его вместе с методами доступа . Также был удален вырожденный конструктор по умолчанию в строке . Компилятор сгенерирует его за нас . Метод строки – пропускаем — мы удалили его при создании перечисления . Мы подходим к методу строки – . Комментарии , не добавляющие полезной информации к сигнатуре метода , только загромождают код , . В комментарии есть всего один содержательный момент — он описывает возвращаемое значение - . Но после перехода на перечисление этот комментарий стал неверным . Сейчас метод сообщает об ошибке , выдавая исключение . Я удалил комментарий . Также я удалил все ключевые слова в объявлениях аргументов и переменных . На мой взгляд , реальной пользы от них не было , а программу они загромождают . Удаление противоречит мнению некоторых экспертов . Например , Роберт Симмонс , . настоятельно рекомендует «…почаще вставлять в своем коде» . Разумеется , я с этим не согласен . У имеются свои полезные применения например , при объявлении отдельных констант , но в остальных случаях это ключевое слово не приносит реальной пользы . Возможно , я так считаю еще и потому , что типичные ошибки , выявляемые при помощи , уже выявляются написанными мной модульными тестами . Мне не понравились повторяющиеся команды внутри цикла строки и они были объединены в одну команду при помощи оператора | | . Также я использовал перечисление для управления циклом и внес ряд других косметических изменений . Мне пришло в голову , что метод в действительности не принадлежит . Фактически это функция разбора , поэтому я переместил ее в перечисление . Но после этого перечисление стало занимать довольно много места . Поскольку концепция не зависит от , я вывел перечисление из класса в собственный исходный файл . Кроме того , я переместил следующую функцию строки – в перечисление и переименовал ее в . . , . , . , . , . , . , . : . . . " : % . " , . . . : . . . | | . . . " % " , . В программе две функции строки – первая функция вызывает вторую . Вторая функция не вызывается никем , кроме первой функцией . Я свернул две функции в одну , что привело к значительному упрощению кода , , . В завершение я переименовал итоговую функцию , присвоив ей более содержательное имя . . Функция строки – потеряла актуальность после введения перечисления , поэтому я ее удалил . Функция строки – отдает ФУНКЦИОНАЛЬНОЙ ЗАВИСТЬЮ вероятно , ее логичнее включить в перечисление в виде метода с именем . Я выполнил замену . - В результате перечисление стало достаточно большим для выделения в отдельный класс . Я убрал его из по образцу перечисления , . Следующие два метода называются строки – . И снова мы видим , как один метод вызывает своего «двойника» с передачей флага . Обычно передавать флаг в аргументе не рекомендуется , особенно если он просто выбирает формат вывода . Я переименовал , упростил и реструктурировал эти функции и переместил их в перечисление , , , . . - . - Далее в листинге идет метод строки – . Я переименовал его , переместил в перечисление и упростил , , , , . . : . . . " " . | | . Метод строки – можно сделать более выразительным . % % % ! | | Следующая функция , строки – , не принадлежит . Она не вызывается никем , кроме двух методов . Я переместил ее в производный класс . Функция строки – использует массив _ _ _ . Этот массив принадлежит перечислению , поэтому функция была перемещена . Заодно я упростил ее код исделал его более выразительным . , . . . Начинается самое интересное . Далее в листинге идет функция строки – . Прежде всего , поскольку эта функция работает с переменными , она не должна быть статической . Соответственно , я преобразовал ее в метод экземпляра . Также она вызывает функцию , которую правильнее называть . Наконец , метод можно несколько упростить . . Сказанное относится и к функции строки – . Она должна быть оформлена в виде метода экземпляра . Алгоритм относительно сложен , поэтому я воспользовался ПОЯСНИТЕЛЬНЫМИ ВРЕМЕННЫМИ ПЕРЕМЕННЫМИ , чтобы сделать его смысл более прозрачным . Заодно метод был переименован в . . - . % , . , . , , Функция строки – преобразуется по тем же принципам , что и ее аналоги . , . , . , , Преобразование статических методов в методы экземпляров вызвало у меня некоторое беспокойство . Поймет ли читатель при виде выражения . , что объект не изменяется , а вместо этого возвращается новый экземпляр ? Или он ошибочно решит , что к объекту прибавляются пять дней ? Казалось бы , проблема не столь серьезна , но конструкции вроде следующей могут оказаться очень коварными . . , . , . Смещение на одну неделю . Скорее всего , читатель кода предположит , что вызов изменяет объект . Значит , нам понадобится имя , разрушающее эту двусмысленность . Я переименовал методы в и . Мне кажется , что предназначение данного метода отлично отражается конструкциями вида . С другой стороны , следующая конструкция читается недостаточно бегло , чтобы читатель сразу предположил , что изменяется объект : . Алгоритмы становятся все интереснее . Функция строки – работает , но выглядит слишком сложно . После некоторых размышлений относительно того , что же в действительности происходит в этой функции , мне удалось упростить ее и воспользоваться ПОЯСНИТЕЛЬНЫМИ ВРЕМЕННЫМИ ПЕРЕМЕННЫМИ , чтобы сделать код более понятным . Я также преобразовал статический метод в метод экземпляра и избавился от дублирующего метода экземпляра строки – . . - . - Абсолютно такой же анализ с тем же результатом был проведен для метода строки – . . - . Далее идет функция строки – , которую мы исправляли на с . . Внесенные тогда изменения не соответствуют тому шаблону , по которому были преобразованыдве последние функции . Я преобразовал функцию по тем же правилам , а также воспользовался ПОЯСНИТЕЛЬНЫМИ ВРЕМЕННЫМИ ПЕРЕМЕННЫМИ для разъяснения алгоритма . . - . % - Метод строки – выглядит немного странно — перед нами метод экземпляра , который «завидует» собственному классу , получая аргумент . Я преобразовал его в полноценный метод экземпляра , а также заменил несколько имен более содержательными . , . , , Переработка строки – оказалась очень интересным делом . Используя средства рефакторинга своей , я сначала переместил метод в перечисление , созданное ранее на с . . Затем я переименовал его в и преобразовал из статического метода в метод экземпляра . Все тесты прошли успешно . Догадываетесь , к чему я клоню ? Затем я полностью удалил метод ! Пять проверок завершились неудачей строки – , листинг Б . , с . . Я изменил эти строки так , чтобы в них использовались имена из перечисления , , . . . . И все тесты прошли . А вы догадываетесь , почему ? И понимаете ли вы , почему каждый из этих шагов был необходим ? Функция рефакторинга проследила за тем , чтобы все предыдущие вызовы были заменены вызовами для перечисления , а во всех перечислениях реализация просто возвращает имена… К сожалению , мои ухищрения ни к чему не привели . Как бы элегантно ни выглядела эта замечательная цепочка рефакторинга , в итоге я понял , что единственными пользователями этой функции были тесты , которые я только что изменил . И я удалил тесты . Стыдно дважды наступать на одни грабли ! Определив , что функция строки – не вызывается нигде , кроме тестов , я просто удалил функцию вместе с ее тестами . Наконец - то мы добрались до абстрактных методов абстрактного класса . Первый метод выглядит знакомо : строки – . На с . я присвоил ему имя . Рассматривая его в новом контексте , я решил , что его лучше переименовать в . Следующий абстрактный метод , строки – , преобразует в . . . Почему метод объявлен абстрактным ? Присмотревшись к его реализации в строки – , листинг Б . , с . , мы видим , что он не зависит ни от каких подробностей реализации класса . Поэтому я поднял его на более высокий уровень абстракции . Методы , и абстрактны . Метод — еще один метод , который следовало бы извлечь из — тоже не зависит от . Или все - таки зависит ? Присмотревшись внимательно строка , листинг Б . , с . , мы видим , что алгоритм неявно зависит от «точки отсчета» дней недели иначе говоря , от того , какой день недели считается днем . Таким образом , хотя функция не имеет физических зависимостей , которые нельзя было бы переместить в , у нее имеются логические зависимости . Подобные логические зависимости беспокоят меня . Если что - то зависит от реализации на логическом уровне , то что - то должно зависеть и на физическом уровне . Кроме того , мне кажется , что сам алгоритм можно было бы сделать более универсальным , чтобы существенно меньшая его часть зависела от реализации . Я создал в абстрактный метод с именем и реализовал его в так , чтобы он возвращал . . Затем я переместил метод наверх по цепочке в и изменил его так , чтобы в нем вызывались методы и . . - . . . % Заодно присмотритесь к комментарию в строках с по . Так ли необходимо это повторение ? Как и в предыдущих случаях , я удалил этот комментарий вместе со всеми остальными . Переходим к следующему методу строки – . Уровень абстракции этого метода снова выбран неправильно , поэтому я поднял его реализацию в . Кроме того , его имя недостаточно содержательно . В действительности этот метод возвращает промежуток в днях , начиная с аргумента , поэтому я переименовал его в . Также я заметил , что для этого метода нет ни одного теста , и написал их . Следующие шесть функций строки – представляют собой абстрактные методы , которые должны реализовываться в . Я извлек из . Последнюю функцию строки – также необходимо извлечь и переработать . Команда выглядит некрасиво ее можно заменить , переместив условия в перечисление . , , , _ , , , _ , , , , , , , , , . . , . . . , . . , , Мы подошли к концу класса . Сейчас я еще раз пройдусь по всему классу и напомню , что было сделано . Открывающий комментарий был слишком длинным и неактуальным я сократил и доработал его . Затем все оставшиеся перечисления были выделены в отдельные файлы . Статическая переменная и три статических метода , , были выделены в новый класс с именем . Абстрактные методы были перемещены на более высокий уровень абстракции , где они были более уместными . Я переименовал . в . и проделал то же самое для всех остальных перечислений . Для всех перечислений был создан метод доступа , а поле было объявлено приватным . В и присутствовало дублирование кода , которое мне удалось устранить введением нового метода . При этом код всех трех методов стал более понятным . «Волшебное число» было заменено соответствующей конструкцией . . или . . . Я потратил некоторое время на доработку класса и чистку алгоритмов . Конечный результат представлен в листингах с Б . с . по Б . с . . Интересно заметить , что покрытие кода в уменьшилосьдо , % ! Это объясняется не снижением объема тестируемой функциональности просто класс сократился , и несколько непокрытых строк имеют больший удельный вес . В классе тесты покрывают из исполняемых команд . Непокрытые строки настолько тривиальны , что не нуждаются в тестировании . Заключение Мы снова последовали «правилу бойскаута» : код стал немного чище , чем был до нашего прихода . На это потребовалось время , но результат того стоил . Тестовое покрытие кода увеличилось , были исправлены некоторые ошибки , код стал чище и компактнее . Хочется верить , что следующему человеку , который будет читать этот код , будет проще в нем разобраться , чем нам . И возможно , этот человек сможет сделать этот код еще чище , чем удалось нам . Литература : : , . , - , . : , , . , ’ , . : : , . , - , . : , , , . Глава . Запахи и эвристические правила Картинка : _ . В своей замечательной книге « » Мартин Фаулер описывает много различных «запахов кода» . Следующий список содержит много «запахов» , предложенных Мартином , а также ряд моих собственных дополнений . Кроме того , в него были включены некоторые приемы и эвристические правила , которые я часто применяю в своей работе . Чтобы построить этот список , я просмотрел и переработал несколько разных программ . При внесении каждого изменения я спрашивал себя , почему я это делаю , и записывалрезультат . Так появился довольно длинный список того , что , на мой взгляд , «дурно пахнет» при чтении кода . Предполагается , что вы будете читать список от начала к концу , а также использовать его как краткий справочник . Обратитесь к приложению В на с . , где собраны перекрестные ссылки , указывающие , где в тексте книги упоминалось то или иное эвристическое правило . Комментарии : Неуместная информация В комментариях неуместно размещать информацию , которую удобнее хранить в других источниках : в системах управления исходным кодом , в системах контроля версий и в других системах протоколирования . Например , история изменений только загромождает исходные файлы длинным историческим и малоинтересным текстом . Метаданные авторы , дата последней модификации и т . д . в общем случае также неуместны в комментариях . Комментарии должны быть зарезервированы для технической информации о коде и его архитектуре . : Устаревший комментарий Комментарий , содержимое которого потеряло актуальность , считается устаревшим . Комментарии стареют довольно быстро . Не пишите комментарии , которые с течением времени устареют . Обнаружив устаревший комментарий , обновите его или избавьтесь от него как можно быстрее . Устаревшие комментарии часто «отрываются» от кода , который они когда - то описывали . Так в вашем коде появляются плавучие островки недостоверности и бесполезности . : Избыточный комментарий Избыточным считается комментарий , описывающий то , что и так очевидно . Например : Увеличение переменной Или другой пример — комментарий , который содержит не больше а вернее , меньше полезной информации , чем простая сигнатура функции : @ @ @ Комментарии должны говорить то , что не может сказать сам код . : Плохо написанный комментарий Если уж вы беретесь за написание комментария , напишите его хорошо . Не жалейте времени и позаботьтесь о том , чтобы это был лучший комментарий , который вы способны создать . Тщательно выбирайте слова . Следите за правильностью орфографии и пунктуации . Не пишите сумбурно . Не объясняйте очевидное . Будьте лаконичны . : Закомментированный код Фрагменты закомментированного кода выводят меня из себя . Кто знает , когда был написан этот код ? Кто знает , есть от него какая - нибудь польза или нет ? Однако никто не удаляет закомментированный код — все считают , что он понадобится кому - то другому . Этот код только попусту занимает место , «загнивая» и утрачивая актуальность с каждым днем . В нем вызываются несуществующие функции . В нем используются переменные , имена которых давно изменились . В нем соблюдаются устаревшие конвенции . Он загрязняет модуль , в котором он содержится , и отвлекает людей , которые пытаются его читать . Закомментированный кодотвратителен ! Увидев закомментированный код , удалите его ! Не беспокойтесь , система управления исходным кодом его не забудет . Если кому - то этот код действительно понадобится , то он сможет вернуться к предыдущей версии . Не позволяйте закомментированному коду портить вам жизнь . Рабочая среда : Построение состоит из нескольких этапов Построение проекта должно быть одной тривиальной операцией . Без выборки многочисленных фрагментов из системы управления исходным кодом . Без длинных серий невразумительных команд или контекстно - зависимых сценариев для построения отдельных элементов . Без поиска дополнительных файлов в формате , и других артефактов , необходимых для вашей системы . Сначала вы проверяете систему одной простой командой , а потом вводите другую простую команду для ее построения . : Тестирование состоит из нескольких этапов Всемодульные тесты должны выполняться всего одной командой . В лучшем случае все тесты запускаются одной кнопкой в . В худшем случае одна простая команда вводится в командной строке . Запуск всех тестов — настолько важная и фундаментальная операция , что она должна быть быстрой , простой и очевидной . Функции : Слишком много аргументов Функции должны иметь небольшое количество аргументов . Лучше всего , когда аргументов вообще нет далее следуют функции с одним , двумя и тремя аргументами . Функции счетырьмя и более аргументами весьма сомнительны старайтесь не использовать их в своих программах см . «Аргументы функций» на с . . : Выходные аргументы Выходные аргументы противоестественны . Читатель кода ожидает , что аргументы используются для передачи входной , а не выходной информации . Если ваша функция должнаизменять чье - либо состояние , пусть она изменяет состояние объекта , для которого она вызывалась см . «Выходные аргументы» , с . . : Флаги в аргументах Логические аргументы явно указывают на то , что функция выполняет более одной операции . Они сильно запутывают код . Исключите их из своих программ см . «Аргументы - флаги» , с . . : Мертвые функции Если метод ни разу не вызывается в программе , то его следует удалить . Хранить «мертвый код» расточительно . Не бойтесь удалять мертвые функции . Не забудьте , что система управления исходным кодом позволит восстановить их в случае необходимости . Разное : Несколько языков в одном исходном файле Современные среды программирования позволяют объединять в одном исходном файле код , написанный на разных языках . Например , исходный файл на языке может содержать вставки , , , , , и т . д . Или , скажем , наряду с кодом в файле может присутствовать код , синтаксис библиотеки тегов , комментарии на английском языке , комментарии , , и т . д . В лучшем случае результат получается запутанным , а в худшем — неаккуратным и ненадежным . В идеале исходный файл должен содержать код на одном — и только одном ! — языке . На практике без смешения языков обойтись , скорее всего , не удастся . Но по крайней мере следует свести к минимуму как количество , так и объем кода на дополнительных языках в исходных файлах . : Очевидное поведение не реализовано Согласно «принципу наименьшего удивления » , любая функция или класс должны реализовать то поведение , которого от них вправе ожидать программист . Допустим , имеется функция , которая преобразует название дня недели в элемент перечисления , представляющий этот день . . Логично ожидать , что строка " " будет преобразована в . . Также можно ожидать , что будут поддерживаться стандартные сокращения дней недели , а регистр символовбудет игнорироваться . Если очевидное поведение не реализовано , читатели и пользователи кода перестают полагаться на свою интуицию в отношении имен функций . Они теряют доверие к автору кода и им приходится разбираться во всех подробностях реализации . : Некорректное граничное поведение Код должен работать правильно — вроде бы очевидное утверждение . Беда в том , что мы редко понимаем , насколько сложным бывает правильное поведение . Разработчики часто пишут функции , которые в их представлении работают , а затем доверяются своей интуиции вместо того , чтобы тщательно проверить работоспособность своего кода во всех граничных и особых ситуациях . Усердие и терпение ничем не заменить . Каждая граничная ситуация , каждый необычный и особый случай способны нарушить работу элегантного и интуитивного алгоритма . Не полагайтесь на свою интуицию . Найдите каждое граничное условие и напишите для него тест . : Отключенные средства безопасности Авария на Чернобыльской станции произошла из - за того , что директор завода отключил все механизмы безопасности , один за другим . Они усложняли проведение эксперимента . Результат — эксперимент так и не состоялся , а мир столкнулся с первой серьезной катастрофой в гражданской атомной энергетике . Отключать средства безопасности рискованно . Ручное управление бывает необходимо , но оно всегда сопряжено с риском . Иногда отключение некоторых или всех ! предупреждений компилятора позволяет успешно построить программу , но при этом вы рискуете бесконечными отладочными сеансами . Не отключайте сбойные тесты , обещая себе , что вы заставите их проходить позднее , — это так же неразумно , как считать кредитную карту источником бесплатных денег . : Дублирование Это одно из самых важных правил в книге и к нему следует относиться очень серьезно . Практически каждый автор , пишущий о проектировании программного обеспечения , упоминает это правило . Дэйв Томас и Энди Хант назвали егопринципом « ’ » , то есть «не повторяйтесь» . Кент Бек сделал его одним из основных принципов экстремального программирования в формулировке «Один , и только один раз» . Рон Джеффрис ставит это правило на второе место , после требования о прохождении всех тестов . Каждый раз , когда в программе встречается повторяющийся код , он указывает на упущенную возможность для абстракции . Возможно , дубликат мог бы стать функцией или даже отдельным классом . «Сворачивая» дублирование в подобные абстракции , вы расширяете лексикон языка программирования . Другие программисты могут воспользоваться созданными вами абстрактными концепциями . Повышение уровня абстракции ускоряет программирование и снижает вероятность ошибок . Простейшая форма дублирования — куски одинакового кода . Программа выглядит так , словно у программиста дрожат руки , и он снова и снова вставляет один и тот же фрагмент . Такие дубликаты заменяются простыми методами . Менее тривиальная форма дублирования — цепочки или , снова и снова встречающиеся в разных модулях и всегда проверяющие одинаковые наборы условий . Вместо них надлежит применять полиморфизм . Еще сложнее модули со сходными алгоритмами , но содержащие похожих строк кода . Однако дублирование присутствует и в этом случае . Проблема решается применением паттернов ШАБЛОННЫЙ МЕТОД или СТРАТЕГИЯ . В сущности , большинство паттернов проектирования , появившихся за последние лет , представляет собой хорошо известные способы борьбы с дублированием . Нормальные формы Кодда устраняют дублирование в схемах баз данных . Само объектно - ориентированное программирование может рассматриваться как стратегия модульной организации кода и устранения дубликатов . Естественно , это относится и к структурному программированию . Надеюсь , я достаточно четко выразил свою мысль . Ищите и устраняйте дубликаты повсюду , где это возможно . : Код на неверном уровне абстракции В программировании важную роль играют абстракции , отделяющие высокоуровневые общие концепции от низкоуровневых подробностей . Иногда эта задача решается созданием абстрактных классов , содержащих высокоуровневые концепции , и производных классов , в которых хранятся низкоуровневые концепции . Действуя подобным образом , необходимо позаботиться о том , чтобы разделение было полным . Все низкоуровневые концепции должны быть сосредоточены в производных классах , а все высокоуровневые концепции объединяются в базовом классе . Например , константы , переменные и вспомогательные функции , относящиеся только к конкретной реализации , исключаются из базового класса . Базовый класс не должен ничего знать о них . Правило также относится к исходным файлам , компонентам и модулям . Качественное проектирование требует , чтобы концепции разделялись на разных уровнях и размещались в разных контейнерах . Иногда такими контейнерами являются базовые и производные классы в других случаях это могут быть исходные файлы , модули или компоненты . Нокакое бы решение ни было выбрано в конкретном случае , разделение должно быть полным . Высокоуровневые и низкоуровневые концепции не должны смешиваться . Рассмотрим следующий фрагмент : Функция находится на неверном уровне абстракции . Существует много реализаций стека , в которых концепция заполнения выглядит разумно , однако другие реализации могутне знать , до какой степени заполнен стек . Следовательно , эта функция должна располагаться в производном интерфейсе — например , . Возможно , вы думаете , что для неограниченного стека реализация может просто вернуть ? Проблема в том , что абсолютно неограниченного стека не существует . Вам не удастся предотвратить исключение , проверив условие . . . Если ваша реализация функции возвращает , то она попросту врет . Суть в том , что ложь и фикции не способны компенсировать неверного размещения абстракций . Разделение абстракций — одна из самых сложных задач , решаемых разработчиками . Если выбор сделан неверно , не надейтесь , что вам удастся найти простое обходное решение . : Базовые классы , зависящие от производных Самая распространенная причина для разбиения концепций на базовые и производные классы состоит в том , чтобы концепции базового класса , относящиеся к более высокому уровню , были независимы от низкоуровневых концепций производных классов . Следовательно , когда в базовом классе встречаются упоминания имен производных классов , значит , в проектировании что - то сделано не так . В общем случае базовые классы не должны ничего знать о своих производных классах . Конечно , у этого правила имеются свои исключения . Иногда количество производных классов жестко фиксировано , а в базовом классе присутствует код для выбора между производными классами . Подобная ситуация часто встречается в реализациях конечных автоматов . Однако в этом случае между базовым и производными классами существуетжесткая привязка , и они всегда размещаются вместе в одном файле . В общем случае нам хотелось бы иметь возможность размещения производных и базовых классов в разных файлах . Размещение производных и базовых классов в разных файлах , при котором базовые файлы ничего не знают о содержимом производных файлов , позволяет организовать развертывание систем в формате дискретных , независимых компонентов . Если в такие компоненты будут внесены изменения , то они развертываются заново без необходимости повторного развертывания базовых компонентов . Такая архитектура значительно сокращает последствия от вносимых изменений и упрощает сопровождение систем в условиях реальной эксплуатации . : Слишком много информации Хорошо определенные модули обладают компактными интерфейсами , позволяющими сделать много минимальными средствами . Для плохо определенных модулей характерны широкие , глубокие интерфейсы , которые заставляют пользователя выполнять много разных операций для решения простых задач . Хорошо определенный интерфейс предоставляет относительно небольшое количество функций , поэтому степень логической привязки при его использовании относительно невелика . Плохо определенный интерфейс предоставляет множество функций , которые необходимо вызывать , поэтому его использование сопряжено с высокой степенью логической привязки . Хорошие разработчики умеют ограничивать интерфейсы своих классов и модулей . Чем меньше методов содержит класс , тем лучше . Чем меньше переменных известно функции , тем лучше . Чем меньше переменных экземпляров содержит класс , тем лучше . Скрывайте свои данные . Скрывайте вспомогательные функции . Скрывайте константы и временные переменные . Не создавайте классы с большим количеством методов или переменных экземпляров . Не создавайте большого количества защищенных переменных и функций в субклассах . Сосредоточьтесь на создании очень компактных , концентрированных интерфейсов . Сокращайте логические привязки за счет ограничения информации . : Мертвый код Мертвым кодом называется код , не выполняемый в ходе работы программы . Он содержится в теле команды , проверяющей невозможное условие . Он содержится в секции для блока , никогда не инициирующего исключения . Он содержится в маленьких вспомогательных методах , которые никогда не вызываются , или в никогда не встречающихся условиях . Мертвый код плох тем , что спустя некоторое время он начинает «плохо пахнуть» . Чем древнее код , тем сильнее и резче запах . Дело в том , что мертвый код не обновляется при изменении архитектуры . Он компилируется , но не соответствует более новым конвенциям и правилам . Он был написан в то время , когда система была другой . Обнаружив мертвый код , сделайте то , что положено делать в таких случаях : достойно похороните его . Удалите его из системы . : Вертикальное разделение Переменные и функции должны определяться вблизи от места их использования . Локальные переменные должны объявляться непосредственно перед первым использованием и должны обладать небольшой вертикальной областью видимости . Объявление локальной переменной не должно отдаляться от места ее использования на сотню строк . Приватные функции должны определяться сразу же после первого использования . Приватные функции принадлежат области видимости всего класса , но вертикальное расстояние между вызовами и определениями все равно должно быть минимальным . Приватная функция должна обнаруживаться простым просмотром кода от места первого использования . : Непоследовательность Если некая операция выполняется определенным образом , то и все похожие операции должны выполняться так же . Это правило возвращает нас к «принципу наименьшего удивления» . Ответственно подходите к выбору новых схем и обозначений , а если уж выбрали — продолжайте следовать им . Если в функцию включена переменная для хранения данных , будьте последовательны и используйте такое же имя переменной в других функциях , работающих с объектами . Если метод называется , присваивайте похожие имена например , методам , обрабатывающим другие запросы . Последовательное соблюдение подобных схем и правил существенно упрощает чтение и модификацию кода . : Балласт Какой прок от конструктора по умолчанию , не имеющего реализации ? Он только попусту загромождает код . Неиспользуемые переменные , невызываемые функции , бессодержательные комментарии — все это бесполезный балласт , который следует удалить . Поддерживайте чистоту в своих исходных файлах , следите за их структурой и не допускайте появления балласта . : Искусственные привязки То , что не зависит друг от друга , не должно объединяться искусственными привязками . Например , обобщенные перечисления не должны содержаться в более конкретных классах , потому что в этом случае информация о конкретном классе должна быть доступна в любой точке приложения , в которой используется перечисление . То же относится и к статическим функциям общего назначения , объявляемым в конкретных классах . В общем случае искусственной считается привязка между двумя модулями , не имеющая явной , непосредственной цели . Искусственная привязка возникает в результате размещения переменной , константы или функции во временно удобном , но неподходящем месте . Главные причины для появления искусственных привязок — лень и небрежность . Не жалейте времени — разберитесь , где должно располагаться объявление той или иной функции , константы или переменной . Слишком часто мы размещаем их в удобном месте «под рукой» , а потом оставляем там навсегда . : Функциональная зависть Это один из «запахов кода» , описанных у Мартина Фаулера . Для методов класса должны быть важны переменные и функции того класса , которому они принадлежат , а не переменные и функции других классов . Когда метод использует методы доступа другого объекта для манипуляций с его данными , то онзавидуетобласти видимости класса этого объекта . Он словно мечтает находиться в другом классе , чтобы иметь прямой доступ к переменным , с которыми он работает . Пример : . . . . , . , - . . Метод обращается к объекту за данными для обработки . Метод завидуетобласти видимости . Он «желает» получить доступ к внутренней реализации . В общем случае от функциональной зависти следует избавиться , потому что она предоставляет доступ к «внутренностям» класса другому классу . Впрочем , иногда функциональная зависть оказывается неизбежным злом . Рассмотрим следующий пример : . . « : % \ : % . % \ » , . , . , . % Очевидно , метод завидует классу . С другой стороны , мы не хотим , чтобы класс знал о формате отчета . Перемещение форматной строки в класс нарушает некоторые принципы объектно - ориентированного проектирования . Такое размещение привязывает к формату отчета и делает его уязвимым для изменений в этом формате . : Аргументы - селекторы Ничто так не раздражает , как висящий в конце вызова функции аргумент . Зачем он здесь ? Что изменится , если этот аргумент будет равен ? Смысл селектора трудно запомнить , но дело не только в этом — селектор указывает на объединение нескольких функций в одну . Аргументы - селекторы помогают ленивому программисту избежать разбиения большой функции на несколько меньших . Пример : . , . , - ? . : . . Функция вызывается с аргументом при оплате сверхурочной работы по полуторному тарифу или с аргументом при оплате по стандартному тарифу . Каждый раз , когда вы встречаете вызов , вам приходится вспоминать , что он означает , и это само по себе неприятно . Но по - настоящему плохо то , что автор поленился использовать решение следующего вида : . , - . . Конечно , селекторы не обязаны быть логическими величинами . Это могут быть элементы перечислений , целые числа или любые другие типы аргументов , в зависимости от которых выбирается поведение функции . В общем случае лучше иметь несколько функций , чем передавать функции признак для выбора поведения . : Непонятные намерения Код должен быть как можно более выразительным . Слишком длинные выражения , венгерская запись , «волшебные числа» — все это скрывает намерения автора . Например , приводившаяся ранее функция могла бы выглядеть и так : _ . . . , - Такая запись выглядит компактной и плотной , но разбираться в ней — сущее мучение . Не жалейте времени на то , чтобы сделать намерения своего кода максимально прозрачными для читателей . : Неверное размещение Одно из самых важных решений , принимаемых разработчиком , — выбор места для размещения кода . Например , где следует объявить константу ? В классе ? А может , ей место в классе ? Или в классе ? В игру вступает принцип наименьшего удивления . Код следует размещать там , где читатель ожидает его увидеть . Константа должна находиться там , где объявляются тригонометрические функции . Константа _ объявляется в классе . Иногда мы пытаемся «творчески» подойти к размещению функциональности . Мы размещаем ее в месте , удобном для нас , но это не всегда выглядит естественно для читателя кода . Предположим , потребовалось напечатать отчет с общим количеством отработанных часов . Мы можем просуммировать часы в коде , печатающем отчет , или же накапливатьсумму в коде обработки учетных карточек рабочего времени . Чтобы принять решение , можно посмотреть на имена функций . Допустим , в модуле отчетов присутствует функция с именем , а в модуле обработки учетных карточек присутствует функция . Какая из этих двух функций , если судить по имени , наводит на мысль о вычислении суммы ? Ответ очевиден . Очевидно , по соображениям производительности сумму правильнее вычислять при обработке карточек , а не при печати отчета . Все верно , но этот факт должен быть отражен в именах функций . Например , в модуле обработки учетных карточек должна присутствовать функция . : Неуместные статические методы . , — хороший статический метод . Он работает не с одним экземпляром в самом деле , запись вида . , или даже . выглядела бы довольно глупо . Все данные , используемые , берутся из двух аргументов , а не из некоего объекта - «владельца» . А главное , что метод . почти наверняка не потребуется делать полиморфным . Но иногда мы пишем статические функции , которые статическими быть не должны . Пример : . , Эта статическая функция тоже выглядит вполне разумно . Она не работает ни с каким конкретным объектом и получает все данные из своих аргументов . Однако нельзя исключать , что эту функцию потребуется сделать полиморфной . Возможно , в будущем потребуется реализовать несколько разных алгоритмов для вычисления почасовой оплаты —скажем , и . В этом случае данная функция не может быть статической . Ее следует оформить как нестатическую функцию . В общем случае отдавайте предпочтение нестатическим методам перед статическими . Если сомневаетесь , сделайте функцию нестатической . Если вы твердо уверены , что функция должна быть статической , удостоверьтесь в том , что от нее не потребуется полиморфное поведение . : Используйте пояснительные переменные Кент Бек писал об этом в своей великой книге « » , . , а затем позднее — в столь же великой книге « » . Один из самых эффективныхспособов улучшения удобочитаемости программы заключается в том , чтобы разбить обработку данных на промежуточные значения , хранящиеся в переменных с содержательными именами . Возьмем следующий пример из : . . . . . . , Простое использование пояснительных переменных четко объясняет , что первое совпадение содержит ключ , а второе — значение . Перестараться в применении пояснительных переменных трудно . Как правило , чем больше пояснительных переменных , тем лучше . Поразительно , насколько очевидным иногда становится самый невразумительный модуль от простого разбиения обработки данных на промежуточные значения с удачно выбранными именами . : Имена функций должны описывать выполняемую операцию Взгляните на следующий код : . Как вы думаете , что он делает — прибавляет пять дней к ? А может , пять недель или часов ? Изменяется ли экземпляр , или функция возвращает новое значение без изменения старого ? По вызову невозможно понять , что делает эта функция . Если функция прибавляет пять дней с изменением , то она должна называться или . С другой стороны , если функция возвращает новую дату , смещенную на пять дней , но не изменяет исходного экземпляра , то она должна называться или . Если вам приходится обращаться к реализации или документации , чтобы понять , что делает та или иная функция , постарайтесь найти более удачное имя или разбейте функциональность на меньшие функции с более понятными именами . : Понимание алгоритма Очень много странного кода пишется из - за того , что люди не утруждают себя пониманием алгоритмов . Они заставляют программу работать «грубой силой» , набивая ее командами и флагами , вместо того чтобы остановиться и подумать , что же в действительности происходит . Программирование часто сопряжено с исследованиями . Вы думаете , что знаете подходящий алгоритм для решения задачи , но потом вам приходится возиться с ним , подправлять и затыкать щели , пока вы не заставите его «работать» . А как вы определили , что он «работает» ? Потому что алгоритм прошел все тесты , которые вы смогли придумать . В этом подходе нет ничего плохого . Более того , часто только так удается заставить функцию делать то , что она должна делать по вашему мнению . Однако ограничиться «работой» в кавычках недостаточно . Прежде чем откладывать в сторону готовую функцию , убедитесь в том , что выпонимаете , как она работает . Прохождения всех тестов недостаточно . Вы должнызнать , что ваше решение правильно . Один из лучших способов достичь этого знания и понимания — разбить функцию на фрагменты настолько чистые и выразительные , что вам станет совершенно очевидно , как работает данная функция . : Преобразование логических зависимостей в физические Если один модуль зависит от другого , зависимость должна быть не только логической , но и физической . Зависимый модуль не должен делать никаких предположений иначе говоря , создавать логические зависимости относительно того модуля , от которого он зависит . Вместо этого он должен явно запросить у этого модуля всю необходимую информацию . Допустим , вы пишете функцию , которая выводит текстовый отчет об отработанном времени . Класс с именем собирает все данные в удобной форме и передает их классу для вывода листинг . . Листинг . . . _ . : . _ . . . . . . . . . % . У этого кода имеется логическая зависимость , лишенная физического воплощения . Удастся ли вам найти ее ? Речь идет о константе _ . Почему класс должен знать размер страницы ? За размер страницы должен отвечать класс . Факт объявления _ в указывает на неверное размещение . Разработчик полагает , что классу необходимо знать размер страницы . Такое предположение является логической зависимостью . Работа зависит от того факта , что поддерживает размер страницы до . Если какая - то реализация не сможет работать с такими страницами , произойдет ошибка . Чтобы создать физическое представление этой зависимости , мы можем включить в новый метод с именем . В дальнейшем вызывает эту функцию вместо того , чтобы использовать константу _ . : Используйте полиморфизм вместо или Эта рекомендация может показаться странной , если вспомнить главу . Ведь в этой главе говорилось , что в тех частях системы , в которые с большей вероятностью будут добавляться новые функции , а не новые типы , команды вполне уместны . Во - первых , команды чаще всего используются только потому , что они представляют очевидное решение методом «грубой силы» , а не самое уместное решение для конкретной ситуации . Таким образом , это эвристическое правило напоминает нам о том , что до применения следует рассмотреть возможность применения полиморфизма . Во - вторых , ситуации , в которых состав функций менее стабилен , чем состав типов , встречаются относительно редко . Следовательно , к каждой конструкции следует относиться с подозрением . Я использую правило «ОДНОЙ КОМАНДЫ » : для каждого типа выбора программа не должна содержать более одной команды . Множественные конструкции следует заменять полиморфными объектами . : Соблюдайте стандартные конвенции Все рабочие группы должны соблюдать единые стандарты кодирования , основанные на отраслевых нормах . Стандарт кодирования определяет , где объявляются переменные экземпляров как присваиваются имена классов , методов и переменных где размещаются фигурные скобки и т . д . Документ с явным описанием этих правил не нужен — сам код служит примером оформления . Правила должны соблюдаться всеми участниками группы . Это означает , что каждый участник группы должен быть достаточно разумным , чтобы понимать : неважно , как именноразмещаются фигурные скобки , если только все согласились размещать их одинаковым образом . Если вам захочется узнать , какие конвенции оформления использую я , обратитесь к переработанному коду в листингах Б . с . — Б . . : Заменяйте «волшебные числа» именованными константами Вероятно , это одно из самых древних правил разработки . Помню , оно встречалось мне еще в - х годах , в учебниках , и для начинающих . В общем случае присутствие «сырых» чисел в коде нежелательно . Числа следует скрыть в константах с содержательными именами . Например , число , следует скрыть в константе _ _ . Если в странице отчета выводится строк , число следует скрыть в константе _ _ . Некоторые числа так легко узнаются , что их не обязательно скрывать за именованными константами — при условии , что они используются в сочетании с предельно ясным кодом . Пример : . . Нужны ли константы _ _ , _ _ _ и в этих примерах ? Разумеется , последний случай выглядит особенно абсурдно . В некоторых формулах константы попросту лучше воспринимаются в числовой записи . По поводу _ _ _ можно спорить , потому что законы и нормативы могут изменяться . С другой стороны , формула с числом читается настолько удобно , что мне просто не хочется нагружать читателя кода лишними символами . А число — количество футов в миле — настолько хорошо известно и уникально , что читатель сразу узнает его , даже если оно будет располагаться вне какого - либо контекста . Такие константы , как . , тоже хорошо известны и легко узнаваемы . Однако вероятность ошибки слишком велика , чтобы оставлять их в числовой форме . Встречая значение . , вы сразу догадываетесь , что перед вами число , и не проверяете его а вы заметили ошибку в одной цифре ? . Также мы не хотим , чтобы в программах использовались сокращения . , . , . и т . д . К счастью , значение . уже определено за нас . Термин «волшебное число» относится не только к числам . Он распространяется на все лексемы , значения которых не являются самодокументирующими . Пример : , . " " . В этом проверочном условии задействованы два «волшебных числа» . Очевидно , первое — , хотя его смысл далеко не так очевиден . Второе «волшебное число» — строка " " . Ее смысл тоже выглядит весьма загадочно . Оказывается , " " — имя работника с табельным номером в тестовой базе данных , созданной нашей группой . Все участники группы знают , как подключаться к этой базеданных . В базе уже хранятся тестовые записи с заранее известными значениями и атрибутами . Также выясняется , что " " — единственный работник с почасовой оплатой в тестовой базе данных . Следовательно , эта проверка должна выглядеть так : _ _ , . _ _ . : Будьте точны Наивно ожидать , что первая запись , возвращаемая по запросу , является единственной . Использовать числа плавающей точкой для представления денежных сумм — почти преступление . Отсутствие блокировок и или управления транзакциями только потому , что вы думаете , что одновременное обновление маловероятно — в лучшем случае халатность . Объявление переменной с типом там , где более уместен тип — чрезмерное ограничение . Объявление всех переменных защищенными по умолчанию — недостаточное ограничение . Принимая решение в своем коде , убедитесь в том , что вы действуете предельно точно и аккуратно . Знайте , почему принимается решение , и как вы собираетесь поступать с исключениями из правила . Не ленитесь обеспечивать точность своих решений . Если вы решили вызвать функцию , которая может вернуть — проверьте возвращаемое значение . Если вы запрашиваете из базы данных запись , которая , по вашему мнению , является единственной — проверьте , не вернул ли запрос дополнительные записи . Если вам нужно работать с денежными суммами , используйте целые числа и округляйте результат по действующим правилам . Если в программе существует возможность одновременного объявления , реализуйте ту или иную разновидность блокировки . Неоднозначности и неточности в коде объясняются либо недопониманием , либо ленью . В любом случае от них следует избавиться . : Структура важнее конвенций Воплощайте архитектурные решения на уровне структуры кода она важнее стандартов и конвенций . Содержательные имена полезны , но структура , заставляющая пользователя соблюдать установленные правила , важнее . Например , конструкции с хорошо выбранными именами элементов перечисления уступают базовым классам с абстрактными методами . Ничто не вынуждает пользователя применять одинаковую реализацию во всех случаях с другой стороны , базовые классы заставляют его реализовать все абстрактные методы в конкретных классах . : Инкапсулируйте условные конструкции В булевской логике достаточно трудно разобраться и вне контекста команд или . Выделите в программе функции , объясняющие намерения условной конструкции . Например , команда выразительнее команды . ! . : Избегайте отрицательных условий Отрицательные условия немного сложнее для понимания , чем положительные . Таким образом , по возможности старайтесь формулировать положительные условия . Например , запись . предпочтительнее записи ! . : Функции должны выполнять одну операцию Часто возникает искушение разделить свою функцию на несколько секций для выполнения разных операций . Такие функции выполняют несколько операций их следует преобразовать в группу меньших функций , каждая из которых выполняет только одну операцию . Пример : : . . . Эта функция выполняет сразу три операции : она перебирает всех работников проверяет , начислены ли работнику какие - то выплаты и наконец , производит оплату . Код лучше записать в следующем виде : : . . . Каждая из этих функций выполняет только одну операцию см . «Правило одной операции» , с . . : Скрытые временны ? е привязки Временны ? е привязки часто необходимы , но они не должны скрываться . Структура аргументов функций должна быть такой , чтобы последовательность вызова была абсолютно очевидной . Рассмотрим следующий пример : … Порядок вызова трех функций важен . Сначала вызывается , затем и только после этого . К сожалению , код не обеспечивает принудительного соблюдения временной привязки . Ничто не мешает другому программисту вызвать до , и все кончится исключением . Более правильное решение выглядит так : , … Временная привязка реализуется посредством создания «эстафеты» . Каждая функция выдает результат , необходимый для работы следующей функции , и вызвать эти функциис нарушением порядка сколько - нибудь разумным способом уже не удастся . Пожалуй , кто - то сочтет , что это увеличивает сложность функций , и это действительно так . Однако дополнительные синтаксические сложности лишь выявляют реальную сложность ситуации , обусловленную необходимостью согласования по времени . Обратите внимание : переменные экземпляров остались на своих местах . Предполагается , что они используются приватными методами класса . Использование их в аргументах лишь явно выражает факт существования временной привязки . : Структура кода должна быть обоснована Структура кода должна выбираться не произвольно , а по строго определенным причинам . Позаботьтесь о том , чтобы эти причины были выражены в структуре кода . Если при чтении кода создается впечатление , что его структура выбрана произвольно , другим пользователям может показаться , что ее можно изменить . Если во всей системе последовательно используется единая структура кода , другие пользователи примут ее и сохранят действующие правила . Например , недавно я занимался объединением изменений в и обнаружил , что один из наших авторов использовал следующую запись : … … Проблема в том , что незачем находиться в облсти видимости . Более того , класс . использовался посторонними классами , которые не имели никакого отношения к . Возможно , программист разместил в по соображениям удобства , а может , он действительно полагал , что область видимости этого класса должна находиться внутри области видимости . Какими бы причинами он ни руководствовался , результат выглядит необоснованным . Открытые классы , не являющиеся вспомогательными по отношению к другому классу то есть используемыми только в его внутренних операциях , не должны размещаться внутри других классов . По стандартным правилам такие классы объявляются на верхнем уровне своих пакетов . : Инкапсулируйте граничные условия Отслеживать граничные условия нелегко . Разместите их обработку в одном месте . Не позволяйте им «растекаться» по всему коду . Не допускайте , чтобы в вашей программе кишели многочисленные и – . Возьмем простой пример из : . , , , Обратите внимание : здесь встречается дважды . Это граничное условие , которое следует инкапсулировать в переменной — например , с именем : . , , , : Функции должны быть написаны на одном уровне абстракции Все команды функции должны быть сформулированы на одном уровне абстракции , который расположен одним уровнем ниже операции , описываемой именем функции . Возможно , это эвристическое правило сложнее всего правильно интерпретировать и соблюдать . Идея достаточно тривиальна , но люди слишком хорошо справляются со смешением разных уровней абстракции . Для примера возьмем следующий код из : " " . " \ " " . . " \ " " . " " . Разобраться в происходящем несложно . Функция конструирует тег , который рисует на странице горизонтальную линию . Толщина линии задается переменной . А теперь взгляните еще раз . В этом методе смешиваются минимум два уровня абстракции . Первый уровень — наличие толщины у горизонтальной линии . Второй уровень — синтаксис тега . Код позаимствован из модуля проекта . Модуль распознает строку из четырех и более дефисов и преобразует ее в соответствующий тег . Чем больше дефисов , тем больше толщина . Я переработал этот фрагмент кода так , как показано ниже . Обратите внимание : имя поля изменено в соответствии с его истинным назначением в нем хранится количество дополнительных дефисов . " " . " " , . . " % " , Изменение разделяет два уровня абстракции . Функция просто конструирует тег , ничего не зная о синтаксисе этого тега . Модуль берет на себя все хлопоты с синтаксисом . Более того , при внесении этого изменения я обнаружил неприметную ошибку . Исходный код не закрывал тег косой чертой , как того требует стандарт иначе говоря , онвыдавал вместо , хотя модуль был давно приведен в соответствие со стандартом . Разделение уровней абстракции — одна из самых важных и одновременно самых сложных в реализации функций рефакторинга . В качестве примера возьмем следующий код — мою первую попытку разделения уровней абстракции в методе . . " " . " " , " " . На этой стадии я стремился к тому , чтобы создать необходимое разделение , и обеспечить прохождение тестов . Мне удалось легко добиться этой цели , но в созданной функции по - прежнему смешивались разные уровни абстракции — на этот раз конструирование тега и интерпретация форматирование переменной . Таким образом , при разбиении функции по уровням абстракции иногда обнаруживаются новые уровни , скрытые прежней структурой . : Храните конфигурационные данные на высоких уровнях Если в программе имеется константа , определяющая значение по умолчанию или параметр конфигурации , и эта константа известна на высоких уровнях абстракции , — не прячьте ее в низкоуровневой функции . Передайте ее в аргументе низкоуровневой функции , вызываемой из функции высокого уровня . Рассмотрим пример из . … _ " . " _ " " _ _ _ … Аргументы командной строки разбираются в самой первой исполняемой строке . Значения аргументов по умолчанию задаются в начале класса . Читателю не приходится спускаться на нижние уровни системы за командами следующего вида : . по умолчанию Конфигурационные константы находятся на очень высоком уровне . Если потребуется , их можно легко изменить . Их значения передаются на более низкие уровни иерархии другим компонентам приложения . Значения этих констант не принадлежат нижним уровням приложения . : Избегайте транзитивных обращений В общем случае модуль не должен обладать слишком полной информацией о тех компонентах , с которыми он взаимодействует . Точнее , если взаимодействует с , а взаимодействует с , то модули , использующие , не должны знать о то есть нежелательны конструкции вида . . . . Иногда это называется «законом Деметры» . Прагматичные программисты используют термин «умеренный код» , с . . В любом случае все сводится к тому , что модули должны обладать информацией только о тех модулях , с которыми они непосредственно взаимодействуют , а не располагать навигационной картой всей системы . Если в нескольких модулях используется та или иная форма команды . . , то в дальнейшем вам будет трудно изменить архитектуру системы , вставив между и промежуточный компонент . Придется найти каждое вхождение . . и преобразовать его в . . . . Так образуются жесткие , закостеневшие архитектуры . Слишком многие модули располагают слишком подробной информацией о системе . Весь необходимый сервис должен предоставляться компонентами , с которыми напрямую взаимодействует модуль . Не заставляйте пользователя странствовать по графу объектов системы в поисках нужного метода . Проблема должна решаться простыми вызовами вида . : Используйте обобщенные директивы импорта Если вы используете два и более класса из пакета , импортируйте весь пакет командой . Длинные списки импорта пугают читателя кода . Начало модуля не должно загромождаться - строчным списком директив импорта . Список импорта должен быть точной и лаконичной конструкцией , показывающей , с какими пакетами мы собираемся работать . Конкретные директивы импорта определяют жесткие зависимости , обобщенные директивы импорта — нет . Если вы импортируете конкретный класс , то этот класс обязательно должен существовать . Но пакет , импортируемый обобщенной директивой , может не содержать ни одного класса . Директива импорта просто добавляет пакет в путь поиска имен . Таким образом , обобщенные директивы импорта не создают реальных зависимостей , а следовательно , способствуют смягчению логических привязок между модулями . В некоторых ситуациях длинные списки конкретных директив импорта бывают полезными . Например , если вы работаете с унаследованным кодом и хотите узнать , для каких классов необходимо создать заглушки и имитации , можно пройтись по конкретным спискам импорта , узнать полные имена классов и написать для них соответствующие заглушки . Однако такое использование конкретных директив импорта встречается крайне редко . Более того , многие современные позволяют преобразовать обобщенный список импорта в список конкретных директив одной командой . Таким образом , даже в унаследованном коде лучше применять обобщенный импорт . Обобщенные директивы импорта иногда становятся причиной конфликтов имен и неоднозначностей . Два класса с одинаковыми именами , находящиеся в разных пакетах , должны импортироваться конкретными директивами или по крайней мере их имена должны уточняться при использовании . Это создает определенные неудобства , однако ситуация встречается достаточно редко , так что в общем случае обобщенные директивы импорта все равно лучше конкретных . : Не наследуйте от констант Я уже неоднократно встречался с этим явлением , и каждый раз оно заставляло меня недовольно поморщиться . Программист размещает константы в интерфейсе , а затем наследует от этого интерфейса для получения доступа к константам . Взгляните на следующий код : . , _ _ - _ … Где определяются константы _ _ и _ ? Возможно , в классе давайте посмотрим : Нет , не здесь . А где тогда ? Присмотритесь повнимательнее к классу . Он реализует интерфейс . _ _ _ . Совершенно отвратительная привычка ! Константы скрыты на верхнем уровне иерархии наследования . Брр ! Наследование не должно применяться для того , чтобы обойти языковые правила видимости . Используйте статическое импортирование . . . , _ _ - _ … : Константы против перечислений В языке появились перечисления — пользуйтесь ими ! Не используйте старый трюк с . Смысл может потеряться смысл перечислений потеряться не может , потому что они принадлежат указанному перечислению . Тщательно изучите синтаксис перечислений . Не забудьте , что перечисления могут содержать методы и поля . Это очень мощные синтаксические инструменты , значительно превосходящие по гибкости и выразительности . Рассмотрим следующую разновидность кода начисления зарплаты : . , _ _ - . _ … . , _ . , . , . Имена : Используйте содержательные имена Не торопитесь с выбором имен . Позаботьтесь о том , чтобы имена были содержательными . Помните , что смысл может изменяться в ходе развития программного продукта почаще переосмысливайте уместность выбранных вами имен . Не рассматривайте это как дополнительный «фактор комфортности» . Имена в программных продуктах на % определяют удобочитаемость кода . Не жалейте времени на то , чтобы выбрать их осмысленно , и поддерживайте их актуальность . Имена слишком важны , чтобы относиться к ним легкомысленно . Возьмем следующий код . Что он делает ? Когда я представлю вам тот же код с нормально выбранными именами , вы моментально поймете его смысл , но в этом виде он представляет собой мешанину из символов и «волшебных чисел» . А вот как должен был выглядеть этот код . Вообще говоря , этот фрагмент чуть менее полон , чем приведенный выше . И все же вы сразу догадаетесь , что мы пытаемся сделать , и с большой вероятностью сможете написать отсутствующие функции , основываясь на своих предположениях . «Волшебные числа» перестали быть волшебными , а структура алгоритма радует своей очевидностью . Сила хорошо выбранных имен заключается в том , что они дополняют структуру кода описаниями . На основании этих описаний у читателя формируются определенные предположения по поводу того , что делают другие функции модуля . Взглянув на приведенный код , вы сможете представить себе примерную реализацию . А при чтении метода становится очевидно , что он делает «примерно то , что предполагалось» . : Выбирайте имена на подходящем уровне абстракции Не используйте имена , передающие информацию о реализации . Имена должны отражать уровень абстракции , на котором работает класс или функция . Сделать это непросто — и снова потому , что люди слишком хорошо справляются со смешением разных уровней абстракции . При каждом просмотре кода вам с большой вероятностью попадется переменная , имя которой выбрано на слишком низком уровне . Воспользуйтесь случаем и измените его . Чтобы ваш код хорошо читался , вы должны серьезно относиться к его непрерывному совершенствованию . Возьмем следующий интерфейс : На первый взгляд все хорошо — имена функций выглядят разумно . В самом деле , во многих приложениях они точно соответствуют выполняемым операциям . А если для установления связи используется не коммутируемое подключение , а какой - то другой механизм ? Например , модемы могут связываться на физическом уровне как кабельные модемы , обеспечивающие доступ к Интернету во многих домах . А может быть , связь устанавливается посредством отправки номера порта коммутатору через интерфейс . Разумеется , концепция телефонных номеров в таких случаях относится к неверному уровню абстракции . Более правильная стратегия выбора имен в таких сценариях может выглядеть так : Теперь имена функций никак не ассоциируются с телефонными номерами . Они могут использоваться как для подключения по телефонной линии , так и для любой другой стратегии подключения . : По возможности используйте стандартную номенклатуру Имена проще понять , если они основаны на существующих конвенциях или стандартных обозначениях . Например , при использовании паттерна ДЕКОРАТОР можно включить в имена декорирующих классов слово . Например , имя может быть присвоено классу , который дополняет класс возможностью автоматического разрыва связи в конце сеанса . Паттерны составляют лишь одну разновидность стандартов . Например , в языке функции , преобразующие объекты в строковые представления , часто называются . Лучше следовать подобным стандартным конвенциям , чем изобретать их заново . Группы часто разрабатывают собственные стандартные системы имен для конкретного проекта . Эрик Эванс называет ихвсеобщим языкомпроекта . Широко используйте термины этого языка в своем коде . Чем больше вы используете имена , переопределенные специальным смыслом , относящимся к вашему конкретному проекту , тем проще читателю понять , о чем идет речь в вашем коде . : Недвусмысленные имена Выбирайте имена , которые максимально недвусмысленно передают назначение функции или переменной . Рассмотрим пример из : . . . Имя функции получилось слишком общим и расплывчатым оно ничего не говорит о том , что делает функция . Ситуацию усугубляет тот факт , что в функции с именем находится функция ! Что можно сказать о различиях между этими функциями по их именам ? Ничего . Функцию было бы правильнее назвать . На первый взгляд имя кажется слишком длинным , но функция вызывается только из одной точки модуля , поэтому ее документирующая ценность перевешивает длину . : Используйте длинные имена для длинных областей видимости Длина имени должна соответствовать длине его области видимости . Переменным с крошечной областью видимости можно присваивать очень короткие имена , но у переменных с большей областью видимости имена должны быть длинными . Если область видимости переменной составляет всего пять строк , то переменной можно присвоить имя или . Возьмем следующий фрагмент из старой стандартной игры « » : , . Смысл переменной абсолютно очевиден . Какое - нибудь раздражающее имя вида только затемнило бы смысл этого тривиального кода . С другой стороны , смысл короткихимен переменных и функций рассеивается на длинных дистанциях . Таким образом , чем длиннее область видимости имени , тем более длинным и точным должно быть ее имя . : Избегайте кодирования Информация о типе или области видимости не должна кодироваться в именах . Префиксы вида _ или бессмысленны в современных средах . Кроме того , информация о проекте и или подсистеме например , префикс _ для подсистемы визуализации также отвлекает читателя и является избыточной . Современные среды разработки позволяют получить всю необходимую информацию без уродования имен . Поддерживайте чистоту в своих именах , не загрязняйте их венгерской записью . : Имена должны описывать побочные эффекты Имена должны описывать все , что делает функция , переменная или класс . Не скрывайте побочные эффекты за именами . Не используйте простые глаголы для описания функции , которая делает что - то помимо этой простой операции . Для примера возьмем следующий код из : _ _ _ . _ Функция не ограничивается простым получением _ она создает объект _ , если он не был создан ранее . Таким образом , эту функцию было бы правильнее назвать . Тесты : Нехватка тестов Сколько тестов должен включать тестовый пакет ? К сожалению , многие программисты руководствуются принципом «Пожалуй , этого хватит» . Тестовый пакет должен тестировать все , что может сломаться . Если в системе остались условия , не проверенные тестами , или вычисления , правильность которых не подтверждена , значит , количество тестов недостаточно . : Используйте средства анализа покрытия кода Средства анализа покрытия сообщают о пробелах в вашей стратегии тестирования . Они упрощают поиск модулей , классов и функций с недостаточно полным тестированием . Во многих используются визуальные обозначения : строки , покрытые тестами , выделяются зеленым цветом , а непокрытые — красным . Это позволяет легко и быстро обнаружить команды или , тело которых не проверяется тестами . : Не пропускайте тривиальные тесты Тривиальные тесты пишутся легко , а их информативная ценность превышает затраты времени на их создание . : Отключенный тест как вопрос Иногда мы не уверены в подробностях поведения системы , потому что неясны сами требования к программе . Вопрос о требованиях можно выразить в виде теста — закомментированного или помеченного аннотацией @ . Выбор зависит от того , компилируется или нет код , к которому относится неопределенность . : Тестируйте граничные условия Особенно тщательно тестируйте граничные условия . Программисты часто правильно реализуют основную часть алгоритма , забывая о граничных ситуациях . : Тщательно тестируйте код рядом с ошибками Ошибки часто собираются группами . Если вы обнаружили ошибку в функции , особенно тщательно протестируйте эту функцию . Может оказаться , что ошибка была не одна . : Закономерности сбоев часто несут полезную информацию Иногда анализ закономерностей в сбоях тестовых сценариев помогает выявить причины возникших проблем . Это еще один аргумент в пользу максимальной полноты тестовых сценариев . Всесторонние наборы тестовых сценариев , упорядоченные логичным образом , выявляют закономерности . Простой пример : вы заметили , что все тесты с входными данными , длина которых превышает пять символов , завершаются неудачей ? Или что любой тест , который передает во втором аргументе функции отрицательное число , не проходит ? Иногда простая закономерность чередования красного и зеленого в тестовом отчете заставляет нас воскликнуть «Ага ! » на пути к правильному решению . Интересный пример такого рода приведен на с . . : Закономерности покрытия кода часто несут полезную информацию Анализ того , какой код выполняется или не выполняется в ходе тестирования , иногда подсказывает причины возможных сбоев в ходе тестирования . : Тесты должны работать быстро Медленный тест не выполняется за разумное время . Если время поджимает , из тестового пакета первыми будут удалены медленные тесты . Сделайте все необходимое для того , чтобы ваши тесты работали быстро . Заключение Приведенный список эвристических правил и «запахов» не претендует на полноту . Я вообще не уверен в том , можно ли составить полный список такого рода . Но вероятно , стопроцентная полнота здесь и не нужна , поскольку список всего лишь дает косвенное представление о системе ценностей . Именно эта система ценностей является нашей целью — и основной темой книги . Невозможно написать чистый код , действуя по списку правил . Нельзя стать мастером , изучив набор эвристик . Профессионализм и мастерство формируются на основе ценностей , которыми вы руководствуетесь в обучении . Литература : : , . , - , . : , , , - , . : : , . , - , . : , , , . : , , - , . : : , , , . , , . : , , - , . Приложение А . Многопоточность Бретт Л . Шухерт Данное приложение дополняет и углубляет материал главы «Многопоточность» , с . . Оно написано в виде набора независимых разделов , которые можно читать в произвольном порядке . Чтобы такое чтение было возможно , материал разделов частично перекрывается . Пример приложения «клиент сервер» Представьте простое приложение «клиент сервер» . Сервер работает в режиме ожидания , прослушивая сокет на предмет клиентских подключений . Клиент подключается и отправляет запросы . Сервер Ниже приведена упрощенная версия серверного приложения . Полный исходный код примера приводится , начиная со с . . . Приложение ожидает подключения , обрабатывает входящее сообщение , а затем снова ожидает следующего клиентского запроса . Код клиента для подключения к серверу выглядит так : " " , . , . . . . Как работает пара «клиент сервер» ? Как формально описать ее производительность ? Следующий тест проверяет , что производительность является «приемлемой» : @ Чтобы по возможности упростить пример , я исключил из него подготовительный код см . « . » , с . . Тест предполагает , что обработка должна быть завершена за миллисекунд . Перед нами классический пример оценки производительности системы . Система должна завершить обработку серии клиентских запросов за секунд . Если сервер сможет обработать все клиентские запросы за положенное время , то тест пройдет . А что делать , если тест завершится неудачей ? В однопоточной модели практически невозможно как - то ускорить обработку запросов если не считать реализации цикла опроса событий . Сможет ли многопоточная модель решить проблему ? Может , но нам необходимо знать , в какой области расходуется основное время выполнения . Возможны два варианта : • Ввод вывод – использование сокета , подключение к базе данных , ожидание подгрузки из виртуальной памяти и т . д . • Процессор – числовые вычисления , обработка регулярных выражений , уборка мусора и т . д . В системах время обычно расходуется в обеих областях , но для конкретной операции одна из областей является доминирующей . Если код в основном ориентирован на обработку процессором , то повышение вычислительной мощности способно улучшить производительность и обеспечить прохождение теста . Однако количество процессорных тактов все же ограничено , так что реализация многопоточной модели в процессорно - ориентированных задачах не ускорит их выполнения . С другой стороны , если значительное время в выполняемом процессе расходуется на операции ввода вывода , то многопоточная модель способна повысить эффективность работы . Пока одна часть системы ожидает ввода вывода , другая часть использует время ожидания для выполнения других действий , обеспечивая более эффективное использование процессорного времени . Реализация многопоточности Допустим , тест производительности не прошел . Как повысить производительность и обеспечить прохождение теста ? Если серверный метод ориентирован на ввод вывод , одна из возможных реализаций многопоточной модели выглядит так : . . , " : " . . Допустим , в результате внесенных изменений тест проходит задача решена , верно ? Анализ серверного кода На обновленном сервере тест успешно завершается всего за одну с небольшим секунду . К сожалению , приведенное решение наивно , и оно создает ряд новых проблем . Сколько потоков может создать наш сервер ? Код не устанавливает ограничений , поэтому сервер вполне может столкнуться с ограничениями , установленными виртуальной машиной . Для многих простых систем этого достаточно . А если система обслуживает огромное количество пользователей в общедоступной сети ? При одновременном подключении слишком многих пользователей система «заглохнет» . Но давайте ненадолго отложим проблемы с поведением . Чистота и структура представленного кода тоже оставляют желать лучшего . Какие ответственности возложены на серверный код ? • Управление подключением к сокетам . • Обработка клиентских запросов . • Политика многопоточности . • Политика завершения работы сервера . К сожалению , все эти ответственности реализуются кодом функции . Кроме того , код распространяется на несколько разных уровней абстракции . Следовательно , какойбы компактной ни была функция , ее все равно необходимо разбить на несколько меньших функций . У серверного кода несколько причин для изменения следовательно , он нарушает принцип единой ответственности . Чтобы код многопоточной системы оставался чистым , управление потоками должно быть сосредоточено в нескольких хорошо контролируемых местах . Более того , код управления потоками не должен делать ничего другого . Почему ? Да хотя бы потому , что отслеживать проблемы многопоточности достаточно сложно и без параллельного отслеживания других проблем , не имеющих ничего общего с многопоточностью . Если создать отдельный класс для каждой из ответственностей , перечисленных выше включая управление потоками , то последствия любых последующих изменений стратегии управления потоками затронут меньший объем кода и не будут загрязнять реализацию других обязанностей . Кроме того , такое разбиение упростит тестирование других модулей , так как вам не придется отвлекаться на многопоточные аспекты . Обновленная версия кода : . . . . Все аспекты , относящиеся к многопоточности , теперь собраны в объекте . Если в приложении возникнут многопоточные проблемы , искать придется только в одном месте : Текущая политика реализуется легко : . . Изоляция всего многопоточного кода существенно упрощает внесение любых изменений в политику управления потоками . Например , чтобы перейти на инфраструктуру , достаточно написать новый класс и подключить его к существующему коду листинг А . . Листинг А . . . . . . . . . . . . Заключение Применение многопоточной модели в этом конкретном примере показывает , как повысить производительность системы , а также демонстрирует методологию проверки изменившейся производительности посредством тестовой инфраструктуры . Сосредоточение всего многопоточного кода в небольшом количестве классов – пример практическогоприменения принципа единой ответственности . В случае многопоточного программирования это особенно важно из - за его нетривиальности . Возможные пути выполнения Рассмотрим код однострочного метода , не содержащего циклов или ветвления : Забудем о возможности целочисленного переполнения . Будем считать , что только один программный поток имеет доступ к единственному экземпляру . В этом случае существует единственный путь выполнения с единственным гарантированным результатом : • Возвращаемое значение равно значению , и оба значения на одну единицу больше значения непосредственно перед вызовом метода . Что произойдет , если мы используем два программных потока , а метод останется неизменным ? Какие возможны результаты , если каждый поток вызовет по одному разу ? Сколько существует возможных путей выполнения ? Начнем с результатов допустим , начинается со значения : • Поток получает значение , поток получает значение , значение равно . • Поток получает значение , поток получает значение , значение равно . • Поток получает значение , поток получает значение , значение равно . Последний результат выглядит удивительно , но он возможен . Чтобы понять , как образуются эти разные результаты , необходимо разобраться в количестве возможных путейвыполнения и в том , как они исполняются виртуальной машиной . Количество путей Чтобы вычислить количество возможных путей выполнения , начнем со сгенерированного байт - кода . Одна строка кода преобразуется в восемь инструкций байт - кода . Выполнение этих восьми инструкций двумя потоками может перемежаться подобно тому , как перемежаются карты в тасуемой колоде . Хотя в каждой руке вы держите всего восемь карт , количество всевозможных перетасованных комбинаций чрезвычайно велико . В простом случае последовательности из команд , без циклов и условных переходов , и потоков , общее количество возможных путей выполнения будет равно Картинка : _ . . Вычисление возможных вариантов упорядочения Из сообщения электронной почты , отправленного Дядюшкой Бобом Бретту : При шагов и потоков общее количество в итоговой последовательности шагов равно . Перед каждым шагом происходит переключение контекста , в ходе которого производится выбор между потоками . Каждый путь может быть представлен в виде последовательности цифр , обозначающей переключение контекстов . Так , для шагов и с потоками и возможны шесть путей : , , , , и . Если использовать в записи обозначения шагов , мы получаем , , , , и . Для трех потоков последовательность вариантов имеет вид , , , , , , , , , , . . . . Одно из свойств этих строк заключается в том , что каждый поток должен присутствовать в строке в экземплярах . Таким образом , строка невозможна , потому что она содержит шесть экземпляров и нуль экземпляров и . Итак , нам нужно сгенерировать перестановки из цифр , цифр … и цифр . Искомое число равно числу перестановок из объектов , то есть ! , но с удалением всех дубликатов . Таким образом , задача заключается в том , чтобы подсчитать дубликаты и вычесть их количество из ! . Сколько дубликатов содержит серия для двух шагов и двух потоков ? Каждая строка из четырех цифр состоит из двух и двух . Цифры каждой пары можно поменять местами без изменения смысла строки . Мы можем переставить две цифры и или две цифры . Таким образом , каждая строка существует в четырех изоморфных версиях это означает , чтоу каждой строки имеются три дубликата . Три варианта из четырех повторяются , то есть только одна перестановка из четырех НЕ ЯВЛЯЕТСЯ дубликатом . ! . . Похоже , наша схема рассуждений работает . Как вычислить количество дубликатов в общем случае ? Для и можно переставить и или . Для и можно переставить , , , и , и или и . Количество вариантов равно количеству перестановок . Допустим , существует разных перестановок . Количество разных вариантов размещения этих перестановок равно . Таким образом , количество возможных изоморфных версий равно ! . Соответственно , количество путей равно ! ! . Для исходного случая , мы получаем . Для и количество путей равно . Для и получается ! ^ . В простейшем случае с одной строкой кода , эквивалентной восьми инструкциям байт - кода , и двумя программными потоками общее количество возможных путей выполнения равно . Если переменная будет относиться к типу , то каждая операция чтения записи преобразуется в две инструкции вместо одной , а количество путей выполнения достигает , , . Что произойдет , если внести в метод единственное одно изменение ? В этом случае количество возможных путей выполнения сократится до для потоков или до ! в общем случае . Копаем глубже А как же удивительный результат , когда два потока вызывают метод по одному разу до добавления , получая одинаковое число ? Как такое возможно ? Начнем с начала . Атомарной операциейназывается операция , выполнение которой не может быть прервано . Например , в следующем коде строка , где переменной присваивается значение , является атомарной операцией , поскольку в соответствии с моделью памяти присваивание - разрядного значения прерываться не может . : : : : : : : : : : : Что произойдет , если изменить тип с на ? Останется ли строка атомарной ? В соответствии со спецификацией – нет . Она может выполняться как атомарная операция на конкретном процессоре , но по спецификации присваивание - разрядной величины требует двух - разрядных присваивания . Это означает , что между первым и вторым - разрядным присваиванием другой поток может вмешаться и изменить одно из значений . А оператор префиксного увеличения в строке ? Выполнение этого оператора может быть прервано , поэтому данная операция не является атомарной . Чтобы понять , как это происходит , мы подробно проанализируем байт - код обоих методов . Прежде чем двигаться дальше , необходимо усвоить ряд важных определений : Кадр – для каждого вызова метода создается кадр с адресом возврата , значениями всех передаваемых параметров и локальных переменных , определяемых в методе . Это стандартный способ реализации стека вызовов , используемого в современных языках для вызова функций методов – как обычного , так и рекурсивного . Локальная переменная– любая переменная , определяемая в области видимости метода . Все нестатические методы содержат как минимум одну переменную , которая представляет текущий объект , то есть объект , получивший последнее сообщение в текущем потоке , инициировавшее вызов метода . Стек операндов– многим инструкциям передаются параметры . Их значения размещаются в стеке операндов , реализованном в виде стандартной структуры данных - , - , то есть «последним пришел , первым вышел» . Байт - код , сгенерированный для , выглядит так . МнемоникаОписаниеСостояние стека операндов после выполнения Загрузка «нулевой» переменной в стек операндов . Что такое «нулевая» переменная ? Это , текущий объект . При вызове метода получатель сообщения , экземпляр , сохраняется в массиве локальных переменных кадра , созданного для вызова метода . Текущий объект всегда является первой сохраняемой переменной для каждого метода экземпляра _ Занесение константы в стек операндов , Сохранение верхнего значения из стека в поле объекта , который задается ссылкой , хранящейся на один элемент ниже вершины стека пусто Эти три инструкции заведомо атомарны . Хотя программный поток , в котором они выполняются , может быть прерван после выполнения любой инструкции , данные инструкции константа на вершине стека и ссылка на в следующем элементе , вместе со значением поля не могут быть изменены другим потоком . Таким образом , при выполнении присваивания в поле будет гарантированно сохранено значение . Операция является атомарной . Все операнды относятся к информации , локальной для данного метода , что исключает нежелательное вмешательство со стороны других потоков . Итак , если эти три инструкции выполняются десятью потоками , существует . возможных путей выполнения . Так как в данном случае возможен только один результат , различия в порядке выполнения несущественны . Так уж вышло , что одинаковый результат гарантирован в этой ситуации и для . Почему ? Потому что все десять потоков присваивают одну и ту же константу . Даже если их выполнение будет чередоваться , результат не изменится . Но с операцией в методе возникают проблемы . Допустим , в начале метода поле содержит значение . Байт - код нового метода выглядит так . МнемоникаОписаниеСостояние стека операндов после выполнения Загрузка в стек операндов Копирование вершины стека . Теперь в стеке операндов хранятся две копии , Загрузка значения поля объекта , ссылка на который хранится в вершине стека , и занесение загруженного значения в стек , _ Занесение константы в стек , , Целочисленное сложение двух верхних значений в стеке операндов . Результат сложения также сохраняется в стеке операндов , _ Копирование значения и сохранение копии в стеке перед , , Сохранение верхнего значения из стека в поле текущего объекта , который задается ссылкой , хранящейся на один элемент ниже вершины стека Возвращение верхнего и единственного элемента стека пусто Представьте , что первый поток выполняет первые три инструкции до включительно , а потом прерывается . Второй поток получает управление и выполняет весь метод , увеличивая на он получает значение . Затем первый поток продолжает работу с того места , на котором она была прервана значение все еще хранится в стеке операндов , потому что поле в момент выполнения содержало именно это число . Поток увеличивает его на , снова получает и сохраняет результат . В итоге первый поток также получает значение . В результате одно из двух увеличений теряется , так как первый поток «перекрыл» результат второго потока после того как второй поток прервал выполнение первого потока . Проблема решается объявлением метода с ключевым словом . Заключение Чтобы понять , как потоки могут «перебегать дорогу» друг другу , не обязательно разбираться во всех тонкостях байт - кода . Приведенный пример наглядно показывает , чтопрограммные потоки могут вмешиваться в работу друг друга , и этого вполне достаточно . Впрочем , даже этот тривиальный пример убеждает в необходимости хорошего понимания модели памяти , чтобы вы знали , какие операции безопасны , а какие – нет . Скажем , существует распространенное заблуждение по поводу атомарности оператора в префиксной или постфиксной форме , тогда как этот оператор атомарным не является . Следовательно , вы должны знать : • где присутствуют общие объекты значения • какой код может создать проблемы многопоточного чтения обновления • как защититься от возможных проблем многопоточности . Знайте свои библиотеки Как демонстрирует пример . на с . , представленная в библиотека предоставляет расширенные средства управления выполнением программ с использованием пулов программных потоков . Библиотека реализована в виде класса в пакете . . . Если вы создаете потоки , не используя пулы , илииспользуете ручную реализацию пулов , возможно , вам стоит воспользоваться . От этого ваш код станет более чистым , понятным и компактным . Инфраструктура создает пул потоков с автоматическим изменением размера и повторным созданием потоков при необходимости . Также поддерживаютсяфьючерсы– стандартная конструкция многопоточного программирования . Библиотека работает как с классами , реализующими интерфейс , так и с классами , реализующими интерфейс . Интерфейс похож на , но может возвращать результат , а это стандартная потребность в многопоточных решениях . Фьючерсы удобны в тех ситуациях , когда код должен выполнить несколько независимых операций и дождаться их завершения : " " Внешний запрос . . В этом примере метод запускает на выполнение объект , после чего переходит к выполнению других действий . Последняя строка содержит вызов . , который блокирует выполнение вплоть до завершения фьючерса . Неблокирующие решения Виртуальная машина пользуется особенностями архитектуры современных процессоров , поддерживающих надежное неблокирующее обновление . Для примера возьмем класс , использующий синхронизацию а следовательно , блокировку для реализации потоково - безопасного обновления , В для этой цели появился ряд новых классов . , и – всего лишь три примера есть и другие . Приведенный выше фрагмент можно переписать без использования блокировки в следующем виде : . . Хотя эта реализация использует объект вместо примитива и отправляет сообщения например , вместо , по своей производительности этот класс почти всегда превосходит предыдущую версию . Иногда приращение скорости незначительно , но ситуации , в которых он бы работал медленнее , практически не встречаются . Как такое возможно ? Современные процессоры поддерживают операцию , которая обычно называется . Эта операция является аналогом оптимистичной блокировки из теории баз данных , тогда как синхронизированная версия является аналогом пессимистичной блокировки . Ключевое слово всегда устанавливает блокировку , даже если второй поток не пытается обновлять то же значение . Хотя производительность встроенных блокировок улучшается от версии к версии , они по - прежнему обходятся недешево . Неблокирующая версия изначально предполагает , что ситуация с обновлением одного значения множественными потоками обычно возникает недостаточно часто для возникновения проблем . Вместо этого она эффективно обнаруживает возникновение таких ситуаций и продолжает повторные попытки до тех пор , пока обновление не пройдет успешно . Обнаружение конфликта почти всегда обходится дешевле установления блокировки , даже в ситуациях с умеренной и высокой конкуренцией . Как решает эту задачу ? является атомарной операцией . На логическом уровне выглядит примерно так : ! , , Когда метод пытается обновить общую переменную , операция проверяет , что изменяемая переменная все еще имеет последнее известное значение . Если условие соблюдается , то переменная изменяется . Если нет , то обновление не выполняется , потому что другой поток успел ему «помешать» . Метод , пытавшийся выполнить обновление с использованием операции , видит , что изменение не состоялось , и делает повторную попытку . Потоково - небезопасные классы Некоторые классы в принципе не обладают потоковой безопасностью . Несколько примеров : • • Подключения к базам данных . • Контейнеры из . . • Сервлеты . Некоторые классы коллекций содержат отдельные потоково - безопасные методы . Однако любая операция , связанная с вызовом более одного метода , потоково - безопасной не является . Например , если вы не хотите заменять уже существующий элемент , можно было бы написать следующий код : ! . . , По отдельности каждый метод потоково - безопасен , однако другой программный поток может добавить значение между вызовами и . У проблемы есть несколько решений : • Установите блокировку и проследите за тем , чтобы остальные пользователи делали то же самое клиентская блокировка : ! . . , • Инкапсулируйте в собственном объекте и используйте другой серверная блокировка с применением паттерна АДАПТЕР : , , , , . . , • Используйте потоково - безопасные коллекции : , , . , Для выполнения подобных операций в коллекциях пакета . . предусмотрены такие методы , как . Зависимости между методами могут нарушить работу многопоточного кода Тривиальный пример введения зависимостей между методами : Код , использующий : . . Действия с Если этот код выполняется одним потоком , проблем не будет . Но что произойдет , если два потока попытаются одновременно использовать общий экземпляр в предположении , что каждый поток будет обрабатывать полученные значения , но каждый элемент списка обрабатывается только один раз ? В большинстве случаев ничего плохого не произойдет потоки будут совместно обращаться к списку , обрабатывая элементы , полученные от итератора , и завершат работу при завершении перебора . Но существует небольшая вероятность того , что в конце итерации два потока помешают работе друг друга , один поток выйдет за конечную позицию итератора , и произойдет исключение . Проблема заключается в следующем : поток проверяет наличие следующего элемента методом , который возвращает . Поток вытесняется потоком последний выдает тот же запрос , и получает тот же ответ . Поток вызывает метод , который возвращает значение , но с побочным эффектом : после него вызов возвращает . Поток продолжает работу . Полагая , что до сих пор возвращает , он вызывает . Хотя каждый из отдельных методов синхронизирован , клиент использовалдваметода . Проблемы такого рода очень часто встречаются в многопоточном коде . В нашей конкретной ситуации проблема особенно нетривиальна , потому что она приводит к сбою только при завершающей итерации . Если передача управления между потоками произойдет в строго определенной последовательности , то один из потоков сможет выйти за конечную позицию итератора . Подобные ошибки часто проявляются уже после того , как система пойдет в эксплуатацию , и обнаружить их весьма нелегко . У вас три варианта : • Перенести сбои . • Решить проблему , внося изменения на стороне клиента клиентская блокировка . • Решить проблему , внося изменения на стороне сервера , что приводит к дополнительному изменению клиента серверная блокировка . Перенесение сбоев Иногда все удается устроить так , что сбой не приносит вреда . Например , клиент может перехватить исключение и выполнить необходимые действия для восстановления . Откровенно говоря , такое решение выглядит неуклюже . Оно напоминает полуночные перезагрузки , исправляющие последствия утечки памяти . Клиентская блокировка Чтобы класс корректно работал в многопоточных условиях , измените приведенного выше клиента а также всех остальных клиентов следующим образом : ! . . Каждый клиент устанавливает блокировку при помощи ключевого слова . Дублирование нарушает принцип , но оно может оказаться необходимым , если в коде используются инструменты сторонних разработчиков , не обладающие потоковой безопасностью . Данная стратегия сопряжена с определенным риском . Все программисты , использующие сервер , должны помнить об установлении блокировки перед использованием и ее снятии после использования . Много очень много ! лет назад я работал над системой , в которой использовалась клиентская блокировка общего ресурса . Ресурс использовался в сотне разных мест по всей кодовой базе . Один несчастный программист забыл установить блокировку в одном из таких мест . Это была многотерминальная система с разделением времени , на которой выполнялись бухгалтерские программы профсоюза транспортных перевозок . Компьютер находился в зале с фальшполом и кондиционером за миль к северу от управления . В управлении десятки операторов вводили данные на терминалах . Терминалы были подключены к компьютеру по выделенным телефонным линиям с полудуплексными модемами на скорости бит с это было очень , очень давно . Примерно раз в день один из терминалов «зависал» . Никакие закономерности в сбоях не прослеживались . Зависания не были привязаны ни к конкретным терминалам , ни к конкретному времени . Все выглядело так , словно время зависания и терминал выбирались броском кубика . Иногда целые дни проходили без зависаний . Поначалу проблема решалась только перезагрузкой , но перезагрузки было трудно координировать . Нам приходилось звонить в управление и просить всех операторов завершить текущую работу на всех терминалах . После этого мы могли отключить питание и перезагрузить систему . Если кто - то выполнял важную работу , занимавшую час или два , зависший терминал попросту простаивал . Через несколько недель отладки мы обнаружили , что причиной зависания была десинхронизация между счетчиком кольцевого буфера и его указателем . Буфер управлял выводом на терминал . Значение указателя говорило о том , что буфер был пуст , а счетчик утверждал , что буфер полон . Так как буфер был пуст , выводить было нечего но так как одновременно он был полон , в экранный буфер нельзя было ничего добавить для вывода на экран . Итак , мы знали , почему зависали терминалы , но было неясно , из - за чего возникает десинхронизация кольцевого буфера . Поэтому мы реализовали обходное решение . Программный код мог прочитать состояние тумблеров на передней панели компьютера это было очень , очень , очень давно . Мы написали небольшую функцию , которая обнаруживала переключение одного из тумблеров и искала кольцевой буфер , одновременно пустой и заполненный . Обнаружив такой буфер , функция сбрасывала его в пустое состояние . ! Зависший терминал снова начинал выводить информацию . Теперь нам не приходилось перезагружать систему при зависании терминала . Когда нам звонили из управления и сообщали о зависании , мы шли в машинный зал и переключали тумблер . Конечно , иногда управление работало по выходным , а мы – нет . Поэтому в планировщик была включена функция , которая раз в минуту проверяла состояние всех кольцевых буферов и сбрасывала те из них , которые были одновременно пустыми и заполненными . Зависший терминал начинал работать даже до того , как операторы успевали подойти к телефону . Прошло несколько недель кропотливого просеивания монолитного ассемблерного кода , прежде чем была обнаружена причина . Мы занялись вычислениями и определили , что частота зависаний статистически соответствует одному незащищенному использованию кольцевого буфера . Оставалось только найти это одно использование . К сожалению , все это было очень давно . В те времена у нас не было функций поиска , перекрестных ссылок или других средств автоматизации . Нам просто приходилось просматривать листинги . Тогда , холодной зимой года в Чикаго , я узнал важный урок . Клиентская блокировка — полный отстой . Серверная блокировка Дублирование можно устранить внесением следующих изменений в : В клиентском коде также вносятся изменения : . Действия с В этом случае мы изменяем своего класса , чтобы он обладал многопоточной поддержкой . Вместо проверки клиент должен выполнить проверку . В общем случае серверная блокировка предпочтительна по следующим причинам : • Она сокращает дублирование кода – клиентская блокировка заставляет каждого клиента устанавливать соответствующую блокировку сервера . Если код блокировки размещается на сервере , клиенты могут использовать объект , не беспокоясь о написании дополнительного кода блокировки . • Она обеспечивает более высокую производительность – в случае однопоточного развертывания потоково - безопасный сервер можно заменить потоково - небезопасным , устраняя все дополнительные затраты . • Она снижает вероятность ошибок – в случае клиентской блокировки достаточно всего одному программисту забыть установить блокировку , и работа системы будет нарушена . • Она определяет единую политику использования – политика сосредоточена в одном месте на сервере , а не во множестве разных мест то есть у каждого клиента . Она сокращает область видимости общих переменных — клиент не знает ни о переменных , ни о том , как они блокируются . Все подробности скрыты на стороне сервера . Если что - то сломается , то количество мест , в которых следует искать причину , сокращается . Что делать , если серверный код вам неподконтролен ? • Используйте паттерн АДАПТЕР , чтобы изменить и добавить блокировку : . . • ИЛИ еще лучше – используйте потоково - безопасные коллекции с расширенными интерфейсами . Повышение производительности Допустим , вы хотите выйти в сеть и прочитать содержимое группы страниц по списку - адресов . По мере чтения страницы обрабатываются для накопления некоторой статистики . После чтения всех страниц выводится сводный отчет . Следующий класс возвращает содержимое одной страницы по - адресу . … . . . Следующий класс – итератор , предоставляющий содержимое страниц на основании итератора - адресов : , . . . . . Экземпляр может совместно использоваться разными потоками , каждый из которых использует собственный экземпляр для чтения и обработки страниц , полученных от итератора . Обратите внимание : блок очень мал . Он содержит только критическую секцию , расположенную глубоко внутри . Старайтесь синхронизировать как можно меньший объем кода . Вычисление производительности в однопоточной модели Выполним некоторые простые вычисления . Для наглядности возьмем следующие показатели : • Время ввода вывода для получения страницы в среднем : секунда . • Время обработки страницы в среднем : , секунды . • Во время операций ввода вывода процессор загружен на % , а во время обработки – на % . При обработке страниц в однопоточной модели общее время выполнения составляет , секунды . На рис . А . изображен график обработки страниц примерно за , секунды . Картинка : _ . Рис . А . . Обработка страниц в однопоточной модели Вычисление производительности в многопоточной модели Если страницы могут загружаться в произвольном порядке и обрабатываться независимо друг от друга , то для повышения производительности можно воспользоваться многопоточной моделью . Что произойдет , если обработка будет производиться тремя потоками ? Сколько страниц удастся обработать за то же время ? Как видно из рис . А . , многопоточное решение позволяет совмещать процессорно - ориентированную обработку страниц с операциями чтения страниц , ориентированными на ввод вывод . В идеальном случае это обеспечивало бы полную загрузку процессора : каждое чтение страницы продолжительностью в одну секунду перекрывается с обработкой двух страниц . Таким образом , многопоточная модель обрабатывает две страницы в секунду , что втрое превышает производительность однопоточной модели . Картинка : _ . Рис . А . . Обработка тремя параллельными потоками Взаимная блокировка Допустим , у нас имеется веб - приложение с двумя общими пулами ресурсов конечного размера : • Пул подключений к базе данных для локальной обработки в памяти процесса . • Пул подключений к главному хранилищу . В работе приложения используются две операции , создание и обновление : • Создание – получение подключений к главному хранилищу и базе данных . Взаимодействие с главным хранилищем и локальное сохранение данных в базе данных процесса . • Обновление – получение подключений к базе данных , а затем к главному хранилищу . Чтение данных из базы данных процесса и их последующая передача в главное хранилище . Что произойдет , если количество пользователей превышает размеры пулов ? Допустим , каждый пул содержит десять подключений . • Десять пользователей пытаются использовать операцию создания . Они захватывают все десять подключений к базе данных . Выполнение каждого потока прерывается после захвата подключения к базе данных , но до захвата подключения к главному хранилищу . • Десять пользователей пытаются использовать операцию обновления . Они захватывают все десять подключений к главному хранилищу . Выполнение каждого потока прерывается после захвата подключения к главному хранилищу , но до захвата подключения к базе данных . • Десять потоков , выполняющих операцию создания , ожидают подключений к главному хранилищу , а десять потоков , выполняющих операцию обновления , ожидают подключений к базе данных . • Возникает взаимная блокировка . Продолжение работы системы невозможно . На первый взгляд такая ситуация выглядит маловероятной , но кому нужна система , которая гарантированно зависает каждую неделю ? Кому захочется отлаживать систему стакими трудновоспроизводимыми симптомами ? Когда такие проблемы возникают в эксплуатируемой системе , на их решение уходят целые недели . Типичное «решение» основано на включении отладочных команд для получения дополнительной информации о происходящем . Конечно , отладочные команды достаточно сильно изменяют код , взаимная блокировка возникает в другой ситуации , и на повторение ошибки могут потребоваться целые месяцы . Чтобы действительно решить проблему взаимной блокировки , необходимо понять , из - за чего она возникает . Для возникновения взаимной блокировки необходимы четыре условия : • Взаимное исключение . • Блокировка с ожиданием . • Отсутствие вытеснения . • Циклическое ожидание . Взаимное исключение Взаимное исключение возникает в том случае , когда несколько потоков должны использовать одни и те же ресурсы , и эти ресурсы : • не могут использоваться несколькими потоками одновременно • существуют в ограниченном количестве . Типичный пример ресурсов такого рода – подключения к базам данных , открытые для записи файлы , блокировки записей , семафоры . Блокировка с ожиданием Когда один поток захватывает ресурс , он не освобождает его до тех пор , пока не захватит все остальные необходимые ресурсы и не завершит свою работу . Отсутствие вытеснения Один поток не может отнимать ресурсы у другого потока . Если поток захватил ресурс , то другой поток сможет получить захваченный ресурс только в одном случае : если первый поток его освободит . Циклическое ожидание Допустим , имеются два потока и и два ресурса и . Поток захватил , поток захватил . Потоку также необходим ресурс , а потоку также необходим ресурс . Ситуация выглядит так , как показано на рис . А . . Картинка : _ . Рис . А . . Циклическое ожидание Взаимная блокировка возможна только при соблюдении всех четырех условий . Стоит хотя бы одному из них нарушиться , и взаимная блокировка исчезнет . Нарушение взаимного исключения Одна из стратегий предотвращения взаимной блокировки основана на предотвращении состояния взаимного исключения . • Использование ресурсов , поддерживающих многопоточный доступ например , . • Увеличение количества ресурсов , чтобы оно достигло или превосходило количество конкурирующих потоков . • Проверка наличия всех свободных ресурсов перед попытками захвата . К сожалению , большинство ресурсов существует в ограниченном количестве и не поддерживает многопоточное использование . Кроме того , второй ресурс нередко определяется только по результатам обработки первого ресурса . Но не огорчайтесь – остаются еще три условия . Нарушение блокировки с ожиданием Вы также можете нарушить взаимную блокировку , если откажетесь ждать . Проверяйте каждый ресурс , прежде чем захватывать его если какой - либо ресурс занят , освободите все захваченные ресурсы и начните все заново . При таком подходе возможны следующие потенциальные проблемы : • Истощение– один поток стабильно не может захватить все необходимые ему ресурсы уникальная комбинация , в которой все ресурсы одновременно оказываются свободными крайне редко . • Обратимая блокировка– несколько потоков «входят в клинч» : все они захватывают один ресурс , затем освобождают один ресурс… снова и снова . Такая ситуация особенно вероятна при использовании тривиальных алгоритмов планирования процессорного времени встроенные системы простейшие , написанные вручную алгоритмы балансировки потоков . Обе ситуации могут привести к снижению производительности . Первая ситуация оборачивается недостаточным , а вторая – завышенным и малоэффективным использованием процессора . Какой бы неэффективной ни казалась эта стратегия , она все же лучше , чем ничего . По крайней мере , вы всегда можете реализовать ее , если все остальные меры не дают результата . Нарушение отсутствия вытеснения Другая стратегия предотвращения взаимных блокировок основана на том , чтобы потоки могли отнимать ресурсы у других потоков . Обычно вытеснение реализуется на основе простого механизма запросов . Когда поток обнаруживает , что ресурс занят , он обращается к владельцу с запросом на его освобождение . Если владелец также ожидает другого ресурса , он освобождает все удерживаемые ресурсы и начинает захватывать их заново . Данное решение сходно с предыдущим , но имеет дополнительное преимущество : поток может ожидать освобождения ресурса . Это снижает количество освобождений и повторных захватов . Но учтите , что правильно реализовать управление запросами весьма непросто . Нарушение циклического ожидания Это самая распространенная стратегия предотвращения взаимных блокировок . В большинстве систем она не требует ничего , кроме системы простых правил , соблюдаемых всеми сторонами . Вспомните приведенный ранее пример с потоком , которому необходимы ресурс и ресурс , и потоком , которому необходимы ресурс и ресурс . Заставьте поток и поток выделять ресурсы в постоянном порядке , при котором циклическое ожидание станет невозможным . В более общем виде , если все потоки согласуют единый глобальный порядок и будут захватывать ресурсы только в указанном порядке , то взаимная блокировка станет невозможной . Эта стратегия , как и все остальные , может создавать проблемы : • Порядок захвата может не соответствовать порядку использования таким образом , ресурс , захваченный в начале , может не использоваться до самого конца . В результате ресурсы остаются заблокированными дольше необходимого . • Соблюдение фиксированного порядка захвата ресурсов возможно не всегда . Если идентификатор второго ресурса определяется на основании операций , выполняемых с первым ресурсом , то эта стратегия становится невозможной . Итак , существует много разных способов предотвращения взаимных блокировок . Одни приводят к истощению потоков , другие – к интенсивному использованию процессора иухудшению времени отклика . Бесплатный сыр бывает только в мышеловке ! Изоляция потокового кода вашего решения упрощает настройку и эксперименты к тому же это действенный способ сбора информации , необходимой для определения оптимальных стратегий . Тестирование многопоточного кода Как написать тест , демонстрирующий некорректность многопоточного кода ? : : : : : : : Тест , доказывающий некорректность , может выглядеть так : • Запомнить текущее значение . • Создать два потока , каждый из которых вызывает по одному разу . • Убедиться в том , что значение на больше исходного . • Выполнять тест до тех пор , пока в ходе очередного теста не увеличится только на вместо . Код такого теста представлен в листинге А . . Листинг А . . . : : : . . . : : . . : : : @ : : : : Листинг А . продолжение : : . : : : : : . : : : : : . : . : . : . : : . : : ! : : : : " . " : : СтрокаОписание Создание экземпляра . Обратите внимание на необходимость использования ключевого слова , так как ниже объект используется в анонимном внутреннем классе – Создание анонимного внутреннего класса , использующего экземпляр Код выполняется количество раз , достаточное для демонстрации его некорректности , но так , чтобы он не выполнялся «слишком долго» . Необходимо выдержать баланс между двумя целями сбои должны выявляться за разумное время . Подобрать нужное число непросто , хотя , как мы вскоре увидим , его можно заметно сократить Сохранение начального значения . Мы пытаемся доказать , что код некорректен . Если тест проходит , то он доказывает , что код некорректен . Если тест не проходит , то он не доказывает ничего Итоговое значение должно быть на два больше текущего – Создание двух потоков , использующих объект , который был создан в строках – . Два потока , пытающихся использовать один экземпляр , могут помешать друг другу эту ситуацию мы и пытаемся воспроизвести . – Запуск двух потоков – Ожидание завершения обоих потоков с последующей проверкой результатов Сохранение итогового значения – Отличается ли значение от ожидаемого ? Если отличается , вернуть признак завершения теста – доказано , что код работает некорректно . Если нет , попробовать еще раз Если управление передано в эту точку , нашим тестам не удалось доказать некорректность кода за «разумное» время . Либо код работает корректно , либо количество итераций было недостаточным для возникновения сбойной комбинации Бесспорно , этот тест создает условия для выявления проблем многопоточного обновления . Но проблема встречается настолько редко , что в подавляющем большинстве случаев тестирование ее попросту не выявит . В самом деле , для сколько - нибудь статистически значимого выявления проблемы количество итераций должно превышать миллион . Несмотря на это , за десять выполнений цикла из итераций проблема была обнаружена всего один раз . Это означает , что для надежного выявления сбоев количество итераций должно составлять около миллионов . Как долго вы готовы ждать ? Даже если тест будет надежно выявлять сбои на одном компьютере , вероятно , его придется заново настраивать с другими параметрами для выявления сбоев на другом компьютере , операционной системе или версии . А ведь мы взяли очень простую задачу . Если нам не удается легко продемонстрировать некорректность кода в тривиальной ситуации , как обнаружить по - настоящему сложную проблему ? Как ускорить выявление этого простейшего сбоя ? И что еще важнее , как написать тесты , демонстрирующие сбои в более сложном коде ? Как узнать , что код некорректен , если мы даже не знаем , где искать ? Несколько возможных идей . Тестирование методом Монте - Карло . Сделайте тесты достаточно гибкими , чтобы вы могли легко вносить изменения в их конфигурацию . Повторяйте тесты снова и снова скажем , на тестовом сервере со случайным изменением параметров . Если в ходе тестирования будет обнаружена ошибка , значит , код некорректен . Начните писать эти тесты на ранней стадии , чтобы как можно ранее начать их выполнение на сервере непрерывной интеграции . Не забудьте сохранить набор условий , при котором был выявлен сбой . • Выполняйте тесты на каждой целевой платформе разработки . Многократно . Непрерывно . Чем продолжительнее тесты работают без сбоев , тем выше вероятность , что : ? код продукта корректен , либо ? тестирования недостаточно для выявления проблем . Запускайте тесты на машинах с разной нагрузкой . Если вы сможете имитировать нагрузку , близкую к среде реальной эксплуатации , сделайте это . Но даже после выполнения всех этих действий вероятность обнаружения многопоточных проблем в вашем коде оставляет желать лучшего . Самыми коваными оказываются проблемы , возникающие при определенных комбинациях условий , встречающихся один раз на миллиард . Такие проблемы – настоящий бич сложных систем . Средства тестирования многопоточного кода Компания создала программу , которая особым образом готовит классы для повышения вероятности сбоев в потоково - небезопасном коде . Мы не связаны ни с , ни с группой разработки . Об этой программе нам рассказал один из коллег . Оказалось , что всего несколько минут использования радикально повышают вероятность выявления многопоточных сбоев . Тестирование с использованием проходит по следующей схеме : • Напишите тесты и код продукта . Проследите за тем , чтобы тесты были специально спроектированы для имитации обращений от многих пользователей при переменной нагрузке , как упоминалось ранее . • Проведите инструментовку кода тестов и продукта при помощи . • Выполните тесты . Если вы помните , ранее сбой выявлялся примерно один раз за десять миллионов запусков . После инструментовки кода в сбои стали выявляться один раз затридцатьзапусков . Таким образом , сбои в адаптированных классах стали выявляться намного быстрее и надежнее . Заключение В этой главе мы предприняли очень краткое путешествие по огромной , ненадежной территории многопоточного программирования . Наше знакомство с этой темой нельзя назвать даже поверхностным . Основное внимание уделялось методам поддержания чистоты многопоточного кода , но если вы собираетесь писать многопоточные системы , вам придется еще многому научиться . Мы рекомендуем начать с замечательной книги Дуга Ли « : » , . . В этой главе рассматривались опасности многопоточного обновления , а также методы чистой синхронизации и блокировки , которые могут их предотвратить . Мы обсудили , как потоки могут повысить производительность систем с интенсивным вводом выводом , а также конкретные приемы повышения производительности . Также была рассмотрена взаимная блокировка и чистые способы ее предотвращения . Приложение завершается описанием стратегий выявления многопоточных проблем посредством инструментовки кода . Полные примеры кода Однопоточная реализация архитектуры «клиент сервер»Листинг А . . . . . . . . . . . . . . . , . . . " \ " . . " \ " . . . " \ " Листинг А . продолжение ! . . . " : \ " . . . " : : % \ " , . . . " : : % \ " , . , " : " . . " : \ " . ! . ! . Листинг А . . . . . . . . . . . . . . . , . . . " \ " . . " \ " . . . " \ " ! . Листинг А . продолжение . . " : \ " . . . " : : % \ " , . . . " : : % \ " , . , " : " . . " : \ " . ! . ! . Листинг А . . . . . . . . . . . . . . . , . . . . . Архитектура «клиент сервер» с использованием потоков Перевод сервера на многопоточную архитектуру сводится к простому изменению функции новые строки выделены жирным шрифтом : . . " : \ " . . . " : : % \ " , . . . " : : % \ " , . , " : " . . " : \ " . . Приложение Б . . . . Листинг Б . . . : библиотека классов общего назначения для платформы – , . Информация о проекте : : . . . Библиотека распространяется бесплатно вы можете свободно распространять и или изменять ее на условиях лицензии в формулировке либо версии . лицензии , либо на ваше усмотрение любой последующей версии . Библиотека распространяется в надежде , что она будет полезна , но БЕЗ КАКИХ - ЛИБО ГАРАНТИЙ , даже без подразумеваемой гарантии ПРИГОДНОСТИ для КОНКРЕТНОЙ ЦЕЛИ . За подробностями обращайтесь к . Вы должны получить копию лицензии с этой библиотекой если этого не произошло , обратитесь в , . , , , , - , . является зарегистрированной торговой маркой , . в Соединенных Штатах и других странах . - - - - - - - - - - - - - - - . - - - - - - - - - - - - - - - – , . Автор : Дэвид Гилберт для Участники : - $ : . , . : : $ Изменения начиная с октября - - - - - - - - - - - - - - - - - - - - - - - - - - . . : Реорганизация класса и его перемещение в новый пакет . . . . : Добавление метода , исключение класса . . : После удаления класса требует наличия метода исправлены ошибки в функциях , и . . : Исправление ошибки в классе . . : Перемещение констант месяцев в отдельный интерфейс . . : Исправление ошибки в , спасибо ? ? ? . . : Исправление ошибок по информации . . : Реализация . . : Исправление ошибки в методе . . : Реализация . Обновление с для . . : Исправление ошибки в методе . . . . . . . . . . . . Абстрактный класс , определяющий требования для манипуляций с датами без привязки к конкретной реализации . Требование : совпадение с представлением дат в формате Требование : класс должен быть неизменным Почему не использовать . . ? Будем использовать , где это имеет смысл . Класс . . бывмает слишком точным - он представляет момент времени с точностью до секунды при этом сама дата зависит от часового пояса . Иногда бывает нужно просто представить конкретный день скажем , января , не заботясь о времени суток , часовом поясе и т . д . Именно для таких ситуаций определяется класс . Вы можете вызвать для получения конкретного субкласса , не беспокоясь о реализации . @ Листинг Б . продолжение , , Для сериализации . - Символические обозначения формата даты . _ _ . Порядковый номер для января . _ _ Порядковый номер для декабря . _ _ Наименьшее значение года , поддерживаемое форматом даты . _ _ Наибольшее значение года , поддерживаемое форматом даты . _ _ Константа для понедельника , эквивалент . . . . . Константа для вторника , эквивалент . . . . . Константа для среды , эквивалент . . . . . Константа для четверга , эквивалент . . . . . Константа для пятницы , эквивалент . . . . . Константа для субботы , эквивалент . . . . . Константа для воскресенья , эквивалент . . . . . Количество дней в месяцах невисокосного года . _ _ _ , , , , , , , , , , , , Количество дней от начала года до конца месяца в невисокосном годе . _ _ _ _ _ , , , , , , , , , , , , Количество дней до конца предыдущего месяца . _ _ _ _ _ _ , , , , , , , , , , , , , Количество дней от начала года до конца месяца в високосном годе . _ _ _ _ _ _ _ , , , , , , , , , , , , Количество дней до конца предыдущего месяца в високосном годе . _ _ _ _ _ _ _ _ , , , , , , , , , , , , , Константа для обозначения первой недели месяца . _ _ _ Константа для обозначения второй недели месяца . _ _ _ Константа для обозначения третьей недели месяца . _ _ _ Константа для обозначения четвертой недели месяца . _ _ _ Константа для обозначения последней недели месяца . _ _ _ Константа для обозначения типа диапазона . _ Константа для обозначения типа диапазона . _ Константа для обозначения типа диапазона . _ Константа для обозначения типа диапазона . Листинг Б . продолжение _ . - Константа для определения дня недели относительно фиксированной даты . Константа для определения дня недели относительно фиксированной даты . Описание даты . Конструктор по умолчанию . Возвращает , если целое число соответствует действительному дню недели , или в противном случае . @ код , проверяемый на допустимость . @ , если целое число соответствует действительному дню недели , в противном случае . : : : : : : : : Преобразует переданную строку в день недели . @ строка , представляющая день недели . @ - , если строка не преобразуется , день недели в противном случае . _ _ . _ _ . - . . . . Возвращает строку , представляющую заданный день недели . Необходимо поискать более элегантное решение . @ день недели . @ строка , представляющая заданный день недели . _ _ . Листинг Б . продолжение Возвращает массив названий месяцев . @ массив названий месяцев . Возвращает массив названий месяцев . @ флаг , указывающий на необходимость возврата сокращенных названий месяцев . @ массив названий месяцев . _ _ . _ _ . Возвращает , если целое число соответствует действительному месяцу . @ Код , проверяемый на действительность . @ , если целое число соответствует действительному месяцу . : : : : : : : : : : : : : Возвращает квартал для заданного месяца . @ код месяца – . @ квартал , к которому относится месяц . @ . . : : : : : : : : : : : : : " . : . " Возвращает строку , представляющую заданный месяц . Строка возвращается в форме длинного названия месяца из локального контекста по умолчанию . @ месяц . @ строка , представляющая заданный месяц . Листинг Б . продолжение , Возвращает строку , представляющую заданный месяц . Строка возвращается в форме длинного или короткого названия месяца из локального контекста по умолчанию . @ месяц . @ если возвращает сокращенное название месяца . @ строка , представляющая заданный месяц . @ . . , Проверка аргументов … ! " . : . " _ _ . _ _ . - Преобразует строку в код месяца . Метод возвращает одну из констант , , … , , соответствующую заданной строке . Если строка не распознается , метод возвращает - . @ строка для обработки . @ - , если строка не разбирается , месяц года в противном случае . _ _ . _ _ . - . Сначала пытаемся разобрать строку как целое число – … . Подавление Теперь ищем по названиям месяцев … | | . . . Возвращает , если целое число представляет действительную неделю месяца , или в противном случае . @ код , проверяемый на действительность . @ , если целое число представляет действительную неделю месяца . _ _ _ : _ _ _ : _ _ _ : Листинг Б . продолжение _ _ _ : _ _ _ : : Определяет , является ли заданный год високосным . @ год в диапазоне от до . @ , если заданный код является високосным . % ! % % Возвращает количество високосных годов от до заданного года ВКЛЮЧИТЕЛЬНО . Учтите , что год високосным не является . @ год в диапазоне от до . @ количество високосных годов от до заданного года . - - - - Возвращает номер последнего дня месяца с учетом високосных годов . @ месяц . @ год в диапазоне от до . @ номер последнего дня месяца . , _ _ _ ! Создает новую дату , прибавляя заданное количество дней к базовой дате . @ количество прибавляемых дней может быть отрицательным . @ базовая дата . @ новая дата . , . . Создает новую дату , прибавляя заданное количество месяцев к базовой дате . Если базовая дата близка к концу месяца , результат может слегка смещаться : мая месяц июня @ количество прибавляемых месяцев может быть отрицательным . @ базовая дата . Листинг Б . продолжение @ новая дата . , . . - . . - % . . , . , . , , Создает новую дату , прибавляя заданное количество лет к базовой дате . @ количество прибавляемых лет может быть отрицательным . @ базовая дата . @ новая дата . , . . . . , . , . , , Возвращает последнюю дату , приходящуюся на заданный день недели , ПРЕДШЕСТВУЮЩУЮ базовой дате . @ код дня недели . @ базовая дата . @ последняя дата , приходящаяся на заданный день недели , ПРЕДШЕСТВУЮЩАЯ базовой дате . , Проверить аргументы … ! . " - - - . " Определить дату … . . , - - . , - . , Возвращает самую раннюю дату , приходящуюся на заданный день недели ПОСЛЕ базовой даты . @ код дня недели . @ базовая дата . @ самая ранняя дата , приходящаяся на заданный день недели ПОСЛЕ базовой даты . , Проверить аргументы … ! . " - - - . " Определить дату … . . , - Листинг Б . продолжение . , - . , Возвращает дату , приходящуюся на заданный день недели , САМУЮ БЛИЗКУЮ к базовой дате . @ код дня недели . @ базовая дата . @ дата , приходящаяся на заданный день недели , САМАЯ БЛИЗКАЯ к базовой дате . , Проверить аргументы … ! . " - - - . " Определить дату … . - . - - - . , Перемещает дату к последнему дню месяца . @ базовая дата . @ новая дата . . . , . . , . , . Возвращает строку , соответствующую коду недели в месяце . Необходимо поискать более элегантное решение . @ целочисленный код недели в месяце . @ строка , соответствующая коду недели в месяце . . _ _ _ : " " . _ _ _ : " " . _ _ _ : " " . _ _ _ : " " . _ _ _ : " " : " . : . " Возвращает строку , представляющую переданное значение . Необходимо поискать более элегантное решение . @ константа , представляющая значение’ ’ . @ строка , представляющая переданное значение ‘ ’ . . : " " . : " " . : " " : " : " Метод - фабрика , возвращающий экземпляр конкретного субкласса @ . Листинг Б . продолжение @ день – . @ месяц – . @ год в диапазоне от до . @ Экземпляр @ . , , , , Метод - фабрика , возвращающий экземпляр конкретного субкласса @ . @ порядковый номер дня января . @ экземпляр . Метод - фабрика , возвращающий экземпляр субкласса . @ объект даты . @ экземпляр . . . . . . , . . , . . Возвращает порядковый номер для даты , где что почти соответствует системе нумерации , используемой в и - - . @ порядковый номер даты . Возвращает . . . Поскольку . . превосходит по точности , необходимо определить схему выбора ‘времени суток’ . @ текущий объект в виде . . . . . Возвращает описание даты . @ описание даты . . Задает описание даты . @ новое описание даты . . Преобразует дату в строку . @ строковое представление даты . " - " . " - " Возвращает год в действительном диапазоне от до . @ год . Возвращает месяц январь , февраль , март . @ месяц . Листинг Б . продолжение Возвращает день месяца . @ день месяца . Возвращает день недели . @ день недели . Возвращает разность в днях между текущей и заданной ' другой ' датой . Результат положительный , если текущая дата следует после ' другой ' , или отрицателен , если текущая дата предшествует ' другой ' . @ дата для сравнения . @ разность между текущей и другой датой . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . Возвращает , если текущий объект представляет более раннюю дату по сравнению с заданным объектом . @ дата для сравнения . @ , если текущий объект представляет более раннюю дату по сравнению с заданным объектом . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . Возвращает , если текущий @ принадлежит заданному диапазону режим . Порядок дат и не важен . @ граничная дата диапазона . @ другая граничная дата диапазона . @ Логический признак . , Возвращает если текущий @ принадлежит заданному диапазону включение границ указывается при вызове . Порядок дат и не важен . @ граничная дата диапазона . @ другая граничная дата диапазона . Листинг Б . продолжение @ код , управляющий включением начальной и конечной дат в диапазон . @ Логический признак . , , Возвращает последнюю дату , приходящуюся на заданный день недели , ПРЕДШЕСТВУЮЩУЮ текущей дате . @ код дня недели . @ последняя дата , приходящаяся на заданный день недели , ПРЕДШЕСТВУЮЩАЯ текущей дате . , Возвращает самую раннюю дату , приходящуюся на заданный день недели , ПОСЛЕ текущей даты . @ код дня недели . @ самая ранняя дата , приходящаяся на заданный день недели ПОСЛЕ текущей даты . , Возвращает ближайшую дату , приходящуюся на заданный день недели , @ код дня недели . @ ближайшая дата , приходящаяся на заданный день недели , , Листинг Б . . . : библиотека классов общего назначения для платформы – , . Информация о проекте : : . . . Библиотека распространяется бесплатно вы можете свободно распространять и или изменять ее на условиях лицензии в формулировке либо версии . лицензии , либо на ваше усмотрение любой последующей версии . Библиотека распространяется в надежде , что она будет полезна , но БЕЗ КАКИХ - ЛИБО ГАРАНТИЙ , даже без подразумеваемой гарантии ПРИГОДНОСТИ для КОНКРЕТНОЙ ЦЕЛИ . За подробностями обращайтесь к . Вы должны получить копию лицензии с этой библиотекой если этого не произошло , обратитесь в , . , , , , - , . является зарегистрированной торговой маркой , . в Соединенных Штатах и других странах . - - - - - - - - - - - - - - - - - - - - . - - - - - - - - - - - - - - - - - - - - – , . Автор : Дэвид Гилберт для Участники : - $ : . , . : : $ Изменения - - - - - - - - - - - - - - - - - - - - - - - - - - . . : Версия . . : Удаление лишнего импорта . . : Исправление ошибок по информации . . : Добавление теста сериализации . . : Добавление теста для ошибки по отчету . . . . . . . Листинг Б . продолжение . . . . . . . . . . . . . . . . . . . . Тесты для класса @ . Дата , представляющая ноября . Создает новый тестовый сценарий . @ . Возвращает пакет тестов для системы запуска тестов . @ тестовый пакет . . Подготовка задачи . . . , . , ноября месяца должно быть января . . , . . , , , Тестовый сценарий для известной ошибки исправлено . . , . , . , , . , . , Тестовый сценарий для известной ошибки исправлено . . , . , . , , Понедельник , предшествующий ноября , - должно быть ноября . . . , . , . Понедельник , следующий за ноября , - должно быть ноября . . . , . , . Понедельник , ближайший к ноября , - должно быть ноября . . . , . , . Листинг Б . продолжение Понедельник , ближайший к января , - должно быть - е января . . , . , . . , , . Проверяет преобразование дней в строки . На самом деле результат зависит от локального контекста , так что тест следует изменить . . . " " , Проверяет преобразование строки в день недели . Если в локальном контексте не используются английские названия дней недели , тест не пройдет улучшить ! . " " . , . " " . , . " " . , Проверяет преобразование строки в месяц . Если в локальном контексте не используются английские названия месяцев , тест не пройдет улучшить ! . " " . , . " " . , . " " . , Проверяет преобразование кода месяца в строку . . . " " , Год не является високосным . ! . Год - високосный . . Количество високосных годов с до включительно равно . . , Количество високосных годов с до включительно равно . . , Количество високосных годов с до включительно равно . . , Листинг Б . продолжение Количество високосных годов с до включительно равно . . , Количество високосных годов с до включительно равно . . , Сериализовать экземпляр , восстановить и проверить на равенство . . , , . . . . . . . . , Тест для ошибки по отчету исправлено . . , , . , . , , . Различные тесты для метода . . , , . , , . , . , . . , , . , . , . . , . , , . , . , . Листинг Б . . . : библиотека классов общего назначения для платформы – , . Информация о проекте : : . . . Библиотека распространяется бесплатно вы можете свободно распространять и или изменять ее на условиях лицензии в формулировке либо версии . лицензии , либо на ваше усмотрение любой последующей версии . Библиотека распространяется в надежде , что она будет полезна , но БЕЗ КАКИХ - ЛИБО ГАРАНТИЙ , даже без подразумеваемой гарантии ПРИГОДНОСТИ для КОНКРЕТНОЙ ЦЕЛИ . За подробностями обращайтесь к . Вы должны получить копию лицензии с этой библиотекой если этого не произошло , обратитесь в , . , , , , - , . является зарегистрированной торговой маркой , . в Соединенных Штатах и других странах . - - - - - - - - - - - - - - - - - - - . Листинг Б . продолжение - - - - - - - - - - - - - - - - - - - , , . Автор : Дэвид Гилберт для Участники : - $ : . , . : : $ Изменения - - - - - - - . . : Версия код перемещен из класса . . Константы месяцев . Обратите внимание : константы НЕ ЭКИВАЛЕНТНЫ определяемым в . . где , а . Используются классами и . @ Дэвид Гилберт Константа для января . Константа для февраля . Константа для мая . Константа для апреля . Константа для мая . Константа для июня . Константа для июля . Константа для августа . Константа для сентября . Константа для октября . Константа для ноября . Константа для декабря . Листинг Б . . . . . . . . . . . . . . . . . - , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " Листинг Б . продолжение , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " " " , " " , " " , " " , " " , " " , " " , , , , , , , , , , , , , - " " " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , , " " , , " " , , " " , , " " , , " " , , " " , , " " , , " " , , " " , , " " , , " " , , - " " Листинг Б . продолжение , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " - , " " - , " " - , " " , , , , , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " Листинг Б . продолжение , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , - , , , " " , , , , , , , , , , , , , , , , , , - , , , " " , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , Листинг Б . . продолжение , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , - , , , " " . , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , , , , . , , " " , _ _ _ " " , _ _ _ " " , _ _ _ " " , _ _ _ " " , _ _ _ - " " " " , " " , " " , - " " , , , . , . , . , . , , , Листинг Б . . продолжение , , , , , , , , . , , , , , . . . . . Листинг Б . . . : библиотека классов общего назначения для платформы – , . Информация о проекте : : . . . Библиотека распространяется бесплатно вы можете свободно распространять и или изменять ее на условиях лицензии в формулировке либо версии . лицензии , либо на ваше усмотрение любой последующей версии . Библиотека распространяется в надежде , что она будет полезна , но БЕЗ КАКИХ - ЛИБО ГАРАНТИЙ , даже без подразумеваемой гарантии ПРИГОДНОСТИ для КОНКРЕТНОЙ ЦЕЛИ . За подробностями обращайтесь к . Вы должны получить копию лицензии с этой библиотекой если этого не произошло , обратитесь в , . , , , , - , . является зарегистрированной торговой маркой , . в Соединенных Штатах и других странах . - - - - - - - - - - - - - - - - - - - - . - - - - - - - - - - - - - - - - - - - - – , . Автор : Дэвид Гилберт для Участники : - $ : . , . : : $ Изменения - - - - - - - . . : Версия . . : Добавлены методы и . . : Переименование . в . Исправлена ошибка в вычислении дня , месяца и года по порядковому номеру . . : Исправлена ошибка в вычислении порядкового номера по дню , месяцу и году . Спасибо Тревору Хиллзу за сообщение . . : Добавлен метод . . : Исправлены ошибки по информации . . : Реализован интерфейс . . : Завершены методы . . : Реализован интерфейс . . : Добавлен метод . . . . . . Представляет дату с использованием целого числа , по аналогии с реализацией в . Поддерживаемый диапазон дат : с января по декабря . Учтите , что в существует намеренная ошибка , вследствие которой год считается високосным , тогда как в действительности он таковым не является . Дополнительная информация приведена на сайте в статье : : . . . считает , что января . Этот класс считает , что января . В результате номер дня этого класса будет отличаться от номера в январе и феврале … но затем прибавляет лишний день февраля , который в действительности не существует ! , и с этого момента нумерация дней совпадает . @ Дэвид Гилберт Для сериализации . - Листинг Б . продолжение Номер дня . . , . . , … , . . . День месяца от до , , или в зависимости от месяца . Месяц года от по . Год от до . Необязательное описание даты . Создает новый экземпляр даты . @ день в диапазоне от до . @ месяц в диапазоне от до . @ год в диапазоне от до . , , . " ' ' . " . . . " ' ' . " . , . " ' ' . " Порядковый номер должен синхронизироваться с днем - месяцем - годом … . , , . Стандартный конструктор - создает новый объект даты , представляющий день с заданным номером в диапазоне от до . @ порядковый номер дня диапазон : от до . _ _ _ _ . " : . " День - месяц - год должен синхронизироваться с порядковым номером … Возвращает описание , присоединенное к дате . Дата не обязана иметь описание , но в некоторых приложениях оно может оказаться полезным . @ описание , присоединенное к дате . . Задает описание для даты . @ описание даты разрешается . . Листинг Б . продолжение Возвращает порядковый номер даты , где января что почти соответствует системе нумерации , используемой в и - - . @ порядковый номер даты . . Возвращает объект . . , эквивалентный текущей дате . @ объект даты . . . , - , , , , . Возвращает год из действительного диапазона от до . @ год . . Возвращает месяц январь , февраль , март . @ месяц года . . Возвращает день месяца . @ день месяца . . Возвращает код , представляющий день недели . Коды определяются в классе @ следующим образом : , , , , , и . @ Код , представляющий день недели . . % Проверяет равенство текущей даты с другим произвольным объектом . Метод возвращает ТОЛЬКО в том случае , если объект является экземпляром базового класса @ и представляет тот же день , что и @ . @ объект для сравнения допускается . @ Логический признак . . . Возвращает хеш - код для экземпляра класса . @ хеш - код . Возвращает разность в днях между текущей и заданной ' другой ' датой . @ дата для сравнения . Листинг Б . продолжение @ разность в днях между текущий и заданной ' другой ' датой . . - . Реализует метод , необходимый для интерфейса . @ другой объект обычно другой объект . @ отрицательное целое , нуль или положительное целое число , если объект меньше , равен или больше заданного объекта . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . . . Возвращает , если текущий объект представляет более раннюю дату по сравнению с заданным объектом . @ дата для сравнения . @ , если текущий объект представляет более раннюю дату по сравнению с заданным объектом . . . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . . . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . . . Возвращает , если текущий объект представляет ту же дату , что и заданный объект . @ дата для сравнения . @ , если текущий объект представляет ту же дату , что и заданный объект . . . Возвращает , если текущий объект @ принадлежит заданному диапазону режим . Порядок дат и не важен . @ граничная дата диапазона . @ другая граничная дата диапазона . @ логический признак . , , , . _ Возвращает , если текущий объект принадлежит Листинг Б . продолжение заданному диапазону включение границ указывается при вызове . Порядок и не важен . @ граничная дата диапазона . @ другая граничная дата диапазона . @ код , управляющий включением начальной и конечной дат в диапазон . @ , если текущий объект принадлежит заданному диапазону . , , . . . , . , . _ . _ . _ Вычисляет порядковый номер по дню , месяцу и году . января . @ день . @ месяц . @ год . @ порядковый номер для заданного дня , месяца и года . , , - . - . _ _ _ _ _ _ . . Вычисляет день , месяц и год по порядковому номеру . Вычислить год по порядковому номеру . - _ _ Переоценка из - за проигнорированных високосных дней . . - Недооценка из - за переоцененных лет . . , , . , , . - , , . _ _ _ _ _ _ . _ _ _ _ _ _ _ _ Получение месяца по порядковому номеру - . - . - Листинг Б . продолжение Остается . . - - . Листинг Б . . . : библиотека классов общего назначения для платформы – , . Информация о проекте : : . . . Библиотека распространяется бесплатно вы можете свободно распространять и или изменять ее на условиях лицензии в формулировке либо версии . лицензии , либо на ваше усмотрение любой последующей версии . Библиотека распространяется в надежде , что она будет полезна , но БЕЗ КАКИХ - ЛИБО ГАРАНТИЙ , даже без подразумеваемой гарантии ПРИГОДНОСТИ для КОНКРЕТНОЙ ЦЕЛИ . За подробностями обращайтесь к . Вы должны получить копию лицензии с этой библиотекой если этого не произошло , обратитесь в , . , , , , - , . является зарегистрированной торговой маркой , . в Соединенных Штатах и других странах . - - - - - - - - - - - - - - - - - - - - - - - - - - . - - - - - - - - - - - - - - - - - - - - - - - - - - – , . Автор : Дэвид Гилберт для Участники : - $ : . , . : : $ Изменения начиная с октября - - - - - - - - - - - - - - - - - - - - - - - - - - - - : Пакет изменен на . . . - - : Исправлены ошибки по информации . . Правило ежегодной даты , возвращающее дату для каждого года на основании эталонного правила б дня недели и в параметра выбора . . , . , . . Например , Страстная пятница может задаваться как ' пятница , ПРЕДШЕСТВУЮЩАЯ Пасхе ' . @ Дэвид Гилберт Ссылка на правило ежегодной даты , на котором основано данное правило . День недели . , . и т . д . . Признак выбора дня недели , или . Конструктор по умолчанию - строит правило для понедельника после января . , . , . Стандартный конструктор - строит правило на основании субправила . @ правило , определяющее эталонную дату . @ день недели по отношению к эталонной дате . @ признак выбора дня недели , или . , , . . . Листинг Б . продолжение Возвращает субправило также называемое эталонным правилом . @ Правило ежегодной даты , определяющее эталонную дату для текущего правила . . Назначает субправило . @ Правило ежегодной даты , определяющее эталонную дату для текущего правила . . Возвращает день недели для текущего правила . @ день недели для текущего правила . . Назначает день недели для текущего правила . @ день недели . , . и т . д . . . Возвращает атрибут ‘ ’ , который определяет , какой день недели нас интересует . , . или . . @ атрибут ' ' . . Задает атрибут ' ' . , . , . . @ определяет , какой день недели выбирается текущим правилом . . Создает копию текущего правила . @ копия текущего правила . @ . . . . . Возвращает дату , сгенерированную текущим правилом для заданного года . @ год год . @ дата , сгенерированная правилом для заданного года допускается . Проверить аргумент … . _ _ | | . _ _ " . : . " Вычислить дату … . . ! . . : . . , Листинг Б . продолжение . : . . , . : . . , : Листинг Б . . . окончательная версия : библиотека классов общего назначения для платформы – , . … . . . . . . Абстрактный класс , представляющий неизменяемые даты с точностью до одного дня . Реализация отображает дату на целое число , представляющее смещение в днях от фиксированной точки отсчета . Почему не использовать . . ? Будем использовать , где это имеет смысл . Класс . . бывает слишком точным - он представляет момент времени с точностью до секунды при этом сама дата зависит от часового пояса . Иногда бывает нужно просто представить конкретный день скажем , января , не заботясь о времени суток , часовом поясе и т . д . Именно для таких ситуаций определяется класс . Для создания экземпляра используется . . @ Дэвид Гилберт @ Роберт С . Мартин провел значительную переработку . , . . - . . % . . . , , . , , , , . , , , , . , . - . - . - . . - . % - Листинг Б . продолжение . , . , , . . - . . . , , , , , . . « % - % - % » , , , . - . . % . . . - . . . . . . , , , . , , . . , . . . , . . , , Листинг Б . . . окончательная версия . . . . , , , , , , , , , , , _ _ _ , , , , , , , , , , , , . : . . " " _ _ _ - Листинг Б . продолжение . - . - . : . . . « « . | | . Листинг Б . . . окончательная версия . . . . . . . , . , . , . , . , . , . : . . . « : % . » , . . . : . . . | | . . . " % " , . Листинг Б . . . окончательная версия . . , , , _ , , , _ , , , , , , , Листинг Б . . . окончательная версия . . , , , , . Листинг Б . . . окончательная версия . . , , Листинг Б . . . окончательная версия . . . . . % % % ! | | , . . . - - - - Листинг Б . . . окончательная версия . . . _ _ , , _ , , _ . . _ _ . _ , , . _ , , , , . _ , , . . Листинг Б . продолжение . _ . _ . _ Листинг Б . . . окончательная версия . . . . _ _ , , , , _ , , , , _ . . . , . . . , . . _ . _ _ _ . _ _ Листинг Б . . . окончательная версия : библиотека классов общего назначения для платформы – , . … . . . . . . . . Представляет дату с использованием целого числа , по аналогии с реализацией в . Поддерживаемый диапазон дат : с января по декабря . Учтите , что в существует намеренная ошибка , вследствие которой год считается високосным , тогда как в действительности он таковым не является . Дополнительная информация приведена на сайте в статье : : . . . По правилам января . По правилам этого класса января . В результате номер дня этого класса будет отличаться от номера в январе и феврале … но затем прибавляет лишний день февраля , который в действительности не существует ! , и с этого момента нумерация дней совпадает . @ _ _ _ _ _ _ _ _ _ _ _ _ _ _ , , , , , , , , , , , , , _ _ _ _ _ _ _ _ , , , , , , , , , , , , , Листинг Б . продолжение , , _ _ | | _ _ " ' ' " _ _ " " _ _ " . " | | . , " ' ' . " . . . , , , , , . , _ _ | | _ _ " : . " . ! . , , . - - _ _ _ _ _ _ _ _ . . . . - _ _ - _ _ _ _ - . _ _ , , - - . , - . - . _ _ _ _ _ _ _ _ - _ _ _ _ _ _ - , Листинг Б . продолжение - , . , . . . , . . . , . . Приложение . Перекрестные ссылки Перекрестные ссылки для «запахов кода» и эвристических правил из приложения А организованы по принципу Номер _ главы - Номер _ страницы . – , – , – – , – , – , – - $ # , – , – , – , – – – – – – , – – – – , – , – – , – – , – – , – – , – – , – , – , – , – – , – , – , – , – , – , – – , – – , – – , – , – , – – , – , – – , – , – , – , – – , – , – , – , – , – – , – , – – , – – , – – , – – , – , – – , – , – , – – , – , – – , – – , – – , – – , – , – , – – , – – , – – – – , – – , – – , – – , – – , – – , – – , – , – – , – – , – – , – – , – – , – , – – , – , – , – , – , – , – , – , – – , – – , – , – – , – , – – , – , – – , – – , – – , – , – – , – – , – – – , – , – – , – – , – – , – – Эпилог На конференции по гибким методологиям , проходившей в Денвере в году , Элизабет Хедриксон вручила мне зеленый браслет наподобие тех , которые стали такими популярными после Ланса Армстронга . На браслете было написано «Одержим тестированием» . Я с гордостью носил этот браслет . С тех пор как Кент Бек научил меня методологии разработки через тестирование в году , я действительно стал буквально одержим этой темой . Но потом случилось нечто странное . Я обнаружил , что не могу снять этот браслет , причем вовсе не потому , что он застрял у меня на запястье . Браслет открыто формулировал мою профессиональную этику . Он стал визуальным признаком моего стремления к написанию самого лучшего кода , который я могу написать . Мне казалось , что снять его –значит предать эту этику вместе с моими устремлениями . Браслет так и остается у меня на запястье . Занимаясь программированием , я вижу его периферийным зрением . Он постоянно напоминает мне о том обещании , которое я дал сам себе – обещании писать чистый код . Картинка : _ . Примечания Когда Игнац Земмельвейс в году впервые порекомендовал врачам мыть руки перед осмотром пациентов , его советы были отвергнуты на том основании , что у врачей слишком много работы и на мытье рук у них нет времени . : . . - . . Из прощального послания Роберта Стивенсона Смита Баден - Пауэлла скаутам : «Постарайтесь оставить этот мир чуть лучшим , чем он был до вашего прихода…» Как будет показано ниже , даже если контейнердействительнопредставляет собой , лучше обойтись без кодирования типа контейнера в имени . Для примера можно привести совершенно отвратительную привычку создавать переменную только из - за того , что имя было использовано для других целей . Дядюшка Боб действовал так при программировании на , но потом бросил эту привычку , потому что благодаря современным она стала излишней . : . . . . «Святая ручная граната» — оружие огромной разрушительной силы из фильма «Монти Пайтон и Священный Грааль» . —Примеч . перев . Из мультипликационного сериала «Симпсоны» . —Примеч . перев . Тестовая программа , распространяемая с открытым кодом — . . . Программа модульного тестирования для , распространяемая с открытым кодом — . . . Я спросил Кента , не сохранилась ли у него эта программа , но ему не удалось ее найти . Обшарил все свои старые компьютеры — тоже безуспешно . Остались лишь мои воспоминания об этой программе . В языке ключевое слово использовалось так же , как в и используется « » . Таким образом , каждая функция начиналась со слова « » . Разумеется , сюда же относятся и длинные цепочки . : . . _ _ : . . . . : . . _ : . . . . Я только что завершил переработку модуля , использовавшего бинарную форму . Мне удалось преобразовать в поле класса и привести все вызовы к унарной форме . Результат получился гораздо более наглядным . Люди , считавшие , что они смогут обойтись без перекомпиляции и повторного развертывания , были пойманы и сурово наказаны . Пример принципа открытости закрытости . Принцип . , . . Прямоугольник представляет диапазон «сигма » выше и ниже среднего значения . Да , я знаю , что распределение длин файлов не является нормальным , поэтому стандартное отклонение не может считаться математически точным . Но я и не стремлюсь к точности . Я хочу лишь дать представление о происходящем . Кого я пытаюсь обмануть ? Я так и остался ассемблерным программистом . Парня можно разлучить с «металлом» , но в душе «металл» все равно живет ! У проблемы существуют обходные решения , хорошо известные опытным объектно - ориентированным программистам : например , паттерн ПОСЕТИТЕЛЬ или двойная диспетчеризация . Но у этих приемов имеются собственные издержки , к тому же они обычно возвращают структуру к состоянию процедурной программы . : . . _ _ Иногда это называется «функциональной завистью» — из . См . описание паттерна АДАПТЕР в . - , . , , , . , . , . – : . . . . . : . . . См . «Избегайте мысленных преобразований» , с . . См . запись в блоге Дейва Астела : : . . . ? . Учебные материалы . За более подробной информацией об этом принципе обращайтесь к . Например , см . . См . и описание . . Не забывайте , что отложенная инициализация — всего лишь разновидность оптимизации… и возможно , преждевременная ! Система управления базами данных . За общей информацией об аспектах обращайтесь к , а за конкретной информацией об — к и . То есть без необходимости ручного редактирования целевого кода . См . , и . Более подробные примеры посредников и его использования можно найти , например , в . Методологию АОП иногда путают с приемами , используемыми для ее реализации например перехватом методов и «инкапсуляцией» посредников . Подлинная ценность АОП - системы заключается в способности модульного , компактного определения системного поведения . См . и . «Непосредственно на уровне » в данном случае означает «без применения » . По материалам : . . . ? . Приведенный пример можно упростить — существуют специальные механизмы , использующие правила конфигурации и аннотации для сокращения объема явно определяемой «связующей» логики . По материалам : . . - - - - - . . См . и . Не путайте с полезной практикой упреждающего проектирования . — привычка проектировать заранеевсе без исключения , до написания какого - либо кода реализации . Впрочем , даже после начала строительства идут серьезные итеративные исследования и обсуждения подробностей . Выражение «физика программного продукта» впервые было использовано в . Работа оказала особенно заметное влияние на сообщество разработчиков ПО . Например , см . . — хороший пример , создавшего свой предметно - ориентированный язык . Фазы Луны , космические лучи и т . д . См . раздел «Копаем глубже» на с . . См . раздел «Пути выполнения» на с . . См . раздел «Пример архитектуры «клиент сервер»» на с . . Также встречается термин «активная блокировка» . —Примеч . перев . : . . - : . . - _ : . . _ _ См . раздел «Зависимости между методами могут нарушить работу многопоточного кода» , с . . «Критической секцией» называется любой фрагмент кода , который должен быть защищен от одновременного использования несколькими программными потоками . См . раздел «Увеличение производительности» , с . . См . раздел «Взаимная блокировка» , с . . А вы знаете , что потоковая модель не гарантирует вытесняющей многопоточности ? В большинстве современных ОС поддерживается вытесняющая многопоточность , которую вы фактически получаете автоматически . И все же ее не гарантирует . Строго говоря , это не совсем так . Поскольку не гарантирует вытесняющей многопоточности , конкретный алгоритм может всегда работать в ОС , не поддерживающей вытеснения . Обратное тоже возможно , но по другим причинам . : . . . Недавно я переписал этот модуль на . Код занимает в раз меньше места и имеет более качественную структуру . Чтобы предотвратить подобные сюрпризы в будущем , я добавил новый модульный тест , который запускал все тесты . , , ’ , , . . См . раздел «Правило бойскаута» на с . . А еще правильнее было бы считать в все комментарии заранее отформатированными , чтобы они одинаково смотрелись в коде и в документации . : . . _ _ _ А конкретно — принцип единой ответственности , принцип открытости закрытости и принцип сокрытия реализаций . См . . Знать , как работает ваш код , и знать , делает ли алгоритм то , что требуется , — не одно и то же . Не уверены в правильности выбора алгоритма ? Нередко это суровая правда жизни . Но если вы не уверены в том , что делает ваш код , то это обычная лень . См . цитату Уорда Каннингема на с . . . Вы можете убедиться в этом сами , тестируя код до и после внесения изменений . Однопоточный код приведен на с . , а многопоточный – на с . . Это несколько упрощенное объяснение . Впрочем , для целей нашего обсуждения мы воспользуемся этой упрощенной моделью . На самом деле интерфейс в принципе не обладает потоковой безопасностью . Он не проектировался с расчетом на многопоточное использование , так что этот факт не вызывает удивления . Кто - то добавляет отладочный вывод , и проблема «исчезает» . Отладочный код «решил» проблему , поэтому он остается в системе . : . . . . : . . Скачано с КулЛиб , : .